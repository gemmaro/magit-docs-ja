This is magit.ja.info, produced by makeinfo version 6.7 from
magit.ja.texi.

     Copyright (C) 2015-2021 Jonas Bernoulli <jonas@bernoul.li>

     You can redistribute this document and/or modify it under the terms
     of the GNU General Public License as published by the Free Software
     Foundation, either version 3 of the License, or (at your option)
     any later version.

     This document is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

INFO-DIR-SECTION Magit文書翻訳
START-INFO-DIR-ENTRY
* Magit(ja): (magit.ja).     MagitでEmacsのGitを使用する。
END-INFO-DIR-ENTRY


File: magit.ja.info,  Node: Top,  Next: Introduction,  Up: (dir)

Magit User Manual
*****************

Magitは、バージョン管理システムGitへのインターフェースであり、Emacsパッ
ケージとして実装されています。Magitは完全なGit磁器を目指しています。
MagitがすべてのGitコマンドをラップして改善するとは(まだ)主張できませんが
、経験豊富なGitユーザーでさえEmacs内から直接毎日のバージョン管理タスクの
ほとんどすべてを実行できるほど十分に完全です。多くの優れたGitクライアン
トが存在しますが、磁器と呼ばれるのはMagitとGit自体だけです。(訳注:低レベ
ルのを配管(plumbing)コマンド、よりユーザーフレンドリーなのを磁器
(porcelain)コマンドと称する)

This manual is for Magit version 3.2.1 (v3.2.1-24-gb8e64dcb9+1).

     Copyright (C) 2015-2021 Jonas Bernoulli <jonas@bernoul.li>

     You can redistribute this document and/or modify it under the terms
     of the GNU General Public License as published by the Free Software
     Foundation, either version 3 of the License, or (at your option)
     any later version.

     This document is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

* Menu:

* Introduction::
* Installation::
* Getting Started::
* Interface Concepts::
* Inspecting::
* Manipulating::
* Transferring::
* Miscellaneous::
* Customizing::
* 配管コマンド(Plumbing)::
* FAQ::
* Debugging Tools::
* Keystroke Index::
* Command Index::
* Function Index::
* Variable Index::

— The Detailed Node Listing —



Installation



* Installing from Melpa::
* Installing from the Git Repository::
* Post-Installation Tasks::

Interface Concepts



* Modes and Buffers::
* Sections::
* 一時的(transient)コマンド::
* 一時的引数とバッファ変数::
* Completion(補完)とConfirmation(確認)とSelection(選択範囲): Completion Confirmation(確認補完)とSelection(選択範囲).
* Running Git::

Modes and Buffers



* バッファの切り替え::
* バッファの名付け::
* Quitting Windows::
* Automatic Refreshing of Magit Buffers::
* Automatic Saving of File-Visiting Buffers::
* Automatic Reverting of File-Visiting Buffers::



Sections



* Section Movement::
* Section Visibility::
* Section Hooks::
* Section Types and Values::
* Section Options::



Completion(補完)とConfirmation(確認)とSelection(選択範囲)



* アクションの確認::
* 補完と確認::
* 選択範囲::
* ハンク内部リージョン::
* 補完フレームワークのサポート::
* 追加の補完オプション::



Running Git



* Viewing Git Output::
* Git Process Status::
* Gitを手動で実行::
* Git実行ファイル::
* Global Git Arguments::



Inspecting



* Status Buffer::
* Repository List::
* Logging::
* Diffing::
* Ediffing::
* References Buffer::
* Bisecting::
* Visiting Files and Blobs::
* Blaming::

Status Buffer



* Status Sections::
* Status Header Sections::
* Status Module Sections::
* Status Options::



Logging



* Refreshing Logs::
* Log Buffer::
* Log Margin::
* Select from Log::
* Reflog::
* Cherries::



Diffing



* Refreshing Diffs::
* Commands Available in Diffs::
* Diff Options::
* Revision Buffer::



References Buffer



* References Sections::



Visiting Files and Blobs



* General-Purpose Visit Commands::
* Visiting Files and Blobs from a Diff::



Manipulating



* Creating Repository::
* Cloning Repository::
* Staging and Unstaging::
* Applying::
* Committing::
* Branching::
* Merging::
* Resolving Conflicts::
* Rebasing::
* Cherry Picking::
* Resetting::
* Stashing::

Staging and Unstaging



* Staging from File-Visiting Buffers::



Committing



* コミット開始::
* コミットメッセージ編集::



Branching



* The Two Remotes::
* Branch Commands::
* Branch Git Variables::
* Auxiliary Branch Commands::



Rebasing



* Editing Rebase Sequences::
* Information About In-Progress Rebase::



Cherry Picking



* Reverting::



Transferring



* Remotes::
* Fetching::
* Pulling::
* Pushing::
* Plain Patches::
* Maildir Patches::

Remotes



* Remote Commands::
* Remote Git Variables::



Miscellaneous



* Tagging::
* Notes::
* Submodules::
* Subtree::
* Worktree::
* Common Commands::
* Wip Modes::
* Commands for Buffers Visiting Files::
* Minor Mode for Buffers Visiting Blobs::

Submodules



* Listing Submodules::
* 一時的サブモジュール::



Wip Modes



* Wip Graph::
* Legacy Wip Modes::



Customizing



* Per-Repository Configuration::
* 基本設定::

基本設定



* Safety::
* Performance::
* Default Bindings::



配管コマンド(Plumbing)



* Calling Git::
* Section Plumbing::
* Refreshing Buffers::
* 慣習::

Calling Git



* Getting a Value from Git::
* Calling Git for Effect::



Section Plumbing



* Creating Sections::
* Section Selection::
* Matching Sections::



慣習



* Theming Faces::



FAQ



* FAQ - How to ...?::
* FAQ - Issues and Errors::

FAQ - How to ...?



* Magitの発音は？::
* How to show git's output?::
* How to install the gitman info manual?::
* How to show diffs for gpg-encrypted files?::
* How does branching and pushing work?::
* Magitをediff-version-control-packageとして使用できますか？::
* VC@を無効にする必要がありますか？::



FAQ - Issues and Errors



* Magit is slow::
* 一度に数千のファイルを変更したらMagitが使用できなくなりました::
* コミットに問題があります::
* MS WindowsではMagitでpushできません::
* I am using OS X and SOMETHING works in shell, but not in Magit: I am using OS X and SOMETHING works in shell but not in Magit.
* ファイルを展開して差分を表示するとファイルが消えます::
* COMMIT_EDITMSGバッファのpointが間違っています::
* モード行の情報が常に最新ではない::
* 同じ名前を共有するブランチとタグは何かを壊します::
* 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません::
* コマンドラインからコミットする場合、git-commit-modeは使用されません::
* file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内に表示されています::
* MS-WindowsからEmacsのTrampモードを使用するとステージできません::
* 私はポップアップのデフォルトを保存できなくなりました::





File: magit.ja.info,  Node: Introduction,  Next: Installation,  Prev: Top,  Up: Top

1 Introduction
**************

Magitは、バージョン管理システムGitへのインターフェースであり、Emacsパッ
ケージとして実装されています。Magitは完全なGit磁器を目指しています。
MagitがすべてのGitコマンドをラップして改善するとは(まだ)主張できませんが
、経験豊富なGitユーザーでさえEmacs内から直接毎日のバージョン管理タスクの
ほとんどすべてを実行できるほど十分に完全です。多くの優れたGitクライアン
トが存在しますが、磁器と呼ばれるのはMagitとGit自体だけです。(訳注:低レベ
ルのを配管(plumbing)コマンド、よりユーザーフレンドリーなのを磁器
(porcelain)コマンドと称する)

ステージやその他の変更の適用は、Git磁器の最も重要な機能の1つであり、ここ
でMagitは、Git自体を含む他のどれよりも優れています。Git独自のステージイ
ンターフェース(‘git add --patch’)は非常に扱いにくいため、多くのユーザー
は例外的な場合にのみ使用します。 Magitでは、ハンクまたはハンクの一部をス
テージすることは、ファイルに加えられたすべての変更をステージするのと同じ
くらい簡単です。(訳注:ハンク(hunk) 大きなかたまり。関数単位とかじゃない
けどファイル全体でもないようなかたまりのこと)

Magitのインターフェースの最も目に見える部分は、現在のリポジトリに関する
情報を表示するステータスバッファです。そのコンテンツは、いくつかのGitコ
マンドを実行し、それらの出力に対して操作可能にしたもので作成されます。 特
に、現在のブランチに関する情報を表示し、プルされていない変更(unpulled
changes)とプッシュされていない変更(unpushed changes)を一覧表示し、ステー
ジされた変更(staged changes)とステージされていない変更(unstaged
changes)を表示するセクションを含みます。煩雑な表示に思えるえるかもしれま
せんが、セクションは折りたたみ可能であるため、そんなことははありません。

変更をステージ(stage)またはステージ解除(unstage)するには、変更にカーソル
を置き、‘s’または‘u’と入力します。 変更は、ファイルまたはハンク、または
領域がアクティブな場合(つまり、選択がある場合)は、複数のファイルまたはハ
ンク、あるいはハンクの一部である可能性があります。これらのコマンド(およ
び他の多くのコマンド)が作用する1つまたは複数の変更が強調表示されます。

Magitは、ステージとステージ解除に加えて、他のいくつかの適用バリエーショ
ン("apply variants")も実装しています。 変更を破棄または元に戻すか、作業
ツリーに適用できます。Git自身の磁器は、ステージとステージ解除でのみこれ
をサポートしており、‘git diff ... | ??? | git apply ...’を使用して、コマ
ンドラインで単一のハンクを破棄、元に戻す、または適用します。 実際、これ
はまさにMagitが内部で行っていることです(これが適用バリエーション("apply
variants")という用語につながるものです)。

MagitはGitの専門家だけのものではありませんが、GitやEmacsでの経験があるこ
とを前提としています。 そうは言っても、多くのMagitユーザーは、Magitを使
用することで、Gitの機能と、Gitを最大限に活用する方法を悟ったといっていま
す。他のユーザーは、Magitをもっと早く手に入れることができるように、もっ
と早くEmacsに切り替えたいと願っていました。

Magitを最大限に活用するにはEmacsの基本機能を知っている必要がありますが、
他のエディターを好むユーザーにとっても、十分なEmacsスキルを習得するのに
時間はかからず、それだけの価値があります。 Vimユーザーは、Evil
(https://bitbucket.org/lyro/evil/wiki/Home)「Extensible VI Layer for
Emacs」、およびSpacemacs (https://github.com/syl20bnr/spacemacs)「Emacs
starter-kit focused on Evil」を試してみることをお勧めします。

Magitは、一貫性のある効率的なGit磁器を提供します。短い学習期間の後、コマ
ンドラインよりも高速に毎日のバージョン管理タスクのほとんどを実行できるよ
うになります。また、過去には気が遠くなるように思われた機能も使い始めるで
しょう。

MagitはGitを完全に包含しています。多くのGUIクライアントのように些細なも
のをラップするだけでなく、シンプルでありながら柔軟なインターフェイスを使
用して、多くの高度な機能を公開します。 もちろん、Magitは、ロギング、クロ
ーン作成、プッシュ、および通常は見事な方法により失敗することはないその他
のコマンドをサポートしています。ただし、1つのステップで完了できないこと
が多いタスクもサポートします。Magitは、これらのタスクを開始するコマンド
を提供するだけでなく、途中で状況に応じた情報を表示し、競合の解決と再開後
の作業に役立つコマンドを提供することにより、マージ、リベース、チェリーピ
ッキング、revert、blameなどのタスクを完全にサポートします。

Magitはラップすることにより、多くの場合、少なくとも次のGit磁器コマンドを
改善します: ‘add’, ‘am’, ‘bisect’, ‘blame’, ‘branch’, ‘checkout’,
‘cherry’, ‘cherry-pick’, ‘clean’, ‘clone’, ‘commit’, ‘config’,
‘describe’, ‘diff’, ‘fetch’, ‘format-patch’, ‘init’, ‘log’, ‘merge’,
‘merge-tree’, ‘mv’, ‘notes’, ‘pull’, ‘rebase’, ‘reflog’, ‘remote’,
‘request-pull’, ‘reset’, ‘revert’, ‘rm’, ‘show’, ‘stash’, ‘submodule’,
‘subtree’, ‘tag’, ‘worktree.’ そして、さらに多くのMagit磁器コマンドが
Git配管コマンドの上に実装されています。


File: magit.ja.info,  Node: Installation,  Next: Getting Started,  Prev: Introduction,  Up: Top

2 Installation
**************

Magitは、Emacsのパッケージマネージャーを使用してインストールすることも、
開発リポジトリから手動でインストールすることもできます。

* Menu:

* Installing from Melpa::
* Installing from the Git Repository::
* Post-Installation Tasks::


File: magit.ja.info,  Node: Installing from Melpa,  Next: Installing from the Git Repository,  Up: Installation

2.1 Installing from Melpa
=========================

MagitはMelpaおよびMelpa-Stableから入手できます。まだEmacsのパッケージマ
ネージャーを使用したことがない場合は、Emacsマニュアルのドキュメントを読
んで慣れてください(*note (emacs)Packages::)。次に、アーカイブの1つを
‘package-archives’に追加します:

   • Melpaを使うなら:

     (require 'package)
     (add-to-list 'package-archives
                  '("melpa" . "http://melpa.org/packages/") t)

   • Melpa-Stableを使うなら:

     (require 'package)
     (add-to-list 'package-archives
                  '("melpa-stable" . "http://stable.melpa.org/packages/") t)

あなたの好きな方のアーカイブを追加したら、以下を使用してローカルパッケー
ジリストを更新する必要があります:

     M-x package-refresh-contents RET

それが完了したら、以下を使用してMagitとその依存関係にあるパッケージをイ
ンストールできます:

     M-x package-install RET magit RET

インストール後にしなければならない作業があります→(*note
Post-Installation Tasks::)。


File: magit.ja.info,  Node: Installing from the Git Repository,  Next: Post-Installation Tasks,  Prev: Installing from Melpa,  Up: Installation

2.2 Installing from the Git Repository
======================================

Magitは、MelpaおよびMelpa-Stableから入手できる、‘dash’と‘transient’と
‘with-editor’ライブラリに依存しています。‘M-x package-install RET
<package> RET’を使用してインストールします。もちろん、それぞれのリポジト
リから手動でインストールすることもできます。

次に、Magitリポジトリのクローンを作成します:

     $ git clone https://github.com/magit/magit.git ~/.emacs.d/site-lisp/magit
     $ cd ~/.emacs.d/site-lisp/magit

次に、ライブラリをコンパイルして、infoマニュアルを生成します:

     $ make

Melpaや‘/path/to/magit/../<package>’から‘dash’と‘transient’と
‘with-editor’をインストールしたので場合は、以下のようにして‘make’にそれ
らの場所を指示します。これを行うには、‘make’を実行する前に、以下の内容の
ファイル‘/path/to/magit/config.mk’を作成します:

     LOAD_PATH  = -L ~/.emacs.d/site-lisp/magit/lisp
     LOAD_PATH += -L ~/.emacs.d/site-lisp/dash
     LOAD_PATH += -L ~/.emacs.d/site-lisp/transient/lisp
     LOAD_PATH += -L ~/.emacs.d/site-lisp/with-editor

最後に、以下をEmacsのinitファイルに追加します:

     (add-to-list 'load-path "~/.emacs.d/site-lisp/magit/lisp")
     (require 'magit)

     (with-eval-after-load 'info
       (info-initialize)
       (add-to-list 'Info-directory-list
                    "~/.emacs.d/site-lisp/magit/Documentation/"))

依存関係パッケージも手動でインストールした場合は、もちろん、上記Lispコー
ドより前に以下を挿入して、Emacsにも依存関係について通知する必要がありま
す:

     (add-to-list 'load-path "~/.emacs.d/site-lisp/dash")
     (add-to-list 'load-path "~/.emacs.d/site-lisp/transient/lisp")
     (add-to-list 'load-path "~/.emacs.d/site-lisp/with-editor")

注意: ‘lisp’サブディレクトリをリポジトリのトップレベルではなく
‘load-path’に追加する必要があり、‘load-path’の要素はスラッシュで終わって
いるべきではありません。逆に‘Info-directory-list’の要素はスラッシュで終
わっているべきです。

‘magit’機能をrerquireする代わりに、ファイル‘magit-autoloads.el’をロード
することにより、autoload定義のみをロードできます。

     (load "/path/to/magit/lisp/magit-autoloads")

クローンしたリポジトリのMagitを‘load-path’に追加してクローンしたリポジト
リから直接実行する代わりに、‘sudo make install’を使用して他のディレクト
リにインストールし、そこからの‘load-path’を設定することをお勧めします。

Magitを更新するには、以下を使用します:

     $ git pull
     $ make

代わりに‘make cleanall’を実行する必要がある場合があります。

使用可能なすべてのターゲットを表示するには、‘make help’を使用します。

インストール後にしなければならない作業があります→(*note
Post-Installation Tasks::)。


File: magit.ja.info,  Node: Post-Installation Tasks,  Prev: Installing from the Git Repository,  Up: Installation

2.3 Post-Installation Tasks
===========================

Magitをインストールした後、あなたが使用していると考えている、Magitと
GitとEmacsのリリースを実際に使用していることを確認する必要があります。
‘load-path’に古い値を使用していないことを確実するために、Magitを再起動す
る前にEmacsを再起動することをお勧めします。

     M-x magit-version RET

次のようなものが表示される必要があります

     Magit 2.8.0, Git 2.10.2, Emacs 25.1.1, gnu/linux

多くのユーザーがカスタマイズしたいと思うプションについても読みたいと思っ
たら→*note 基本設定::

このマニュアルにあるGit manpageへの相互参照をたどることができるようにす
るには、‘gitman’ infoマニュアルを手動でインストールするか、
‘Info-follow-nearest-node’でアドバイスして実際のmanpageを開く必要がある
場合もあります。 (*note How to install the gitman info manual?::)

あなたがMagitを完全に初めて触る場合は→(*note Getting Started::)

問題が発生した場合→*note FAQ:: こちらもどうぞ→*note Debugging Tools::

そして最後になりましたが、私がMagitに取り組み続けることができるように、
寄付を検討してください。<https://magit.vc/donations>を参照してください。
さまざまな寄付オプションがあります。


File: magit.ja.info,  Node: Getting Started,  Next: Interface Concepts,  Prev: Installation,  Up: Top

3 Getting Started
*****************

この短いチュートリアルでは、多くのマジシャン(Magitian)が日常的に使用する
最も重要な機能について説明します。それは表面を引っ掻く程度ですが、あなた
が始めるのに十分なはずです。

重要: このチュートリアルのためだけにリポジトリのクローンを作成するのが最
も安全です。または、既存のローカルリポジトリを使用することもできますが、
その場合は、作業を続行する前に、コミットされていないすべての変更をコミッ
トする必要があります。

‘C-x g’と入力して、ステータスバッファと呼ばれる専用バッファ内の現在の
Gitリポジトリに関する情報を表示します。

ほとんどのMagitコマンドは、通常、ステータスバッファから呼び出されます。
これは、Magitを使用してGitと対話するための主要なインターフェースと見なす
ことができます。他の多くのMagitバッファが特定の時間に存在する可能性があ
りますが、多くの場合、これらはこのバッファから作成されます。

リポジトリの状態に応じて、このバッファには、"Staged changes"、"Unstaged
changes"、"Unmerged into origin/master"、"Unpushed to origin/master"、そ
の他のタイトルのセクションが含まれる場合があります。

(‘git reset --hard PRE-MAGIT-STATE’を実行することで)簡単に戻ることができ
る安全な状態から開始しているため、現在、ステージされた変更(staged
changes)またはステージされてない変更(unstaged changes)はありません。いく
つかのファイルを編集し、変更を保存します。それから‘C-x g’と入力して、ス
テータスバッファに戻り、同時に更新します(ステータスバッファ、またはその
ためのMagitバッファが現在のバッファである場合は、‘g’だけを使用して更新す
ることもできます)。

‘p’と‘n’を使用してセクション間を移動します。一部のセクションの本文は非表
示になっていることに注意してください。‘TAB’と入力して、ポイントでセクシ
ョンを展開または折りたたみます。‘C-tab’を使用して、現在のセクションとそ
の子の表示を循環させることもできます。"Unstaged changes"という名前のセク
ション内のファイルセクションに移動し、‘s’と入力して、そのファイルに加え
た変更をステージします。 そのファイルは"Staged changes"の下に表れます。

Magitは、完全なファイルだけでなく、個々のハンクをステージ(stage)およびス
テージ解除(unstage)できます。ステージしたファイルに移動し、‘TAB’を使用し
て展開し、‘n’を使用してハンクのいずれかに移動し、‘u’と入力してステージを
解除します。ステージ(‘s’)コマンドとステージ解除(‘u’)コマンドがポイントで
の変更に対してどのように動作するかに注意してください。他の多くのコマンド
も同じように動作します。

ハンクの一部だけをステージ解除(unstage)/ステージ(stage)することもできま
す。ハンクセクションの本体内(‘C-n’を使用してそこに移動する)で、‘C-SPC’を
使用してマークを設定し、追加または削除された行がすべてリージョン内に収ま
るまで下に移動します。そして、もう一度‘s’と入力してステージします。

複数のファイルを一度にステージ解除(unstage)/ステージ(stage)することも可
能です。ファイルセクションに移動し、‘C-SPC’と入力し、‘n’を使用して次のフ
ァイルに移動し、次に‘s’を使用して両方のファイルをステージします。これが
機能するには、マークとポイントの両方が兄弟セクションの見出しにある必要が
あることに注意してください。リージョンが他のバッファと同じように見える場
合、ユニットとして機能できるMagitセクションは選択されません。

そしてもちろん、変更をコミットする必要があります。‘c’と入力します。ここ
で、フレームの下部にあるバッファで使用可能なコミットコマンドと引数を示し
ています。各コマンドと引数には、それを呼び出す/設定するキーが前置として
付けられます。ここではこれについて気にする必要はありません。「通常の」コ
ミットを作成します。これは、‘c’をもう一度入力することで実行されます。

これで、2つの新しいバッファが表示されます。1つはコミットメッセージを書き
込むためのもので、もう1つはコミットしようとしている変更との差分を示しま
す。メッセージを書き込んでから、‘C-c C-c’と入力して、実際にコミットを作
成します。

ランダムな変更をコミットしただけなので、作成したばかりのコミットをプッシ
ュしたくない場合がありますが、そうでない場合は、‘P’と入力して、使用可能
なすべてのプッシュコマンドと引数を表示してからプッシュできます。‘p’は、
ローカルブランチと同じ名前のブランチにpush-remoteとして構成された
remoteにプッシュします。(push-remoteがまだ構成されていない場合は、最初に
プッシュするためのremoteを求められます。)

これまで、commit、push、およびlogメニューコマンドについて説明してきまし
た。これらはおそらくあなたが最も使用するメニューの1つですが、他にもたく
さんあります。他のすべてのメニュー(およびさまざまなapplyコマンドやその他
の重要なコマンド)を一覧表示するメニューを表示するには、‘h’と入力します。
いくつか試してみてください。(このようなメニューは、「一時的前置コマンド
」("transient prefix commands")または単に「一時的コマンド」
("transients")とも呼ばれます。）

そのメニューのキーバインディングは、ステータスバッファを含むがこれに限定
されない、Magitバッファのバインディングに対応します。したがって、‘h d’と
入力してdiffメニューを表示できますが、「d」が「diff」を表すことを思い出
したら、通常は‘d’と入力するだけです。ただし、この「前置の前置」は、すべ
てのバインディングを記憶した後でも、Magit以外のバッファからMagitコマンド
に簡単にアクセスできるため便利です。グローバルバインディングは‘C-x M-g’で
す。

file visitingバッファでは、‘C-c M-g’は、訪問したファイルのみに作用する機
能コマンド群である同様のメニューを表示します(*note Commands for Buffers
Visiting Files::)。

今すぐでなくて構いませんが、Magitを使い続ける場合は、次の節も読むことを
強くお勧めします。


File: magit.ja.info,  Node: Interface Concepts,  Next: Inspecting,  Prev: Getting Started,  Up: Top

4 Interface Concepts
********************

* Menu:

* Modes and Buffers::
* Sections::
* 一時的(transient)コマンド::
* 一時的引数とバッファ変数::
* Completion(補完)とConfirmation(確認)とSelection(選択範囲): Completion Confirmation(確認補完)とSelection(選択範囲).
* Running Git::


File: magit.ja.info,  Node: Modes and Buffers,  Next: Sections,  Up: Interface Concepts

4.1 Modes and Buffers
=====================

Magitはいくつかのメジャーモードを提供します。 これらのモードのそれぞれに
ついて、通常、リポジトリごとに1つのバッファのみが存在します。個別のモー
ドとそのためのバッファは、コミット、差分、ログ、およびその他のいくつかの
もののために存在します。

これらの特別な目的のバッファに加えて、*ステータスバッファ*と呼ばれる概要
バッファもあります。ユーザーがGitコマンドを呼び出すか、他のバッファを作
成またはアクセスするのは、通常、このバッファからです。

このマニュアルでは、「Magitバッファ」についてよく話します。つまり、メジ
ャーモードが‘magit-mode’から派生するバッファを意味します。

‘M-x magit-toggle-buffer-lock’     (‘magit-toggle-buffer-lock’)

     このコマンドは、現在のバッファをその値にロックします。バッファがす
     でにロックされている場合は、ロックを解除します。

     バッファをその値にロックすると、別の値を表示するためにバッファが再
     利用されるのを防ぐことができます。ロックされたバッファの名前にはそ
     の値が含まれているため、他のロックされたバッファやロックされていな
     いバッファと区別することができます。

     すべてのMagitバッファをそれらの値にロックできるわけではありません。
     たとえば、ステータスバッファをロックすることは意味がありません。

     リポジトリごとに特定のメジャーモードを使用するロック解除されたバッ
     ファは1つだけです。したがって、バッファがロック解除されていて、その
     モードとリポジトリ用に別のロック解除されたバッファがすでに存在する
     場合、前者のバッファは代わりに削除され、後者がその場所に表示されま
     す。

* Menu:

* バッファの切り替え::
* バッファの名付け::
* Quitting Windows::
* Automatic Refreshing of Magit Buffers::
* Automatic Saving of File-Visiting Buffers::
* Automatic Reverting of File-Visiting Buffers::


File: magit.ja.info,  Node: バッファの切り替え,  Next: バッファの名付け,  Up: Modes and Buffers

4.1.1 バッファの切り替え
------------------------

 -- Function: magit-display-buffer buffer &optional display-function

     この関数は‘display-buffer’のラッパーであり、Magitバッファを表示する
     ために使用されます。一部のウィンドウにBUFFERを表示し、
     ‘display-buffer’とは異なり、‘magit-display-buffer-noselect’が
     ‘nil’の場合、そのウィンドウも選択します。また、以下に説明するフック
     を実行します。

     オプションのDISPLAY-FUNCTIONがnil以外の場合、それはバッファを表示す
     るために使用されます。通常、これは‘nil’であり、
     ‘magit-display-buffer-function’で指定された関数が使用されます。

 -- Variable: magit-display-buffer-noselect

     これがnil以外の場合、‘magit-display-buffer’はバッファのみを表示し、
     ウィンドウの選択も行いません。この変数はグローバルに設定しないでく
     ださい。「もう一方のウィンドウ」(the other window)を自動的に更新す
     るコードによって、制限されることのみを目的としています。これは、た
     とえば、ログバッファ内に移動したときにリビジョンバッファが更新され
     るときに使用されます。

 -- User Option: magit-display-buffer-function

     ここで指定された関数は、‘magit-display-buffer’によって呼び出され、
     1つの引数、つまりバッファを使用して、そのバッファを実際に表示します
     。この関数は、最初にそのバッファを使用し、2番目の引数として表示アク
     ションのリストを使用して‘display-buffer’を呼び出す必要があります。

     Magitは、このオプションに適した値である、以下にリストされているいく
     つかの関数を提供します。あなたが別のルールを使用したい場合は、これ
     らの関数の1つのコピーから始めて、あなたの必要に応じて調整(adjust)す
     ることをお勧めします。

     ‘display-buffer’のラッパーを使用する代わりに、その関数自体をここで
     使用できます。その場合、代わりに‘display-buffer-alist’に追加して表
     示アクションを指定する必要があります。

     表示アクションについては→*note (elisp)Choosing Window::

 -- Function: magit-display-buffer-traditional buffer

     この関数は、オプション‘magit-display-buffer-function’の現在のデフォ
     ルト値です。そのオプションとこの関数が追加される前は、動作はコード
     ベース全体の多くの場所でハードコーディングされていましたが、現在は
     すべてのルールがこの1つの関数に含まれています(上記の「noselect」特
     殊ケースを除く)。

 -- Function: magit-display-buffer-same-window-except-diff-v1

     この関数は、現在選択されているウィンドウにほとんどのバッファを表示
     します。バッファのモードが‘magit-diff-mode’または
     ‘magit-process-mode’から派生している場合、別のウィンドウに表示され
     ます。

 -- Function: magit-display-buffer-fullframe-status-v1

     この関数は、ステータスバッファを表示するときにフレーム全体を埋めま
     す。それ以外の場合は、‘magit-display-buffer-traditional’のように動
     作します。

 -- Function: magit-display-buffer-fullframe-status-topleft-v1

     この関数は、ステータスバッファを表示するときにフレーム全体を埋めま
     す。‘magit-display-buffer-fullframe-status-v1’と同じように動作しま
     すが、‘magit-diff-mode’または‘magit-process-mode’から派生したバッフ
     ァが、現在のバッファの下部または右側ではなく、上部または左側に表示
     される点が異なります。その結果、Magitバッファは、
     ‘magit-display-buffer-traditional’が使用されている場合と同じ側にポ
     ップアップする傾向があります。

 -- Function: magit-display-buffer-fullcolumn-most-v1

     この関数は、ほとんどのバッファを表示して、フレームの高さ全体を埋め
     るようにします。 ただし、(1)バッファのモードが
     ‘magit-process-mode’から派生している場合、または(2)バッファのモード
     が‘magit-diff-mode’から派生している場合、現在のバッファのモードが
     ‘magit-log-mode’または‘magit-cherry-mode’から派生している場合、バッ
     ファは別のウィンドウに表示されます。

 -- User Option: magit-pre-display-buffer-hook

     このフックは、バッファを表示する前に‘magit-display-buffer’によって
     実行されます。

 -- Function: magit-save-window-configuration

     この関数は、現在のウィンドウ構成を保存します。後でバッファが葬られ
     ると、‘magit-restore-window-configuration’によって復元される可能性
     があります。

 -- User Option: magit-post-display-buffer-hook

     このフックは、バッファを表示した後、‘magit-display-buffer’によって
     実行されます。

 -- Function: magit-maybe-set-dedicated

     この関数は、バッファを表示するために新しいウィンドウを作成する必要
     があるかどうか、または既存のウィンドウが再利用されたかどうかを記憶
     しています。 この情報は、後で‘magit-mode-quit-window’によって使用さ
     れ、最後のMagitバッファが葬られたときにウィンドウを削除する必要があ
     るかどうかを判断します。


File: magit.ja.info,  Node: バッファの名付け,  Next: Quitting Windows,  Prev: バッファの切り替え,  Up: Modes and Buffers

4.1.2 バッファの名付け
----------------------

 -- User Option: magit-generate-buffer-name-function

     Magitバッファの名前を生成するために使用される関数。

     このような関数は、オプション‘magit-uniquify-buffer-names’と
     ‘magit-buffer-name-format’を考慮に入れる必要があります。そうでない
     場合は、doc-stringに明確に記載する必要があります。また、オプション
     ‘magit-buffer-name-format’のdoc-stringに記載されている以外の
     %-sequencesをサポートしている場合は、独自のdoc-stringで追加を説明す
     る必要があります。

 -- Function: magit-generate-buffer-name-default-function mode

     この関数は、メジャーモードが「mode」であり、かつ、
     ‘default-directory’が配置されているリポジトリに関する情報を表示する
     バッファに適したバッファ名を返します。

     この関数は‘magit-buffer-name-format’を使用し、そのオプションの文書
     に記載されているすべての %シーケンス をサポートします。また、オプシ
     ョン‘magit-uniquify-buffer-names’も尊重します。

 -- User Option: magit-buffer-name-format

     Magitバッファに名前を付けるために使用されるフォーマット文字列。

     少なくとも以下の%シーケンスがサポートされています:

        • ‘%m’

          メジャーモードの名前ですが、‘-mode’後置部分が削除されています
          。

        • ‘%M’

          ‘%m’に似ていますが、‘magit-status-mode’を‘magit’と省略します。

        • ‘%v’

          バッファがロックされている時のカッコ内の値。またはバッファが値
          にロックされていない場合は空文字列。

        • ‘%V’

          ‘%v’と同様ですが、空文字列でない限り、文字列の前にスペースが付
          きます。

        • ‘%t’

          リポジトリの作業ツリーの最上位ディレクトリ、または
          ‘magit-uniquify-buffer-names’がnil以外の場合はその省略形。

        • ‘%x’

          ‘magit-uniquify-buffer-names’がnilの場合"*"、それ以外の場合は
          空の文字列。‘uniquify’パッケージの制限により、バッファ名はパス
          で終わる必要があります。

        • ‘%T’

          廃止されました。代わりに"%t%x"を使用してください。‘%t’と同様で
          すが、‘magit-uniquify-buffer-names’がnilの場合にのみ、アスタリ
          スクを追加します。<

     値には、常に、‘%m’または‘%M’と‘%v’または‘%V’と‘%t’(または廃止された
     ‘%T’)が含まれているべきです。‘magit-uniquify-buffer-names’がnil以外
     の場合、値は ‘%t’または‘%t%x’(または廃止された‘%T’)で終わる必要があ
     ります。issue #2841 を参照してください。

 -- User Option: magit-uniquify-buffer-names

     このオプションは、Magitバッファ達の名前を一意化(uniquify)するかどう
     かを制御します。名前が一意化されていない場合は、対応するリポジトリ
     の作業ツリーの最上位のフルパスが含まれます。一意化されている場合は
     、最上位のベース名で終了します。それが他のバッファに使用されている
     名前と競合する場合は、競合しなくなるまで、これらすべてのバッファの
     名前が調整されます。

     これは、‘uniquify’パッケージを使用して行われます。オプションをカス
     タマイズして、バッファ名の一意化(uniquify)方法を制御します。


File: magit.ja.info,  Node: Quitting Windows,  Next: Automatic Refreshing of Magit Buffers,  Prev: バッファの名付け,  Up: Modes and Buffers

4.1.3 Quitting Windows
----------------------

‘q’     (‘magit-mode-bury-buffer’)

     このコマンドは現在のMagitバッファを隠し(bury)ます。

     プレフィックス引数を付けると、代わりにバッファを強制終了します。プ
     レフィックス引数を2つ付けると、現在のプロジェクトに関連付けられてい
     る他のすべてのMagitバッファも強制終了します。

 -- User Option: magit-bury-buffer-function

     現在のバッファを実際に隠す(bury)かまたは強制終了(kill)するために使
     用される関数。

     ‘magit-mode-bury-buffer’は、この関数を1つの引数で呼び出します。引数
     がnil以外の場合、関数は現在のバッファを強制終了(kill)する必要があり
     ます。そうでなければ、それは生きたまま隠さなければなりません。現在
     のデフォルト値は‘magit-restore-window-configuration’です。

 -- Function: magit-restore-window-configuration kill-buffer

     ‘quit-window’を使用して現在のバッファを隠す(bury)か、強制終了
     (kill)します。これは、最初にKILL-BUFFERを使用し、2番目の引数として
     選択したウィンドウを使用して呼び出されます。

     それから、選択したフレームに現在のバッファが表示される直前に存在し
     ていたウィンドウ構成を復元します。残念ながら、それはまた、選択した
     フレームに表示されているすべてのバッファでポイントが調整されること
     を意味します。

 -- Function: magit-mode-quit-window kill-buffer

     ‘quit-window’を使用して現在のバッファを隠す(bury)か、強制終了
     (kill)します。これは、最初にKILL-BUFFERを使用し、2番目の引数として
     選択したウィンドウを使用して呼び出されます。

     それから、ウィンドウが元々Magitバッファを表示するために作成され、埋
     め込み(buried)バッファがウィンドウに表示された最後の残りのMagitバッ
     ファであった場合、それは削除されます。


File: magit.ja.info,  Node: Automatic Refreshing of Magit Buffers,  Next: Automatic Saving of File-Visiting Buffers,  Prev: Quitting Windows,  Up: Modes and Buffers

4.1.4 Automatic Refreshing of Magit Buffers
-------------------------------------------

現在のリポジトリの状態を変更する可能性のあるコマンドを実行した後で、現在
のMagitバッファと対応するステータスバッファが更新されます。ステータスバ
ッファは、以下のようにフックを追加することで、バッファがそれぞれのリポジ
トリ内のファイルに保存されるたびに自動的に更新できます:

     (with-eval-after-load 'magit-mode
       (add-hook 'after-save-hook 'magit-after-save-refresh-status t))

Magitバッファ達を自動的に更新すると、表示される情報はほとんどの場合最新
であることが保証されますが、大きなリポジトリで顕著な遅延が発生する可能性
があります。他のMagitバッファ達は、遅延を最小限に抑えるために更新されま
せん。また、更新することが望ましくない場合があるためです。

バッファは明示的に更新することもできます。これは、最後の更新時および
Magitの外部のリポジトリに変更が加えられた後、最新ではなかったバッファで
役立ちます。

‘g’     (‘magit-refresh’)

     このコマンドは、メジャーモードが‘magit-mode’および対応するステータ
     スバッファから派生している場合、現在のバッファを更新します。

     オプション‘magit-revert-buffers’がそれを要求する場合、現在のリポジ
     トリで追跡されているファイルにアクセスするすべての変更されていない
     バッファも元に戻します。

‘G’     (‘magit-refresh-all’)

     このコマンドは、現在のリポジトリに属するすべてのMagitバッファを更新
     し、現在のリポジトリで追跡されているファイルにアクセスするすべての
     変更されていないバッファを元に戻します。

     ‘magit-revert-buffers’がnilの場合でも、file-visitingバッファは常に
     元に戻されます。

 -- User Option: magit-refresh-buffer-hook

     このフックは、現在更新中に更新された各Magitバッファ(通常は現在のバ
     ッファとステータスバッファ)で実行されます。

 -- User Option: magit-refresh-status-buffer

     このオプションがnil以外の場合、現在のMagitバッファに加えて、副作用
     としてgitを実行した後、ステータスバッファが自動的に更新されます。こ
     れは、常に自動的に更新されます。

     パフォーマンスを向上させるために他のすべてのオプションを使い果たし
     た後でのみ、これをnilに設定してください。

 -- Function: magit-after-save-refresh-status

     この関数は、‘after-save-hook’に追加することを目的としています。その
     後、リポジトリ内のファイルにバッファが保存されるたびに、対応するス
     テータスバッファが更新されます。

     Magitバッファの更新は、その内容を最初から再作成することによって行わ
     れることに注意してください。これは、大規模なリポジトリでは遅くなる
     可能性があります。Magitのパフォーマンスに満足できない場合は、明らか
     にこの関数をそのフックに追加しないでください。


File: magit.ja.info,  Node: Automatic Saving of File-Visiting Buffers,  Next: Automatic Reverting of File-Visiting Buffers,  Prev: Automatic Refreshing of Magit Buffers,  Up: Modes and Buffers

4.1.5 Automatic Saving of File-Visiting Buffers
-----------------------------------------------

file-visitingバッファは、デフォルトで特定の時点で保存されます。これは、
Magitバッファが常に最新であることを保証するものではありませんが、Emacsで
ファイルを編集するだけでファイルを編集し、Magitのみを使用してGitと対話す
る場合には、かなり自信があります。疑わしい場合やまたは外部の変更後は、
‘g’ (‘magit-refresh’)と入力して、明示的に保存および更新します。

 -- User Option: magit-save-repository-buffers

     このオプションは、特定のイベントの前にfile-visitingバッファを保存す
     るかどうかを制御します。

     これがnil以外の場合、現在のリポジトリに属するすべての変更された
     file-visitingバッファは、コマンドを実行する前、新しいMagitバッファ
     を作成する前、およびそのようなバッファを明示的に更新する前に保存で
     きます。これが‘dontask’の場合、これはユーザーの介入なしに実行されま
     す。‘t’の場合、ユーザーは各保存を確認する必要があります。


File: magit.ja.info,  Node: Automatic Reverting of File-Visiting Buffers,  Prev: Automatic Saving of File-Visiting Buffers,  Up: Modes and Buffers

4.1.6 Automatic Reverting of File-Visiting Buffers
--------------------------------------------------

デフォルトでは、Magitは、ディスク上で変更された後、Gitリポジトリで追跡さ
れているファイルにアクセスしているバッファを自動的に元に戻します。
Magitを使用する場合、Gitを実行してディスク上のファイルを変更することがよ
くあります。つまり、「Emacsの外部」(outside Emacs)であるため、これはかな
り重要な機能です。

たとえば、ステータスバッファの変更を破棄する場合、‘git apply --reverse
...’を実行することでそれが行われ、Emacsはファイルが「ディスク上で変更さ
れた」と見なします。 Magitがバッファを自動的に元に戻さなかった場合は、変
更を続行する前に、訪問中のバッファに‘M-x revert-buffer RET RET’と入力す
る必要があります。

 -- User Option: magit-auto-revert-mode

     このモードを有効にすると、追跡中のファイル(tracked files)にアクセス
     したバッファは、アクセスしたファイルがディスク上で変更された後、自
     動的に元に戻されます。

 -- User Option: global-auto-revert-mode

     このモードを有効にすると、訪問したファイル(visited file)がディスク
     上で変更された後、file-visitingバッファが自動的に元に戻されます。

     追跡中のファイル(tracked files)にアクセスするバッファを自動的に元に
     戻す場合は、追跡中のファイルにアクセスするバッファだけでなく、任意
     のバッファを元に戻すこともできます。その場合は、
     ‘magit-auto-revert-mode’の「代わりに」このモードを有効にしてくださ
     い。

 -- User Option: magit-auto-revert-immediately

     このオプションは、Magitがバッファをすぐに元に戻すかどうかを制御しま
     す。

     これがnil以外で、‘global-auto-revert-mode’または
     ‘magit-auto-revert-mode’のいずれかが有効になっている場合、Magitは、
     副作用のためにGitを実行した後、‘auto-revert-buffers’を明示的に呼び
     出すことにより、すぐにバッファを戻します。

     ‘auto-revert-use-notify’がnil以外の場合(およびファイル通知が実際に
     サポートされている場合)、復帰はとにかくすぐに行われるため、
     ‘magit-auto-revert-immediately’をnil以外にする必要はありません。

     ‘magit-auto-revert-immediately’と‘auto-revert-use-notify’が両方とも
     ‘nil’の場合、ユーザーが非アクティブになってから
     ‘auto-revert-interval’秒後に復帰が発生します。それは望ましくありま
     せん。

 -- User Option: auto-revert-use-notify

     このオプションは、ファイル通知機能を使用するかどうかを制御します。
     残念ながら、ファイル通知を使用できないシステムでも、この変数のデフ
     ォルトは‘t’であることに注意してください。

 -- User Option: magit-auto-revert-tracked-only

     このオプションは、‘magit-auto-revert-mode’が追跡されたファイル
     (tracked files)のみを元に戻すか、追跡されていないファイル(untracked
     files)やGitの制御ディレクトリ内にあるファイルを含むGitリポジトリ内
     にあるすべてのファイルを元に戻すかを制御します。

 -- User Option: auto-revert-mode

     グローバルモード‘magit-auto-revert-mode’は、適切なバッファでこのロ
     ーカルモードをオンにすることで機能します(ただし、
     ‘global-auto-revert-mode’の実装は異なります)。手動でオンまたはオフ
     にすることもできます。これは、以前は追跡されてなかったファイルが今
     現在追跡されていることにMagitが気付かない場合、またはその逆の場合に
     必要になることがあります。

 -- User Option: auto-revert-stop-on-user-input

     このオプションは、ユーザーが入力するまで‘auto-revert-interval’秒間
     、自動復帰を一時停止するかどうかを制御します。

 -- User Option: auto-revert-interval

     このオプションは、一時停止された復帰を再開する前にEmacsが待機する秒
     数を制御します。

 -- User Option: auto-revert-buffer-list-filter

     このオプションは、‘auto-revert-buffers’がバッファを元に戻すかどうか
     を決定するために使用する追加のフィルターを指定します。

     このオプションはMagitによって提供され、‘auto-revert-buffers’にもそ
     れを尊重するようにアドバイスします。ローカルモード
     ‘auto-revert-mode’を自分でオンにしないMagitユーザーは、値を
     ‘magit-auto-revert-repository-buffer-p’に設定するのが最適です。

     ただし、ローカルモードを直接使用するユーザーの邪魔にならないように
     、デフォルトはnilです。Magitコマンドの実行中に遅延が発生した場合は
     、Magitが提供する述語(predicate)の1つを使用することを検討する必要が
     あります。特に、Trampも使用している場合はそうです。

     Magitがオンにしないバッファで‘auto-revert-mode’をオンにするユーザー
     は、フィルターを使用しないでください。‘global-auto-revert-mode’をオ
     ンにするユーザーは、グローバルモードが有効になっている場合は無視さ
     れるため、このオプションについて心配する必要はありません。

 -- User Option: auto-revert-verbose

     このオプションは、バッファが元に戻されたときにEmacsがレポートするか
     どうかを制御します。

‘auto-revert-’接頭辞が付いたオプションは、‘auto-revert’という名前のカス
タムグループにあります。他のMagit固有のオプションは、‘magit’グループにあ
ります。

* Menu:

* 自動的に元に戻るリスク::


File: magit.ja.info,  Node: 自動的に元に戻るリスク,  Up: Automatic Reverting of File-Visiting Buffers

自動的に元に戻るリスク
......................

大多数のユーザーにとって、ディスク上で変更された後にfile-visitingバッフ
ァを自動的に元に戻すことは無害です。

バッファが変更された場合(つまり、まだ保存されていない変更が含まれている
場合)、Emacsは自動的にバッファを元に戻すことを拒否します。以前に変更され
たバッファを保存すると、Gitはコミットされていない変更と見なします。その
後、Gitは、これらの変更が失われる原因となるコマンドの実行を拒否します。
言い換えれば、失われる可能性のあるものがある場合、GitまたはEmacsのいずれ
かが変更の破棄を拒否します。

ただし、あなたがfile-visitingバッファを一種その場しのぎ(ad hoc)の「ステ
ージ領域」として使用する場合、自動復帰によってデータが失われる可能性があ
ります。 これまでのところ、このようなワークフローを使用しているユーザー
は私が知っている限りでは1人だけです。

例：あなたはバッファ内のファイルにアクセスして編集し、変更を保存します。
それから、Emacsの外部で(または少なくともMagitを使用しないか、バッファを
保存することにより)、ディスク上のファイルを再度変更します。この時点で、
バッファは中間バージョンがまだ存在する唯一の場所です。変更をディスクに保
存しましたが、それ以降は上書きされています。一方、Emacsはバッファが変更
されていないと見なし(最後にアクセスしたファイルに保存してから変更を加え
ていないため)、自動的に元に戻されることに異議を唱えません。この時点で、
自動復帰モードが開始されます。バッファが変更されているかどうかがチェック
され、変更されていないため、バッファが復帰します。中間バージョンは失われ
ます。(実際には、‘undo’コマンドを使用して元に戻すことができます。)

あなたのワークフローがバッファに中間バージョンを保持するEmacsに依存して
いる場合は、すべての自動復帰モードを無効にする必要があります。ただし、こ
のようなワークフローは、自動復帰モードを使用しなくても危険であるため、回
避する必要があることを考慮してください。Emacsがクラッシュしたり、誤って
Emacsを終了したりすると、バッファの内容も失われます。中間バージョンがま
だ含まれている自動保存ファイルはなく(バッファを保存したときに削除された
ため)、バッファを保存するかどうかを尋ねられることはありません(変更されて
いないため)。


File: magit.ja.info,  Node: Sections,  Next: 一時的(transient)コマンド,  Prev: Modes and Buffers,  Up: Interface Concepts

4.2 Sections
============

Magitバッファはネストされたセクションに編成され、Orgモードでセクションが
処理されるのと同様に、折りたたんだり展開したりできます。各セクションにも
タイプがあり、一部のセクションにも値があります。セクションタイプごとに、
そのタイプのすべてのセクションで共有されるローカルキーマップを作成するこ
ともできます。

セクションの値とタイプを利用して、多くのコマンドが現在のセクションで動作
します。または、リージョンがアクティブで同じタイプのセクションを選択する
と、選択されたすべてのセクションが操作されます。特定のセクションタイプに
対してのみ意味のあるコマンド(（タイプによって動作が異なるだけではなく）
は、通常、セクションタイプのキーマップにバインドされます。

* Menu:

* Section Movement::
* Section Visibility::
* Section Hooks::
* Section Types and Values::
* Section Options::


File: magit.ja.info,  Node: Section Movement,  Next: Section Visibility,  Up: Sections

4.2.1 Section Movement
----------------------

セクション内を移動するには、グローバルバインディングが隠蔽されていない通
常のキー(‘C-p’, ‘C-n’, ‘C-b’, ‘C-f’ 等)を使用します。 別のセクションに移
動するには、以下のコマンドを使用します。

‘p’     (‘magit-section-backward’)

     セクションの先頭じゃない場合は、現在のセクションの先頭に移動します
     。セクションの先頭では、前の表示セクションの先頭に移動します。

‘n’     (‘magit-section-forward’)

     次の表示セクションの先頭に移動します。

‘M-p’     (‘magit-section-backward-siblings’)

     前の兄弟セクションの先頭に移動します。 前の兄弟セクションがない場合
     は、代わりに親セクションに移動します。

‘M-n’     (‘magit-section-forward-siblings’)

     次の兄弟セクションの先頭に移動します。 次の兄弟セクションがない場合
     は、代わりに親セクションに移動します。

‘^’     (‘magit-section-up’)

     現在のセクションの親の先頭に移動します。

上記のコマンドはすべて、フック‘magit-section-movement-hook’を呼び出しま
す。以下にリストされている関数のいずれかをこのフックのメンバーとして使用
できます。

あなたは、Magitが‘add-hook’を使用して追加する関数のいくつかを削除したい
と思うかもしれません。その際は、まだ追加されていない関数を削除しようとし
ないようにする必要があります。以下に例を示します。

     (with-eval-after-load 'magit-diff
       (remove-hook 'magit-section-movement-hook
                    'magit-hunk-set-window-start))

 -- Variable: magit-section-movement-hook

     このフックは、上記のすべての移動コマンドににおいて、目的地に到着し
     た後に実行されます。

 -- Function: magit-hunk-set-window-start

     このフック関数は、‘hunk’セクションであれば、現在のセクションの先頭
     が表示されるようにします。それ以外の場合は何もしません。

     ‘magit-diff’をロードすると、この関数がフックに追加されます。

 -- Function: magit-section-set-window-start

     このフック機能により、セクションのタイプに関係なく、現在のセクショ
     ンの先頭が表示されます。これを‘magit-section-movement-hook’に追加す
     る場合は、ハンクのみのバリエーション(hunk-only variant)を順番に削除
     する必要があります。

 -- Function: magit-log-maybe-show-more-commits

     このフック関数はログバッファでのみ効果があり、そして‘point’は"show
     more"(もっと見る)セクションにあります。その場合は、表示されているコ
     ミットの数が2倍になります。

     ‘magit-log’をロードすると、この関数がフックに追加されます。

 -- Function: magit-log-maybe-update-revision-buffer

     ログバッファ内を移動する場合、同じフレームの別のウィンドウにすでに
     表示されている場合、この関数はリビジョンバッファを更新します。

     ‘magit-log’をロードすると、この関数がフックに追加されます。

 -- Function: magit-log-maybe-update-blob-buffer

     ログバッファ内を移動し、同じフレームの別のウィンドウにblobバッファ
     が表示される場合、この関数は代わりに、そのウィンドウ内のポイントで
     のコミットのblobバッファを表示します。

 -- Function: magit-status-maybe-update-revision-buffer

     ステータスバッファ内を移動するとき、同じフレームの別のウィンドウに
     すでに表示されている場合、この関数はリビジョンバッファを更新します
     。

 -- Function: magit-status-maybe-update-stash-buffer

     ステータスバッファ内を移動するとき、同じフレームの別のウィンドウに
     すでに表示されている場合、この関数はスタッシュバッファを更新します
     。

 -- Function: magit-status-maybe-update-blob-buffer

     ステータスバッファ内を移動し、同じフレームの別のウィンドウにblobバ
     ッファが表示される場合、この関数は代わりに、そのウィンドウ内のポイ
     ントでのコミットのblobバッファを表示します。

 -- Function: magit-stashes-maybe-update-stash-buffer

     スタッシュを一覧表示するバッファ内を移動する場合、同じフレームの別
     のウィンドウにすでに表示されている場合、この関数はスタッシュバッフ
     ァを更新します。

 -- User Option: magit-update-other-window-delay

     他のウィンドウを自動的に更新する前に遅延します。

     特定のバッファ内を移動する場合、別のウィンドウに表示されている特定
     の他のバッファをオプションで更新して、その時点のセクションに関する
     情報を表示することができます。

     キーを押したままにして複数のセクションを移動すると、途中でセクショ
     ンごとにそのバッファーが更新されます。これを防ぐために、リビジョン
     バッファの更新は遅延され、このオプションはそれがどのくらいの長さか
     を制御します。最適なエクスペリエンスを得るには、この遅延やキーボー
     ドの繰り返し速度、およびグラフィカル環境やオペレーティングシステム
     の遅延を調整する必要がある場合があります。


File: magit.ja.info,  Node: Section Visibility,  Next: Section Hooks,  Prev: Section Movement,  Up: Sections

4.2.2 Section Visibility
------------------------

Magitには、セクションの表示を変更するための多くのコマンドが用意されてい
ますが、開始するために必要なのは次の2つだけです。

‘TAB’     (‘magit-section-toggle’)

     現在のセクションの本体の表示を切り替えます。

‘C-<tab>’     (‘magit-section-cycle’)

     現在のセクションとその子の表示を循環させます。

‘M-<tab>’     (‘magit-section-cycle-diffs’)

     現在のバッファ内のdiff-relatedセクションの表示を循環させます。

‘S-<tab>’     (‘magit-section-cycle-global’)

     現在のバッファ内のすべてのセクションの表示を循環させます。

‘1’     (‘magit-section-show-level-1’)
‘2’     (‘magit-section-show-level-2’)
‘3’     (‘magit-section-show-level-3’)
‘4’     (‘magit-section-show-level-4’)

     レベルN@までの現在のセクションを囲むセクションを表示します。

‘M-1’     (‘magit-section-show-level-1-all’)
‘M-2’     (‘magit-section-show-level-2-all’)
‘M-3’     (‘magit-section-show-level-3-all’)
‘M-4’     (‘magit-section-show-level-4-all’)

     レベルN@までのすべてのセクションを表示します。

上記のコマンドを実装するために使用される一部の関数は、コマンド自体として
も公開されます。デフォルトでは、これらのコマンドに結び付けられているキー
はありません。これらのコマンドは、一般的にあまり役に立たないと認識されて
いるためです。しかし、あなたにとっては有益かもしれません。

 -- magit-section-show: コマンド

     現在のセクションのボディを表示します。

 -- magit-section-hide: コマンド

     現在のセクションのボディを非表示にします。

 -- magit-section-show-headings: コマンド

     現在のセクションの子の見出しを再帰的に表示します。見出しのみを表示
     します。以前に表示されたテキストのみのボディは非表示になります。

 -- magit-section-show-children: コマンド

     現在のセクションの子の体を再帰的に表示します。プレフィックス引数を
     使用すると、現在のセクションのレベルまで子を表示し、より深い子を非
     表示にします。

 -- magit-section-hide-children: コマンド

     現在のセクションの子のボディを再帰的に非表示にします。

 -- magit-section-toggle-children: コマンド

     現在のセクションの子のボディの可視性を切り替えます(toggle)。

バッファが最初に作成されると、一部のセクションは展開されて表示されますが
、他のセクションは展開されません。これはハードコーディングされています。
バッファが更新されると、以前の可視性が保持されます。特定のセクションの初
期可視性は、フック‘magit-section-set-visibility-hook’を使用して上書きす
ることもできます。

 -- User Option: magit-section-initial-visibility-alist

     このオプションを使用して、セクションの初期可視性をオーバーライドで
     きます。将来的には、デフォルトの定義にも使用されますが、現在、セク
     ションのデフォルトはハードコーディングされています。

     値は単一のリストです。各要素は、セクションタイプまたは系統
     (lineage)をそのようなセクションの初期可視状態にマップします。状態は
     、‘show’または‘hide’のいずれか、またはこれらのシンボルの1つを返す関
     数である必要があります。セクションを唯一の引数として関数が呼び出さ
     れます。

     コマンド‘magit-describe-section-briefly’を使用して、セクションの系
     統(lineage)またはタイプを判別します。出力のベクター(vector)はセクシ
     ョン系統(section lineage)であり、タイプはそのベクター(vector)の最初
     の要素です。ワイルドカードを使用できます。‘magit-section-match’を参
     照してください。

 -- User Option: magit-section-cache-visibility

     このオプションは、セクションが消えて後で再び表示された場合に、以前
     の可視性状態を復元するセクションを制御します。値はブール値またはセ
     クションタイプのリストです。tの場合、すべてのセクションの可視性がキ
     ャッシュされます。それ以外の場合、これは、タイプがリストされたタイ
     プの1つと一致するセクションに対してのみ実行されます。

     これには、関数‘magit-section-cached-visibility’が
     ‘magit-section-set-visibility-hook’のメンバーである必要があります。

 -- Variable: magit-section-set-visibility-hook

     このフックは、最初にバッファを作成するとき、および既存のバッファを
     更新するときに実行され、現在挿入されているセクションの可視性を判別
     するために使用されます。

     各関数は1つの引数で呼び出され、セクションが挿入されます。‘hide’また
     は‘show’を返すか、可視性を未定義の‘nil’のままにする必要があります。
     可視性を決定する関数がなく、バッファが更新されている場合、可視性は
     保持されます。 または、バッファが作成されている場合は、ハードコード
     されたデフォルトが使用されます。

     通常、これは初期の可視性を設定するためにのみ使用する必要があり、更
     新中は使用しないでください。‘magit-insert-section--oldroot’がnil以
     外の場合、バッファは更新済で、これらの関数はすぐに‘nil’を返す必要が
     あります。

 -- User Option: magit-section-visibility-indicator

     このオプションは、セクションを展開/折りたたむことができるかどうか、
     および表示(indicate)方法を制御します。

     nilの場合、可視性インジケータは表示されません。それ以外の場合、値は
     以下の2つの形式のいずれかである必要があります:

        • ‘(EXPANDABLE-BITMAP . COLLAPSIBLE-BITMAP)’

          両方の値は、値がフリンジビットマップ(fringe bitmaps)である変数
          である必要があります。この場合、展開または折りたたむことができ
          るすべてのセクションは、左フリンジ(left fringe)にインジケータ
          ーを取得します。

          インジケーターの周囲に追加のパディングを提供するには、
          ‘magit-mode-hook’で‘left-fringe-width’を設定します。例:

               (add-hook 'magit-mode-hook (lambda ()
                                            (setq left-fringe-width 20)))

        • ‘(STRING . BOOLEAN)’

          この場合、折りたたまれたすべてのセクションの見出しの最後に
          STRING(通常は省略記号)が表示されます。展開されたセクションには
          インジケーターが表示されません。cdrは、これらの省略記号の外観
          がセクションの強調表示を考慮に入れるかどうかを制御します。そう
          しないとパフォーマンスに影響を与える可能性がありますが、そうし
          ないと少し醜いです。


File: magit.ja.info,  Node: Section Hooks,  Next: Section Types and Values,  Prev: Section Visibility,  Up: Sections

4.2.3 Section Hooks
-------------------

どのセクションが特定のバッファーに挿入されるかは、フックで制御されます。
これには、ステータス(status)と参照(refs)バッファが含まれます。他のバッフ
ァの場合、例えば logおよびdiffバッファ、これは不可能です。コマンド
‘magit-describe-section’を使用して、ポイントにセクションを挿入する原因と
なったフック(存在する場合)を確認できます。

ユーザーがセクションをカスタマイズできるバッファの場合、
‘magit-TYPE-sections-hook’というフック変数が存在します。このフックは、
‘magit-add-section-hook’を使用して変更する必要があります。‘add-hooks’ま
たはカスタムインターフェイス(Custom interface)の使用は避けてください。

使用可能なさまざまなセクションフック変数については、このマニュアルの後半
で、適切な"section inserter functions"(セクションインサーター関数)ととも
に説明します。

 -- Function: magit-add-section-hook hook function &optional at append
          local

     セクションフックFOOK@の値に関数FUNCTIONを追加します。

     オプションのAPPENDがnil以外の場合を除き、フックリストの最初に
     FUNCTIONを追加します。APPENDがnil以外の場合、最後にFUNCTIONを追加し
     ます。 FUNCTIONがすでにメンバーである場合は、それを新しい場所に移動
     します。

     オプションのATがnil以外で、フックリストのメンバーである場合は、代わ
     りにその脇にFUNCTIONを追加します。 APPEND@に応じて、ATの前または後
     に追加するか、ATをFUNCTIONに置き換えます。APPENDがシンボル
     ‘replace’の場合、ATをFUNCTION@に置き換えます。APPENDがその他のゼロ
     以外の値の場合は、AT@の直後にFUNCTIONを配置します。nilの場合は、
     AT@の直前にFUNCTIONを配置します。FUNCTIONがすでにリストのメンバーで
     あるが、ATがメンバーでない場合は、FUNCTIONを既に存在する場所に残し
     ます。

     オプションのLOCALがnil以外の場合は、フックのグローバル値ではなく、
     バッファローカル値を変更します。 これにより、デフォルト値をコピーし
     てフックがローカルになります。次に、そのコピーが変更されます。

     HOOKはシンボルであるべきです。HOOKが無効の場合、最初にnilに設定され
     ます。HOOKの値は単一のフック関数であってはなりません。FUNCTIONは、
     引数をとらず、ポイントに1つまたは複数のセクションを挿入して、ポイン
     トを前方に移動する関数である必要があります。FUNCTIONは、意味がない
     場合に、セクションを挿入しないことを選択する場合があります。他の副
     作用のために乱用されるべきではありません。

セクションフックから関数を削除するには、‘remove-hook’を使用します。


File: magit.ja.info,  Node: Section Types and Values,  Next: Section Options,  Prev: Section Hooks,  Up: Sections

4.2.4 Section Types and Values
------------------------------

各セクションには、例えば‘hunk’, ‘file’,‘commit’などのタイプがあります。
特定のセクションタイプのインスタンスにも値があります。たとえば、タイプ
‘file’のセクションの値は、ファイル名です。

ユーザーは通常、セクションのタイプと値について心配する必要はありませんが
、それらを知っていると便利な場合があります。

‘M-x magit-describe-section-briefly’     (‘magit-describe-section-briefly’)

     エコー領域内にポイントのあるセクションに関する情報を
     "#<magit-section VALUE [TYPE PARENT-TYPE...] BEGINNING-END>"として
     表示します。

多くのコマンドは、ポイントのある場所でのセクションのタイプに応じて異なる
動作をしたり、何らかの形でそのセクションの値を消費したりします。しかし、
それは、現在のセクションに応じて、同じキーが異なることを行う可能性がある
理由の1つにすぎません。

さらに、セクションタイプごとに、‘magit-TYPE-section-map’という名前のキー
マップ「might」を定義します。そのキーマップは、それぞれのタイプの任意の
セクションに属するすべてのテキストのテキストプロパティキーマップとして使
用されます。そのようなマップが特定のタイプに存在しない場合は、自分で定義
することができ、自動的に使用されます。


File: magit.ja.info,  Node: Section Options,  Prev: Section Types and Values,  Up: Sections

4.2.5 Section Options
---------------------

このセクションでは、特定のタイプのセクション以外にも影響を与えるオプショ
ンについて説明します。以下ご覧のとおり、そんなに多くはありません。

 -- User Option: magit-section-show-child-count

     セクションの見出しに子の数を追加するかどうか。これは、この情報の恩
     恵を受ける可能性のあるセクションにのみ影響します。


File: magit.ja.info,  Node: 一時的(transient)コマンド,  Next: 一時的引数とバッファ変数,  Prev: Sections,  Up: Interface Concepts

4.3 一時的(transient)コマンド
=============================

多くのMagitコマンドは、*一時的*(transient)コマンドとして実装されています
。 最初に、ユーザーが*前置*(prefix)コマンドを呼び出すと、*中置*(infix)引
数達と*後置*(suffix)コマンド達がエコー領域に表示されます。次に、ユーザー
はオプションでいくつかの中置(infix)引数を設定し、最後に後置(suffix)コマ
ンドのどれか1つを呼び出します。

これは、ライブラリ‘transient’で実装されています。 以前のMagitリリースで
は、パッケージ‘magit-popup’と、さらに以前のバージョンのライブラリ
‘magit-key-mode’を使用していました。

Transientの文書は→*note (transient)Top::

‘C-c C-c’     (‘magit-dispatch’)

     この一時的(transient)前置(prefix)コマンドは、Magitの他の前置
     (prefix)コマンドのほとんどを後置(suffix)コマンドとして結びつけ、そ
     のうちの1つが呼び出されるまで一時バッファ(temporary buffer)に表示し
     ます。このようなサブの前置(sub-prefix)を呼び出すと、
     ‘magit-dispatch’の後置(suffix)ではなく、そのコマンドの後置
     (suffix)が結び付けられて表示されます。

このコマンドは、Magitバッファの外部でも特に便利なので、グローバル・バイ
ンディングを設定すべきです:

     (global-set-key (kbd "C-x M-g") 'magit-dispatch)


File: magit.ja.info,  Node: 一時的引数とバッファ変数,  Next: Completion Confirmation(確認補完)とSelection(選択範囲),  Prev: 一時的(transient)コマンド,  Up: Interface Concepts

4.4 一時的引数とバッファ変数
============================

Magitの一時的な前置コマンドの多くの中置引数は、それらの引数で呼び出され
た‘git’コマンドが返されると、効果がなくなります。コミットを作成するコマ
ンドは、この良い例です。ユーザーが引数を変更した場合、それは次の後置コマ
ンドの呼び出しにのみ影響します。 同じ一時前置コマンドが後で再度呼び出さ
れた場合、引数は最初にデフォルト値にリセットされます。このデフォルト値は
、現在のEmacsセッションに設定することも、永続的に保存することもできます
(*note (transient)Saving Values::)。 ‘M-p’と‘M-n’を使用して、以前に使用
した引数のセットを循環させることもできます(*note (transient)Using
History::)。

ただし、他の多くの一時コマンドの中置引数は、それらの引数で呼び出された
‘git’コマンドが返された後でも引き続き有効です。このような最も重要なコマ
ンドは、専用のバッファに差分やログを表示したりするコマンドです。それぞれ
の差分またはログが表示されている限り、それらの引数は明らかに効果を持ち続
けます。さらに、使用された引数は、将来の参照のためにバッファローカル変数
に格納されます。

2番目のグループのコマンドの場合、一時的前置コマンドが再度呼び出されたと
きに、引数をグローバル値にリセットすることが常に望ましいとは限りません。

上記のように、一時的なポップアップが表示されている間に、以前に使用された
引数のセットを循環させることができます。つまり、既存のバッファでアクティ
ブになっている引数のセットは‘M-p’の数個しか離れていないため、中置引数を
常にデフォルトにリセットできます。Magitはそのように動作するように構成で
きますが、ほとんどのユーザーにとってはそれほど便利ではないと思うので、デ
フォルトではありません。

また、‘D’と‘L’でそれぞれの「refresh」一時前置コマンドを使用して、現在の
バッファ(diffセクションとlogセクションの両方を含むステータスバッファを含
む)で使用されるdiff引数とlog引数を変更できることにも注意してください。
(一方、‘d’と‘l’は、差分またはログの表示方法を変更することを*目的*として
います。差分またはログの*表示方法*を同時に変更することもできますが、後者
のみを実行する場合は、refreshのバリエーションを使用する必要があります。
）これらのセカンダリdiffおよびlog一時前置は、現在のバッファで使用される
引数の*変更*に関するものであるため、常に、そのバッファで現在有効な引数の
セットから開始します。

一部のコマンドは、一時的な前置コマンドの後置として呼び出すこともできます
が、通常は直接呼び出されます。最も目立つように、‘magit-show-commit’は通
常、ポイントがログのコミット中に‘RET’と入力することで呼び出されますが、
‘magit-diff’一時前置から呼び出すこともできます。

このようなコマンドを直接呼び出す場合は、デフォルトの引数を使用するのでは
なく、それぞれのバッファローカル値で指定された引数を再利用することが重要
です。 logで‘RET’を押して別のバッファ内のポイントでcommitを表示し、次に
‘D’を使用してそのバッファでの差分の表示方法を変更するとします。次に、別
のcommitで‘RET’を押して、代わりにdiff引数がデフォルトにリセットされるこ
とを示します。クールじゃありません。したがって、Magitはデフォルトではそ
れを行いません。

 -- User Option: magit-prefix-use-buffer-arguments

     このオプションは、特定の一時的な前置コマンドで最初に表示される中置
     引数が、後置が更新するバッファで現在有効な引数に基づいているかどう
     かを制御します。

     ‘magit-diff’および‘magit-log’の一時的な前置コマンドは、このオプショ
     ンの影響を受けます。

 -- User Option: magit-direct-use-buffer-arguments

     このオプションは、特定のコマンドが直接呼び出されたときに(つまり、一
     時的前置コマンドの後置としてではなく)、更新しようとしているバッファ
     で現在アクティブな引数を使用するかどうかを制御します。代替手段は、
     これらの引数にデフォルト値を使用することで、これにより、バッファで
     使用される引数が変更される可能性があります。

上記の両方のオプションの有効な値は以下のとおりです:

   • ‘always’: もちろんバッファが存在する場合は、それぞれのバッファで現
     在アクティブな引数のセットを常に使用します。

   • ‘selected’または‘t’: それぞれのバッファからの引数のセットを使用しま
     すが、それが現在のフレームのウィンドウに表示されている場合に限りま
     す。これは、両方の変数のデフォルトです。

   • ‘current’: それぞれのバッファからの引数のセットを使用しますが、それ
     が現在のバッファ(current buffer)である場合に限ります。

   • ‘never’: それぞれのバッファーからの引数のセットを使用しないでくださ
     い。

私はそれがさらに複雑になるのではないかと心配しています:

   • グローバルのdiffおよびlog引数は、サポートされているモードごとに個別
     に設定されます。たとえば、diff引数は、‘magit-diff-mode’、
     ‘magit-revision-mode’、‘magit-merge-preview-mode’および
     ‘magit-status-mode’バッファで異なる値を持ちます。あるモードの値を設
     定または保存しても、他のモードの値は変更されません。ただし、履歴は
     共有されます。

   • ‘magit-show-commit’がログバッファから直接呼び出されると、ファイルフ
     ィルターは、リビジョンバッファやモードのグローバルdiff引数からでは
     なく、そのバッファから取得されます。

   • これらはdiff前置の後置ですが、‘magit-show-commit’と
     ‘magit-stash-show’は、diffコマンドで使用されるdiffバッファを使用せ
     ず、代わりに専用のリビジョンバッファーとstashバッファーを使用します
     。

     diff前置を呼び出すとき、どの後置コマンドを呼び出すかはMagitにはわか
     りません。確かではありませんが、多くの場合、ユーザーはdiffバッファ
     を使用するコマンドのいずれかを呼び出すため、最初の中置引数はそのバ
     ッファで使用されるものです。ただし、これらのコマンドの1つを直接呼び
     出すと、Magitはリビジョンまたはリビジョンごとの引数を使用する必要が
     あることを認識します。 スタッシュバッファ。

   • ログ前置にはreflogコマンドもありますが、これらのコマンドはログ引数
     を使用しません。

   • ‘magit-show-refs’が‘magit-refs-mode’バッファから呼び出された場合、
     それはrefresh前置として機能するため、バッファの引数を初期引数として
     無条件に使用します。前置引数を使用して他の場所で呼び出された場合、
     通常の前置として機能するため、‘magit-prefix-use-buffer-arguments’を
     尊重します。前置引数なしで他の場所で呼び出された場合、直接コマンド
     として機能するため、‘magit-direct-use-buffer-arguments’を尊重します
     。


File: magit.ja.info,  Node: Completion Confirmation(確認補完)とSelection(選択範囲),  Next: Running Git,  Prev: 一時的引数とバッファ変数,  Up: Interface Concepts

4.5 Completion(補完)とConfirmation(確認)とSelection(選択範囲)
=============================================================

* Menu:

* アクションの確認::
* 補完と確認::
* 選択範囲::
* ハンク内部リージョン::
* 補完フレームワークのサポート::
* 追加の補完オプション::


File: magit.ja.info,  Node: アクションの確認,  Next: 補完と確認,  Up: Completion Confirmation(確認補完)とSelection(選択範囲)

4.5.1 アクションの確認
----------------------

デフォルトでは、データ損失につながる可能性のある多くのアクションを確認す
る必要があります。これには多くの非常に一般的なアクションが含まれるため、
これはすぐに煩わしくなります。これらのアクションの多くは元に戻すことがで
きるので、あなたが特定の間違いを元に戻す方法を考えている場合は、それぞれ
のアクションの確認を無効にしても安全です。

オプション‘magit-no-confirm’を使用すると、ユーザーが確認しなくても特定の
アクションを実行するようにMagitに指示できます。このオプションは特定のア
クションセットの確認を無効にするためにのみ使用できますが、次節では、
Magitに質問を少なくするように指示する別の方法について説明します。

 -- User Option: magit-no-confirm

     このオプションの値はシンボルのリストであり、実行する前にユーザーが
     確認する必要のないアクションを表します。

     デフォルトでは、多くの潜在的に危険なコマンドがユーザーに確認を求め
     ます。以下の各シンボル、意図せずに、または結果を完全に認識せずに呼
     び出された場合に、涙を流す可能性のあるアクションを表しています。多
     くの場合、特定のアクションのバリエーションを実行するコマンドがいく
     つかあるため、コマンド名ではなく、より一般的なシンボルを使用します
     。

        • 変更の適用:

             • ‘discard’ 1つ以上の変更(つまり、ファイルのハンクまたは完
               全な差分)を破棄すると、明らかにその変更が失われます。

             • ‘reverse’ 1つ以上の変更を元に戻すには、通常、reversionの
               復元によって元通りにすることができます。

             • ‘stage-all-changes’, ‘unstage-all-changes’ ステージされた
               変更とステージされていない変更の両方がある場合、すべての
               ステージを解除/ステージすると、その区別が失われます。もち
               ろん、これは単一の変更をアンステージ/ステージする場合にも
               当てはまりますが、失われるものは少なく、頻繁に行うため、
               毎回確認する必要はありません。

        • Files:

             • ‘delete’ Gitによってまだ追跡されていないファイルが削除さ
               れると、最後の変更だけでなく、完全に失われます。大変危険
               です。

             • ‘trash’ ファイルを削除する代わりに、システムのゴミ箱に移
               動することもできます。明らかに、それを削除するよりもはる
               かに危険が少ないです。

               オプション‘magit-delete-by-moving-to-trash’もご覧ください
               。

             • ‘resurrect’ 削除されたファイルは、最初に同じファイルを削
               除するために使用されたのと同じコマンドを使用して実行され
               る削除を「削除」することにより、簡単に復活させることがで
               きます。

             • ‘untrack’ ファイルの追跡解除(untracking)は、ファイルを再
               度追跡(tracking)することで元に戻すことができます。

             • ‘rename’ ファイルの名前変更は簡単に元に戻すことができます
               。

        • 一連の処理:

             • ‘reset-bisect’ bisect操作を中止(abort)すると(Gitでは「リ
               セット」と呼ばれます)、これまでに収集されたすべての情報が
               失われます。

             • ‘abort-rebase’ リベースを中止(abort)すると、すでに変更さ
               れたすべてのコミットが破棄されますが、reflogからそれらを
               復元することは可能です。

             • ‘abort-merge’ マージを中止(abort)すると、ユーザーがすでに
               実行したすべての競合解決(conflict resolution)が破棄されま
               す。

             • ‘merge-dirty’ ダーティなワークツリーとマージすると、マー
               ジが開始される前の状態に戻るのが難しくなる可能性がありま
               す。

        • 参照:

             • ‘delete-unmerged-branch’ ブランチが削除されると、Gitが提
               供する低レベルのリカバリツールを使用してのみ復元できます
               。そしてそれでもreflogはなくなってしまいます。ユーザーは
               常にデフォルトの選択を受け入れる(または別のブランチを選択
               する)ことによってブランチの削除を確認する必要がありますが
               、ブランチがまだマージされていない場合は、ユーザーがそれ
               を認識していることも確認してください。

             • ‘delete-pr-remote’ プルリクエストから作成されたブランチを
               削除するときに、そのリモートに他のブランチがまだ存在しな
               い場合、‘magit-branch-delete’はリモートも削除するように提
               案します。これは、リモート名前空間(remotes namespace)に他
               の参照が存在しない場合にのみ発生し、必要に応じてリモート
               を再作成できるため、安全であるはずです。

             • ‘drop-stashes’ Gitはスタッシュをreflogに保存するため、ス
               タッシュを削除するのは危険です。スタッシュが削除されると
               、Gitが提供する低レベルのリカバリツールを使用せずに戻すこ
               とはできません。単一のスタッシュがドロップされた場合、ユ
               ーザーは常にデフォルトを受け入れる(または別のスタッシュを
               選択する)ことによって確認する必要があります。このアクショ
               ンは、一度に複数のスタッシュを削除する場合のみ関係します
               。

        • Publishing:

             • ‘set-and-push’ アップストリームまたはプッシュリモートにプ
               ッシュし、それが実際にはまだ構成されていない場合、ユーザ
               ーは最初にターゲットを設定できます。デフォルトの確認が速
               すぎると、間違ったブランチにプッシュしてしまう可能性があ
               り、リモートリポジトリがそのような間違いの修正を許可しな
               いように構成されている場合、それは非常にどぎまぎして胸糞
               悪いことになる可能性があります。

        • Edit published history:

          ここにこれらのシンボルを追加しないと、
          ‘magit-published-branches’にリストされているブランチの1つにす
          でにプッシュされているコミットを編集する前に警告が表示されます
          。

             • ‘amend-published’「HEAD」を修正するほとんどのコマンドに影
               響します。

             • ‘rebase-published’ 対話的なリベースを実行するコマンドに影
               響します。これには、「HEAD」以外のコミットを変更する、つ
               まみぐいコミット(commit transient)なコミットからのコマン
               ド、つまりさまざまなfixupとsquashのバリエーションが含まれ
               ます。

             • ‘edit-published’ コマンド‘magit-edit-line-commit’および
               ‘magit-diff-edit-hunk-commit’に影響します。これらの2つの
               コマンドを使用すると、公開されたコミット(published
               commit)を誤って編集することが非常に簡単になるため、確認を
               求めないように構成する前に、よく考えておく必要があります
               。

          確認を完全に無効にするには、ここに3つのシンボルすべてを追加す
          るか、‘magit-published-branches’を‘nil’に設定します。

        • その他:

             • ‘kill-process’ プロセスを強制終了する理由はめったにありま
               せん。

        • Global settings:

          このオプションの値に上記のすべてのシンボルを追加する代わりに、
          アトム‘t’に設定することもできます。これは、上記のすべてのシン
          ボルを追加するのと同じ効果があります。特に他のシンボルが将来追
          加される可能性があるため、これを行うことは間違いなく悪い考えで
          す。したがって、これらのアクションのいずれについても確認を求め
          られたくない場合でも、それぞれのシンボルをすべて個別に追加する
          ことをお勧めします。

          ‘magit-wip-before-change-mode’が有効になっている場合、
          ‘discard’と‘reverse’と‘stage-all-changes’と
          ‘unstage-all-changes’アクションはかなり簡単に元に戻すことがで
          きます。このモードが有効になっている場合にのみ、
          ‘safe-with-wip’はこれらのシンボルをすべて個別に追加するのと同
          じ効果があります。


File: magit.ja.info,  Node: 補完と確認,  Next: 選択範囲,  Prev: アクションの確認,  Up: Completion Confirmation(確認補完)とSelection(選択範囲)

4.5.2 補完と確認
----------------

多くのMagitコマンドは、ユーザーに、実行可能なもののリストから選択するよ
うに求めますが、デフォルトとして最も可能性の高い選択肢を提供します。これ
らのコマンドの多くでは、実際に実行することできるという条件のものが提供さ
れ、デフォルトはその時点でのものです。ブランチに作用する多くのコマンドで
は、ポイントにブランチがない場合、現在のブランチがデフォルトになります。

これらのコマンドは、確認(confirm)を求めることと、アクションを実行するタ
ーゲットを求めることを組み合わせて1つのアクションにします。ユーザーは、
‘RET’を使用してデフォルトのターゲットを確認するか、‘C-g’を使用して中止
(abort)することができます。これは‘y-or-n-p’プロンプトに似ていますが、確
認(confirm)または中止(abort)するためのキーが異なります。

同時に、ユーザーには別のターゲットを選択する機会も与えられます。これは、
コマンドや状況によっては、ターゲットに移動して選択する前にアクションを選
択したい場合があるため便利です。

けれども、一部のコマンドでは、デフォルトのターゲットがあればそれを常に使
用したい場合や、確認をまったく必要とせずにコマンドをデフォルトで動作させ
たい場合もあります。オプション‘magit-dwim-selection’を使用して、その効果
をもたらす特定のコマンドを構成できます。

リージョンがアクティブな場合、多くの場合、確認を求めた後、リージョンに基
づくメカニズムを使用して選択されたものに多くのコマンド達が作用することに
注意してください。このリージョンベースのメカニズムは「selection」(選択状
態)と呼ばれ、次節で詳しく説明します。呼び出されたコマンドに有効な
selectionが存在する場合、そのコマンドは他の何かに作用することを提案する
ことはなく、確認を求めるかどうかはこのオプションによって制御されません。

また、Magitは、補完(completion)(または選択状態(selection))と結び付けられ
ていない特定のアクションの確認を要求することにも注意してください。このよ
うなダイアログもこのオプションの影響を受けず、前の節で説明済です。

 -- User Option: magit-dwim-selection

このオプションを使用すると、確認の有無にかかわらず、アクションを実行する
候補をユーザーに選択する代わりに、特定のコマンドにそのpointでそれを使用
するように指示できます。

値の形式は‘((COMMAND nil|PROMPT DEFAULT)...)’です。

   • COMMANDは、選択を求めるプロンプトを表示してはならないコマンドです。
     効果を得るには、コマンドで関数‘magit-completing-read’を使用するか、
     ユーティリティ関数を使用してその関数を使用する必要があります。

   • コマンドが‘magit-completing-read’を複数回使用する場合、PROMPTは、こ
     れらの使用の1つにのみ影響を与えるために使用できます。PROMPTは、
     nil以外の場合、‘magit-completing-read’に渡されるPROMPT引数と照合す
     るために使用される正規表現です。

   • DEFAULTは、デフォルトの使用方法を指定します。‘t’の場合、
     ‘magit-completing-read’に渡されたDEFAULT引数が確認なしで使用されま
     す。‘ask’の場合、ユーザーは中止する機会が与えられます。DEFAULTは
     ‘nil’にすることもできます。この場合、エントリは効果がありません。


File: magit.ja.info,  Node: 選択範囲,  Next: ハンク内部リージョン,  Prev: 補完と確認,  Up: Completion Confirmation(確認補完)とSelection(選択範囲)

4.5.3 選択範囲
--------------

リージョンがアクティブな場合、多くのMagitコマンドは、単一のものではなく
、リージョンに基づくメカニズムを使用して選択されたもの達に作用します。リ
ージョンがアクティブでない場合、これらのコマンドはそのpointでモノに作用
するか、作用する単一のモノを読み取ります。これについては前節で説明しまし
た。この節では、複数のものを選択する方法、それを視覚化する方法、およびそ
の場合の特定のコマンドの動作についてのみ説明します。

複数のもの、またはこれらを表すセクションを選択するためのMagitのメカニズ
ムは、Emacsリージョンに基づいていますが、Magitが選択すると見なすリージョ
ンは通常、リージョンよりも大きく、追加の制限が適用されます。

Magitは、有効なMagit選択範囲(selection)を形成する資格があるリージョンと
そうでないリージョンを区別します。リージョンが適格でない場合は、他の
Emacsバッファと同じように表示されます。リージョンがMagit選択範囲として適
格である場合、選択範囲は常に視覚化されますが、リージョン自体は、同じ行で
開始および終了する場合にのみ視覚化されます。

リージョンがMagit選択範囲(selection)として適格であるためには、そのリージ
ョンは1つのセクションの見出しで始まり、兄弟セクションの見出しで終わる必
要があります。リージョンの終わりがセクション見出しの最初(つまり、行の最
初)にある場合、そのセクションは選択範囲の「内側」と見なされることに注意
してください。

これは、リージョンがEmacsで通常どのように扱われるかと一致していません。
Emacsリージョンが行の先頭で終了する場合、その行はEmacsリージョンの外側に
あります。Magitが選択範囲を視覚化する方法により、この違いが存在すること
は明らかです。

すべてのコマンドがすべての有効な選択範囲に作用するわけではありません。一
部のコマンドはポイントの位置さえ考慮しません。他のコマンドはポイントでセ
クションに作用しますが、選択範囲に作用することをサポートしません。もちろ
ん、選択範囲をサポートするコマンドでさえ、作用できるものを選択する場合に
のみそうします。

これが、選択範囲にポイントのセクションを含める必要がある主な理由です。選
択範囲が存在する場合でも、呼び出されたコマンドはそれを無視する場合があり
ます。その場合、現在のセクションにのみ作用する可能性があります。選択した
セクションの「代わりに」現在のセクションに作用するよりも、現在のセクショ
ンにのみ作用し、他の選択したセクションには作用しない方がはるかに安全です
。後者の方がはるかに驚くべきことであり、現在のセクションが常に選択範囲の
一部である場合、それは起こり得ません。

 -- Variable: magit-keep-region-overlay

     この変数は、有効なMagit選択範囲またはハンク内部リージョンが存在する
     場合でも、リージョンを通常どおりに視覚化するかどうかを制御します。
     詳細については、doc-stringを参照してください。


File: magit.ja.info,  Node: ハンク内部リージョン,  Next: 補完フレームワークのサポート,  Prev: 選択範囲,  Up: Completion Confirmation(確認補完)とSelection(選択範囲)

4.5.4 ハンク内部リージョン
--------------------------

前節で説明したMagitの選択範囲にいくらか関連しているのは、ハンク内部リー
ジョンです。

選択範囲と同様に、ハンク内部リージョンはEmacsリージョンに基づいています
が、そのリージョンは他のEmacsバッファの場合のように視覚化されず、そして
、そのリージョンの行の最初で終了しても、そのリージョンにはその行の終わり
までが含まれます。

1つのセクションの見出しで始まり、兄弟セクションのセクションで終わるリー
ジョンに基づく選択状態とは異なり、ハンク内部リージョンは、ハンクセクショ
ンの「ボディ」内で始まり、そのセクションのボディ内で終わる必要があります
。

ハンク内部リージョンは、"apply"コマンドによって尊重されます。このコマン
ドは、他のターゲットの中でも、ハンクに作用することができます。 ハンク内
部リージョンがアクティブな場合、そのようなコマンドは、ハンク全体ではなく
、ハンク中のマークされた部分にのみ作用します。


File: magit.ja.info,  Node: 補完フレームワークのサポート,  Next: 追加の補完オプション,  Prev: ハンク内部リージョン,  Up: Completion Confirmation(確認補完)とSelection(選択範囲)

4.5.5 補完フレームワークのサポート
----------------------------------

組み込みオプション‘completing-read-function’は、‘completing-read’がユー
ザーに選択肢のリストから選択するように求めるために使用する低レベル関数を
指定します。デフォルト値は‘completing-read-default’です。代替の補完フレ
ームワークは通常、独自の実装で置き換えることによってそれ自体をアクティブ
にします。

主に歴史的な理由から、Magitは‘magit-completing-read-function’という名前
の同様のオプションを提供します。これは、‘magit-completing-read’によって
使用される低レベル関数のみを制御します。このオプションを使用すると、
Magitで他のEmacsとは異なる補完メカニズムを使用することもできますが、これ
を行うことはお勧めしません。

ほとんどの場合、代替の補完フレームワークを使用するためにmagit固有のオプ
ションをカスタマイズする必要はありません。 たとえば、‘ivy-mode’を有効に
すると、Magitはそれを尊重し、‘helm-mode’を有効にすると、それも補完します
。

ただし、Idoを使用する場合は、‘ido-mode’ではうまくいきません。 また、
‘ido-completing-read+’パッケージをインストールし、
‘magit-ido-completing-read’を‘magit-completing-read-function’として使用
する必要があります。

 -- User Option: magit-completing-read-function

     この変数の値は、(組み込みの‘completing-read’ではなく
     )‘magit-completing-read’を使用するコードによる補完を実行するために
     使用される低レベル関数です。

     デフォルト値の‘magit-builtin-completing-read’は、少なくとも標準の補
     完メカニズムである‘ivy-mode’と‘helm-mode’に適しています。

     組み込みの‘completing-read’と‘completing-read-default’は、ここでの
     使用には「適していません」。‘magit-builtin-completing-read’はいくつ
     かの追加作業を実行し、その場所で使用される関数はすべて同じことを実
     行する必要があります。

 -- Function: magit-builtin-completing-read prompt choices &optional
          predicate require-match initial-input hist def

     この関数は、組み込みの‘completing-read’を使用して補完を実行し、
     magit固有の追加の作業を実行します。

 -- Function: magit-ido-completing-read prompt choices &optional
          predicate require-match initial-input hist def

     この関数は、(明示的にインストールする必要がある)同じ名前のパッケー
     ジから‘ido-completing-read+’を使用して補完を実行し、さらにいくつか
     のmagit固有の作業を実行します。

     Ido自体に付属している‘ido-completing-read’の代わりに
     ‘ido-completing-read+’を使用する必要があります。後者は、drop-in代替
     として意図されていますが、その目的を果たすことができないためです。
     暗黙の規則の多くに違反しています。

 -- Function: magit-completing-read prompt choices &optional predicate
          require-match initial-input hist def fallback

     これは、Magitコマンドが、ユーザーが操作するものを1つ選択する必要が
     ある場合に使用する機能です。引数の意味は、‘completing-read’の場合と
     同じですが、FALLBACKはこの関数に固有ですので以下で説明します。

     この関数は、可能な候補のリストから選択するようにユーザーに求める代
     わりに、ユーザーの確認を必要とするかどうかに関係なく、DEFで指定され
     たデフォルトを返すだけの場合があります。それが当てはまるかどうかは
     、PROMPTと‘this-command’と‘magit-dwim-selection’によって異なります
     。 詳細については後述します。

     ミニバッファの値を読み取る場合、この関数は‘completing-read’と同様に
     機能しますが、以下の点が異なります:

        • COLLECTIONは選択肢のリストでなければなりません。関数はサポート
          されていません。

        • REQUIRE-MATCHが‘nil’であり、ユーザーが選択せずに終了した場合、
          空文字列の代わりに‘nil’が返されます。

        • REQUIRE-MATCHがnil以外で、ユーザーが選択せずに終了した場合、ユ
          ーザーエラー(user-error)が発生(raise)します。

        • FALLBACKは、一次デフォルトDEFが‘nil’の場合にのみ使用される二次
          デフォルトを指定します。 二次デフォルトは
          ‘magit-dwim-selection’の対象ではありません。DEFが‘nil’であるが
          、FALLBACKがそうでない場合、この関数は、両方のデフォルトが
          ‘nil’であるかのように、常にユーザーに候補を選択するように求め
          ます。

        • ": " がPROMPT@に追加されます。

        • PROMPTは、\" (default DEF|FALLBACK): \"で終わるように変更され
          ます。ただし、DEFまたはFALLBACKがnil以外であり、‘ivy-mode’も
          ‘helm-mode’も有効になっていない場合、
          ‘magit-completing-read-function’は、デフォルト値の
          ‘magit-builtin-completing-read’に設定されています。


File: magit.ja.info,  Node: 追加の補完オプション,  Prev: 補完フレームワークのサポート,  Up: Completion Confirmation(確認補完)とSelection(選択範囲)

4.5.6 追加の補完オプション
--------------------------

 -- User Option: magit-list-refs-sortby

     ユーザーから1つまたは複数の参照(ref)を読み取る多くのコマンドでは、
     このオプションの値を使用して、参照(refs)の順序を制御できます。有効
     な値には、‘gitfor-each-ref’の‘--sort’フラグで受け入れられるすべての
     キーが含まれます。デフォルトでは、参照はフルネームのアルファベット
     順に並べ替えられます(例: "refs/heads/master")。


File: magit.ja.info,  Node: Running Git,  Prev: Completion Confirmation(確認補完)とSelection(選択範囲),  Up: Interface Concepts

4.6 Running Git
===============

* Menu:

* Viewing Git Output::
* Git Process Status::
* Gitを手動で実行::
* Git実行ファイル::
* Global Git Arguments::


File: magit.ja.info,  Node: Viewing Git Output,  Next: Git Process Status,  Up: Running Git

4.6.1 Viewing Git Output
------------------------

Magitは、副作用(プッシュ時など)または何らかの値(現在のブランチの名前など
)を得るためにGitを実行します。

副作用のためにGitを実行すると、プロセス出力はリポジトリごとのログバッフ
ァに記録されます。これが期待どおりに進まない場合には‘magit-process’コマ
ンドを使用して参照できます。

最大‘magit-process-log-max’個のGitコマンドの 出力/エラー が保持されます
。

‘$’     (‘magit-process’)

     このコマンドは、現在のリポジトリのプロセスバッファを表示します。

そのバッファ内では、セクションをナビゲートおよび表示するための通常のキー
バインディングが利用可能です。これらに追加のコマンドが1つあります。

‘k’     (‘magit-process-kill’)

     このコマンドは、ポイントしているセクションで表されるプロセスを強制
     終了します。

 -- User Option: magit-git-debug

     これがnil以外の場合、gitへのすべての呼び出しの出力はプロセスバッフ
     ァーに記録されます。これはデバッグ時に役立ちます。デバッグ時以外は
     パフォーマンスに悪影響を与えるだけです。


File: magit.ja.info,  Node: Git Process Status,  Next: Gitを手動で実行,  Prev: Viewing Git Output,  Up: Running Git

4.6.2 Git Process Status
------------------------

副作用のためにGitプロセスが実行されている場合、Magitは
‘magit-mode-line-process’faceを使用して、モード行にインジケーターを表示
します。

Gitプロセスが正常に終了すると、プロセスインジケーターはモードラインから
直ちに削除されます。

Gitエラーの場合、プロセスインジケーターは削除されませんが、代わりに
‘magit-mode-line-process-error’faceで強調表示され、プロセスバッファーか
らのエラーの詳細がマウスユーザーのためにツールチップとして提供されます。
このエラーインジケータは、次のmagitバッファ更新までモード行に表示されま
す。

モード行にプロセスエラーを表示したくない場合は、
‘magit-process-display-mode-line-error’ユーザーオプションをカスタマイズ
します。

プロセスエラーは、ステータスバッファの先頭に追加で示されます。


File: magit.ja.info,  Node: Gitを手動で実行,  Next: Git実行ファイル,  Prev: Git Process Status,  Up: Running Git

4.6.3 Gitを手動で実行
---------------------

MagitはGitと対話するための多くのEmacsコマンドを提供しますが、すべてを網
羅しているわけではありません。そのような場合、既存のGitの知識が役立ちま
す。Magitは、シェルに切り替える代わりに、ミニバッファーに入力することで
任意のGitコマンドを実行するためのいくつかのコマンドを提供します。

‘!’     (‘magit-run’)

     この一時的(transient)前置(prefix)コマンドは、それに続く後置
     (suffix)コマンドを結びつけ、後置(suffix)コマンドが呼び出されるまで
     一時バッファ(temporary buffer)に表示します。

‘! !’     (‘magit-git-command-topdir’)

     このコマンドは、ユーザーからコマンドを読み取り、現在の作業ツリーの
     最上位ディレクトリで実行します。

     文字列「git」は、ユーザーにコマンドの入力を求めるときの初期入力とし
     て使用されます。別のコマンドを実行するために削除できます。

‘! p’     (‘magit-git-command’)

     このコマンドは、ユーザーからコマンドを読み取り、
     ‘default-directory’で実行します。前置引数を使用すると、コマンドは
     ‘default-directory’の代わりに現在の作業ツリーの最上位ディレクトリで
     実行されます。

     文字列「git」は、ユーザーにコマンドの入力を求めるときの初期入力とし
     て使用されます。別のコマンドを実行するために削除できます。

‘! s’     (‘magit-shell-command-topdir’)

     このコマンドは、ユーザーからコマンドを読み取り、現在の作業ツリーの
     最上位ディレクトリで実行します。

‘! S’     (‘magit-shell-command’)

     このコマンドは、ユーザーからコマンドを読み取り、
     ‘default-directory’で実行します。前置引数を使用すると、コマンドは
     ‘default-directory’の代わりに現在の作業ツリーの最上位ディレクトリで
     実行されます。

 -- User Option: magit-shell-command-verbose-prompt

     シェルコマンドを読み取るときに上記のコマンドで使用されるプロンプト
     が、それが実行されるディレクトリを表示しているかどうか。

これらの後置コマンドは、外部GUIツールを起動します。

‘! k’     (‘magit-run-gitk’)

     このコマンドは、現在のリポジトリで‘gitk’を実行します。

‘! a’     (‘magit-run-gitk-all’)

     このコマンドは、現在のリポジトリで‘gitk --all’を実行します。

‘! b’     (‘magit-run-gitk-branches’)

     このコマンドは、現在のリポジトリで‘gitk --branches’を実行します。

‘! g’     (‘magit-run-git-gui’)

     このコマンドは、現在のリポジトリで‘git gui’を実行します。


File: magit.ja.info,  Node: Git実行ファイル,  Next: Global Git Arguments,  Prev: Gitを手動で実行,  Up: Running Git

4.6.4 Git実行ファイル
---------------------

MagitがGitを呼び出すときは、‘git’実行可能ファイルへの絶対パスを使用する
か、その名前だけを使用して呼び出すことができます。

‘git’をローカルで実行し、かつ、‘system-type’が‘windows-nt’(任意の
Windowsバージョン)または‘darwin’(macOS)の場合、‘magit-git-executable’は
Magitがロードされるときに絶対パスに設定されます。

Windowsでは、絶対パスを使用する必要があります。Gitには実際の‘git’バイナ
リ用のラッパースクリプトがいくつか付属しており、これらも‘$PATH’に配置さ
れ、バイナリの代わりにこれらのラッパーの1つを使用すると パフォーマンスが
ひどく低下します。一部のmacOSユーザーの場合、実行可能ファイルの名前だけ
を使用するとパフォーマンスが低下するため、このプラットフォームでもそうい
う実行を回避します。 他のプラットフォームでは、名前だけを使用しても問題
なく機能するようです。

Trampを介してリモートマシンで‘git’を実行するときに絶対パスを使用すると、
ローカルマシンに適した絶対パスを使用するのが問題になるため、リモートマシ
ンで使用される名前またはパスを制御するために別のオプションが使用されます
。

 -- User Option: magit-git-executable

     ローカルホスト上のMagitによって使用される‘git’実行可能ファイル。こ
     れは、実行可能ファイルへの絶対パス、またはEmacsがそのようなことを行
     うための標準メカニズムを使用して実行可能ファイル自体を見つけられる
     ようにする文字列"git"のいずれかである必要があります。

 -- User Option: magit-remote-git-executable

     Trampを介してリモートマシン上のMagitによって使用される‘git’実行可能
     ファイル。通常、これは文字列"git"である必要があります。このオプショ
     ンの代わりに‘tramp-remote-path’をカスタマイズすることを検討してくだ
     さい。

Emacsが正しい実行可能ファイルを見つけられない場合は、これら2つのオプショ
ンのいずれかの値を明示的に設定することで回避できます。それを行うことは、
応急修理と見なされるべきです。‘exec-path’または‘tramp-remote-path’の順序
が正しいことを確認することをお勧めします。

‘exec-path’は、Emacsの起動時に有効な‘PATH’環境変数の値に基づいて設定され
ることに注意してください。あなたのシェルのinitファイルで‘PATH’を設定した
場合、そのシェルから開始した場合にのみEmacsに影響します(プロセスの環境は
子プロセスにのみ渡され、他の任意のプロセスには渡されないため)。それが
Emacsの起動方法ではない場合は、‘exec-path-from-shell’パッケージが役立ち
ます。正直なところ、私もそれを応急修理だと思います。

コマンド‘magit-debug-git-executable’は、Emacsが‘git’を検索している場所を
見つけるのに役立ちます。

‘M-x magit-debug-git-executable’     (‘magit-debug-git-executable’)

     このコマンドは、‘magit-git-executable’および
     ‘magit-remote-git-executable’に関する情報を含むバッファを表示します
     。

‘M-x magit-version’     (‘magit-version’)

     このコマンドは、現在使用されているMagit、Git、およびEmacsのバージョ
     ンをエコー領域に表示します。非インタラクティブでは、これは単に
     Magitバージョンを返すだけです。


File: magit.ja.info,  Node: Global Git Arguments,  Prev: Git実行ファイル,  Up: Running Git

4.6.5 Global Git Arguments
--------------------------

 -- User Option: magit-git-global-arguments

     ここで設定された引数は、git実行可能ファイルがサブプロセスとして実行
     されるたびに使用されます。これらは、実行可能ファイル自体の直後で、
     gitコマンドの前に配置されます。‘git HERE... COMMAND REST’のように。
     有効な引数については→ *note (gitman)git::

     特にTrampを使用して古いGitバージョンのサーバーに接続している場合は
     、ここに何を追加するかに注意してください。自分が何をしているかを本
     当に理解していない限り、デフォルト値の一部であるものは絶対に削除し
     ないでください。そして、何かを追加する前に、非常によく考えてくださ
     い。それはMagitがどんな目的であれGitを実行するたびに使用されます。


File: magit.ja.info,  Node: Inspecting,  Next: Manipulating,  Prev: Interface Concepts,  Up: Top

5 Inspecting
************

Magitが提供する機能は、既存のデータの検査、既存のデータの操作または新し
いデータの追加、データの転送の3つのグループに大別できます。もちろん、そ
れはかなり大雑把な区別であり、しばしば不十分ですが、まったく区別しないよ
りも便利です。この節はデータの検査に関係し、次の2つはデータの操作と転送
に関係します。次に、この区別に簡単に当てはまらないその他の機能に関する節
が続きます。

もちろん、他の区別も意味があります。Gitでの磁器コマンドと配管コマンドの
区別。これは、ほとんどの場合、Emacsでのインタラクティブコマンドと非イン
タラクティブ機能の区別に相当します。前述のすべての節は、主に磁器に関係し
ています。Magitの配管コマンド層については後で説明します。

* Menu:

* Status Buffer::
* Repository List::
* Logging::
* Diffing::
* Ediffing::
* References Buffer::
* Bisecting::
* Visiting Files and Blobs::
* Blaming::


File: magit.ja.info,  Node: Status Buffer,  Next: Repository List,  Up: Inspecting

5.1 Status Buffer
=================

他のMagitバッファ達では、例えば、1つの特定の差分または1つの特定のログや
、ステータスバッファならばステージされた変更とステージされていない変更の
差分、プッシュされていないコミットとプルされていないコミットのログ、スタ
ッシュと追跡されていないファイル(untracked files)のリスト、および現在の
ブランチに関連する情報が含まれます。

特定の不完全な操作の途中(たとえば、マージによって競合が発生した場合)、操
作の続行または中止に役立つ追加情報が表示されます。

コマンド‘magit-status’は、現在のリポジトリに属するステータスバッファを別
のウィンドウに表示します。このコマンドは頻繁に使用されるため、グローバル
にバインドすべきです。我々は‘C-x g’をお勧めします:

     (global-set-key (kbd "C-x g") 'magit-status)

‘C-x g’     (‘magit-status’)

     既存のGitリポジトリ内から呼び出されると、このコマンドはバッファ内の
     そのリポジトリのステータスを表示します。

     現在のディレクトリがGitリポジトリ内にない場合、このコマンドは、オプ
     ション‘magit-repository-directories’に応じて、既存のリポジトリまた
     は任意のディレクトリの入力を求め、その代わりに選択したリポジトリの
     ステータスが表示されます。

        • そのオプションで既存のリポジトリ達が指定されている場合、ユーザ
          ーはそれらの1つを選択するように求められます。

        • それ以外の場合、ユーザーは通常のファイル名補完を使用して任意の
          ディレクトリを選択するように求められます。選択したディレクトリ
          が既存の作業ツリーの最上位ディレクトリである場合、そのステータ
          スバッファが表示されます。

        • それ以外の場合、ユーザーは選択したディレクトリを新しいリポジト
          リとして初期化するように提案されます。リポジトリを作成すると、
          そのステータスバッファが表示されます。

     これらのフォールバック動作は、1つ以上の前置引数を使用して強制するこ
     ともできます。

        • 2つの前置引数(より正確には16以上の数値前置値)を使用して、任意
          のディレクトリが読み取られ、上記のように処理されます。コマンド
          ‘magit-init’を使用して同じことを実行できます。

        • 単一の前置引数を使用すると、既存のリポジトリがユーザーから読み
          取られます。または、‘magit-repository-directories’の値に基づい
          てリポジトリが見つからない場合、動作は2つの前置引数の場合と同
          じです。

 -- User Option: magit-repository-directories

     Gitリポジトリであるか、Gitリポジトリを含むディレクトリのリスト。

     各要素の形式は‘(DIRECTORY . DEPTH)’です。DIRECTORYは、ディレクトリ
     またはディレクトリファイル名で文字列である必要があります。DEPTHは整
     数でGitリポジトリを検索する最大の深さを指定します。DEPTHが0の場合は
     、DIRECTORY自体のみを追加します。

     このオプションは、‘magit-list-repositories’によってリストされるリポ
     ジトリを制御します。また、‘magit-status’(を参照)にも驚くべき方法で
     影響を及ぼします(上記を参照)。

 -- magit-status-quick: コマンド

     このコマンドは、‘magit-status’の代替になり、通常はステータスバッフ
     ァの更新を回避します。

     現在のGitリポジトリのステータスバッファが存在するが、選択したフレー
     ムに表示されていない場合は、更新されずに表示されます。

     選択したフレームにステータスバッファが表示されている場合、このコマ
     ンドはステータスバッファを更新します。

     前置引数は‘magit-status’の場合と同じ意味を持ち、さらにバッファを更
     新します。

     このコマンドを使用するには、以下をinitファイルに追加します:

          (global-set-key (kbd "C-x g") 'magit-status-quick).

     これを行った後、バッファを再表示してすぐに更新する場合は、‘C-x g’に
     続けて‘g’と入力します。

     可能な代替コマンドは‘magit-display-repository-buffer’です。現在のリ
     ポジトリに属する既存のMagitバッファの表示をサポートします。それはス
     テータスバッファだけではありません。

 -- ido-enter-magit-status: コマンド

     ファイルを開くために使用されるIdoプロンプトから、代わりに
     ‘magit-status’にドロップ(drop)します。これは
     ‘ido-magic-delete-char’に似ており、その名前にもかかわらず、通常は
     Diredバッファが作成されます。

     このコマンドを使用可能にするには、以下のようなものを使用します:

          (add-hook 'ido-setup-hook
                    (lambda ()
                      (define-key ido-completion-map
                        (kbd \"C-x g\") 'ido-enter-magit-status)))

     Emacs 25.1以降、IdoキーマップはIdoが呼び出されるたびではなく、一度
     だけ定義されるため、他のほとんどすべてのキーマップと同じように変更
     できるようになりました。

          (define-key ido-common-completion-map
            (kbd \"C-x g\") 'ido-enter-magit-status)

* Menu:

* Status Sections::
* Status Header Sections::
* Status Module Sections::
* Status Options::


File: magit.ja.info,  Node: Status Sections,  Next: Status Header Sections,  Up: Status Buffer

5.1.1 Status Sections
---------------------

ステータスバッファの内容は、フック‘magit-status-sections-hook’を使用して
制御されます。このようなフックとそれらをカスタマイズする方法については
→*note Section Hooks::

 -- User Option: magit-status-sections-hook

     フックを実行して、セクションをステータスバッファに挿入します。

デフォルトでは、そのフックの最初の関数は‘magit-insert-status-headers’で
す。次節で説明します。デフォルトでは、それに続く関数もそのフックのメンバ
ーです。

 -- Function: magit-insert-merge-log

     進行中のマージのセクションを挿入します。マージされているヘッド達を
     表示します。マージが進行中でない場合は、何もしません。

 -- Function: magit-insert-rebase-sequence

     進行中のリベースシーケンスのセクションを挿入します。そのようなシー
     ケンスが進行中でない場合は、何もしません。

 -- Function: magit-insert-am-sequence

     進行中のパッチ適用シーケンスのセクションを挿入します。そのようなシ
     ーケンスが進行中でない場合は、何もしません。

 -- Function: magit-insert-sequencer-sequence

     進行中のチェリーピックまたはrevertシーケンスのセクションを挿入しま
     す。そのようなシーケンスが進行中でない場合は、何もしません。

 -- Function: magit-insert-bisect-output

     bisectしている間、‘git bisect’からの出力を含むセクションを挿入しま
     す。

 -- Function: magit-insert-bisect-rest

     bisectしている間、bisect態を視覚化するセクションを挿入します。

 -- Function: magit-insert-bisect-log

     bisectしている間、bisectの進行状況をlogするセクションを挿入します。

 -- Function: magit-insert-untracked-files

     たぶん、追跡されていないファイル(untracked file)のリストまたはツリ
     ーを挿入します。

     ‘status.showUntrackedFiles’の値に応じてこれを行います。値が‘all’で
     あっても、Magitは最初はディレクトリのみを表示することに注意してくだ
     さい。ただし、ディレクトリセクションは‘TAB’を使用して展開できます。

 -- Function: magit-insert-unstaged-changes

     ステージされていない変更(unstaged changes)を示すセクションを挿入し
     ます。

 -- Function: magit-insert-staged-changes

     ステージされた変更(staged changes)を表すセクションを挿入します。

 -- Function: magit-insert-stashes &optional ref heading

     "refs/stash"のreflogを示す‘stashes’セクションを挿入します。オプショ
     ンのREFがnil以外の場合は、代わりにそのためのreflogを表示します。オ
     プションのHEADINGがnil以外の場合は、"Stashes:"の代わりにセクション
     見出しとして使用します。

 -- Function: magit-insert-unpulled-from-upstream

     アップストリームブランチからまだプルされていないコミットを示すセク
     ションを挿入します。

 -- Function: magit-insert-unpulled-from-pushremote

     プッシュリモートブランチからまだプルされていないコミットを示すセク
     ションを挿入します。

 -- Function: magit-insert-unpushed-to-upstream

     まだアップストリームにプッシュされていないコミットを示すセクション
     を挿入します。

 -- Function: magit-insert-unpushed-to-pushremote

     まだプッシュリモートにプッシュされていないコミットを示すセクション
     を挿入します。

以下の関数を上記のフックに追加することもできます:

 -- Function: magit-insert-tracked-files

     追跡中のファイル(tracked files)のツリーを挿入します。

 -- Function: magit-insert-ignored-files

     無視されたファイル(ignored files)のツリーを挿入します。‘D = f
     <DIRECTORY> RET g’を使用して、現在のバッファ内のログを特定のディレ
     クトリに制限することができます。これを行うと、このコマンドにも影響
     します。

     ログフィルターの使用により、対象ファイル達を絞り込めます。その場合
     、この関数は最初のファイルのみを尊重し、それがディレクトリである場
     合に限ります。

 -- Function: magit-insert-skip-worktree-files

     スキップワークツリーファイル(skip-worktree files)のツリーを挿入しま
     す。‘magit-buffer-diff-files’の最初の要素がディレクトリである場合は
     、リストをその下のファイル達だけに制限します。その変数の値は、‘D --
     DIRECTORY RET g’を使用して設定できます。

 -- Function: magit-insert-assumed-unchanged-files

     変更されていないと想定されるファイルのツリーを挿入します。
     ‘magit-buffer-diff-files’の最初の要素がディレクトリである場合は、リ
     ストをその下のファイル達に制限します。その変数の値は、‘D --
     DIRECTORY RET g’を使用して設定できます。

 -- Function: magit-insert-unpulled-or-recent-commits

     プルされていないコミットまたは最近のコミットを示すセクションを挿入
     します。アップストリームが現在のブランチ用に構成されていて、それが
     現在のブランチよりも進んでいる場合は、欠落しているコミットを表示し
     ます。それ以外の場合は、最後の‘magit-log-section-commit-count’コミ
     ットを表示します。

 -- Function: magit-insert-recent-commits

     最後の‘magit-log-section-commit-count’コミットを示すセクションを挿
     入します。

 -- User Option: magit-log-section-commit-count

     (プルされていないコミットがない場合、)
     ‘magit-insert-recent-commits’および
     ‘magit-insert-unpulled-or-recent-commits’の最近のコミット数が表示さ
     れます。

 -- Function: magit-insert-unpulled-cherries

     プルされていないコミットを示すセクションを挿入します。
     ‘magit-insert-unpulled-commits’と同様ですが、まだ適用されていない各
     コミット(つまり、ローカルコミットと共有されていないパッチ
     ID(patch-id)を持つコミット)の前に"+"を付け、他のすべてのコミットに
     は"-"を付けます。

 -- Function: magit-insert-unpushed-cherries

     プッシュされていないコミットを示すセクションを挿入します。
     ‘magit-insert-unpushed-commits’と同様ですが、アップストリームにまだ
     適用されていない各コミット(つまり、パッチID(patch-id)のあるコミット
     はアップストリームコミットと共有されていません)の前に"+"を付け、他
     のすべてのコミットには"-"を付けます。

ここで使用できるその他のセクションインサーターについては→*note
References Buffer::


File: magit.ja.info,  Node: Status Header Sections,  Next: Status Module Sections,  Prev: Status Sections,  Up: Status Buffer

5.1.2 Status Header Sections
----------------------------

ステータスバッファの内容は、フック‘magit-status-sections-hook’を使用して
制御されます(see *note Status Sections::)。

デフォルトでは、‘magit-insert-status-headers’がそのフック変数の最初のメ
ンバーです。

 -- Function: magit-insert-status-headers

     ‘magit-status-mode’バッファに適したヘッダーセクションを挿入します。
     セクションは、フック‘magit-status-headers-hook’で関数達を実行するこ
     とによって挿入されます。

 -- User Option: magit-status-headers-hook

     フックを実行して、ヘッダーセクションをステータスバッファーに挿入し
     ます。

     このフックは‘magit-insert-status-headers’によって実行され、それらの
     関数は‘magit-status-sections-hook’のメンバーである必要があります。

デフォルトでは、行か関数が上記のフックのメンバーです:

 -- Function: magit-insert-error-header

     ちょうど今発生したGitエラーに関するメッセージを示すヘッダー行を挿入
     します。

     この関数は、副作用のためにGitが実行されたときに発生した最後のエラー
     のみを認識します。たとえば、diffの生成中にエラーが発生した場合、そ
     のエラーは挿入されません。ステータスバッファを更新すると、このセク
     ションは再び表示されなくなります。

 -- Function: magit-insert-diff-filter-header

     有効なdiffフィルター達を示すヘッダー行を挿入します。

 -- Function: magit-insert-head-branch-header

     現在のブランチまたは切り離(detach)された‘HEAD’に関するヘッダー行を
     挿入します。

 -- Function: magit-insert-upstream-branch-header

     通常は現在のブランチにプル(pull into)されるブランチに関するヘッダー
     行を挿入します。

 -- Function: magit-insert-push-branch-header

     現在のブランチが通常プッシュされるブランチに関するヘッダー行を挿入
     します。

 -- Function: magit-insert-tags-header

     タグと‘HEAD’の間のコミット数とともに、現在または次のタグ、あるいは
     その両方に関するヘッダー行を挿入します。

以下の関数を上記のフックに追加することもできます:

 -- Function: magit-insert-repo-header

     リポジトリのトップレベルへのパスを表すヘッダー行を挿入します。

 -- Function: magit-insert-remote-header

     現在のブランチのリモートに関するヘッダー行を挿入します。

     現在のブランチにリモートが構成されていない場合は、フォールバックし
     て"origin"リモートを表示します。存在しない場合は、アルファベット順
     に最初のリモートを表示します。

 -- Function: magit-insert-user-header

     現在のユーザーに関するヘッダー行を挿入します。


File: magit.ja.info,  Node: Status Module Sections,  Next: Status Options,  Prev: Status Header Sections,  Up: Status Buffer

5.1.3 Status Module Sections
----------------------------

ステータスバッファの内容は、フック‘magit-status-sections-hook’を使用して
制御されます(see *note Status Sections::)。

デフォルトでは、‘magit-insert-modules’はそのフック変数のメンバーでは「あ
りません」。

 -- Function: magit-insert-modules

     サブモジュールセクションを挿入します。

     フック‘magit-module-sections-hook’は、挿入されるモジュールセクショ
     ンを制御し、オプション‘magit-module-sections-nested’は、それらを追
     加のセクションでラップ(wrap)するかどうかを制御します。

 -- User Option: magit-module-sections-hook

     ‘magit-insert-modules’によって実行されるフック。

 -- User Option: magit-module-sections-nested

     このオプションは、‘magit-insert-modules’が挿入されたセクションを追
     加のセクションでラップ(wrap)するかどうかを制御します。

     これがnil以外の場合、単一のトップレベルセクションのみが挿入されます
     。nilの場合、‘magit-module-sections-hook’にリストされているすべての
     セクションがトップレベルのセクションになります。

 -- Function: magit-insert-modules-overview

     すべてのサブモジュールのセクションを挿入します。セクションごとに、
     パスとブランチと、‘git describe --tags’の出力を挿入します。それがで
     きない場合は、省略されたHEADコミットハッシュを挿入します。

     このようなサブモジュールセクションで‘RET’を押すと、独自のステータス
     バッファが表示されます。"Modules"セクションで‘RET’を押すと、別のバ
     ッファにあるサブモジュールのリストが表示されます。これは、スーパー
     リポジトリ(super-repository)のステータスバッファに表示されない追加
     情報を表しています。

 -- Function: magit-insert-modules-unpulled-from-upstream

     まだアップストリームからプルされていないモジュールのセクションを挿
     入します。これらのセクションを展開して、それぞれのコミットを表示で
     きます。

 -- Function: magit-insert-modules-unpulled-from-pushremote

     プッシュリモートからまだプルされていないモジュールのセクションを挿
     入します。これらのセクションを展開して、それぞれのコミットを表示で
     きます。

 -- Function: magit-insert-modules-unpushed-to-upstream

     まだアップストリームにプッシュされていないモジュールのセクションを
     挿入します。これらのセクションを展開して、それぞれのコミットを表示
     できます。

 -- Function: magit-insert-modules-unpushed-to-pushremote

     まだプッシュリモートにプッシュされていないモジュールのセクションを
     挿入します。これらのセクションを展開して、それぞれのコミットを表示
     できます。


File: magit.ja.info,  Node: Status Options,  Prev: Status Module Sections,  Up: Status Buffer

5.1.4 Status Options
--------------------

 -- User Option: magit-status-refresh-hook

     ステータスバッファが更新された後、フックが実行されます。

 -- User Option: magit-status-margin

     このオプションは、マージン(margin)が最初にMagit-Statusモードのバッ
     ファーに表示されるかどうか、およびそのフォーマット方法を指定します
     。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、マージン(margin)が最初に表示されます。

        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。

        • WIDTHは、マージンの幅を制御します。これは上位互換性のために存
          在し、現在値を変更すべきではありません。

        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。

        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。

ステータスバッファに関するその他のオプションについては、前節も参照してく
ださい。


File: magit.ja.info,  Node: Repository List,  Next: Logging,  Prev: Status Buffer,  Up: Inspecting

5.2 Repository List
===================

 -- magit-list-repositories: コマンド

     このコマンドは、別のバッファにあるリポジトリのリストを表示します。

     オプション‘magit-repository-directories’および
     ‘magit-repository-directories-depth’は、表示されるリポジトリを制御
     します。

 -- User Option: magit-repolist-columns

     このオプションは、コマンド‘magit-list-repositories’によって表示され
     る列(columns)とその表示方法を制御します。

     各要素の形式は‘(HEADER WIDTH FORMAT PROPS)’です。

     HEADERは、ヘッダーに表示される文字列です。WIDTHは、列の幅です。
     FORMATは、1つの引数とリポジトリID(通常はそのベース名)と作業ツリーの
     最上位に結び付けられたされた‘default-directory’を使用して呼び出され
     る関数です。挿入する文字列またはnilを返す必要があります。PROPSは、
     キー‘:right-align’と‘:pad-right’‘：right-align’をサポートするリスト
     です。

     あなたは列ごとに1文字だけを使用し、列間にパディングなしで数値列の範
     囲を表示したい場合があるかもしれません。その場合は、適切なHEADERを
     使用し、WIDTHを1に設定し、‘:pad-right’を0に設定する必要があります。
     ‘+’は、9より大きい数値に置き換えられます。

上記のオプションに以下の機能を追加できます:

 -- Function: magit-repolist-column-ident

     この関数は、リポジトリのIDを挿入します。 通常、これは単なるベース名
     です。

 -- Function: magit-repolist-column-path

     この関数は、リポジトリの絶対パスを挿入します。

 -- Function: magit-repolist-column-version

     この関数は、リポジトリの‘HEAD’リビジョンの説明を挿入します。

 -- Function: magit-repolist-column-branch

     この関数は、現在のブランチの名前を挿入します。

 -- Function: magit-repolist-column-upstream

     この関数は、現在のブランチのアップストリームブランチの名前を挿入し
     ます。

 -- Function: magit-repolist-column-branches

     この関数は、ブランチの数を挿入します。

 -- Function: magit-repolist-column-stashes

     この関数は、スタッシュの数を挿入します。

 -- Function: magit-repolist-column-flag

     この関数は、‘magit-repolist-column-flag-alist’で指定されたフラグ
     (flag)を挿入します。

     デフォルトでは、コミットされていない変更(uncommitted changes)がある
     かどうかを示します。

        • ‘N’ならば、追跡されていないファイル(untracked file)が少なくと
          も1つある。

        • ‘U’ならばステージされていないファイル(unstaged file)が少なくと
          も1つある。

        • ‘S’ならばステージされたファイル(staged file)が少なくとも1つあ
          る。

     適用されるこれらの最初のものだけが示されています。

 -- Function: magit-repolist-column-unpulled-from-upstream

     この関数は、現在のブランチにないアップストリームコミットの数を挿入
     します。

 -- Function: magit-repolist-column-unpulled-from-pushremote

     この関数は、現在のブランチではなく、プッシュブランチにコミット数を
     挿入します。

 -- Function: magit-repolist-column-unpushed-to-upstream

     この関数は、現在のブランチにコミット数を挿入しますが、そのアップス
     トリームには挿入しません。

 -- Function: magit-repolist-column-unpushed-to-pushremote

     この関数は、現在のブランチにコミット数を挿入しますが、プッシュブラ
     ンチには挿入しません。


File: magit.ja.info,  Node: Logging,  Next: Diffing,  Prev: Repository List,  Up: Inspecting

5.3 Logging
===========

ステータスバッファには、プッシュされていないコミットとプルされていないコ
ミットのログが含まれていますが、それだけでは明らかに不十分です。‘l’上の
一時前置コマンド‘magit-log’は、個別のログバッファに特定のログを表示する
いくつかの後置スコマンドを備えています。

他の一時的前置コマンドと同様に、‘magit-log’にも、後置コマンドの1つを呼び
出す前に変更できるいくつかの中置引数達があります。 ただし、一時的ログ
(log transient)の場合、これらの引数は、
‘magit-prefix-use-buffer-arguments’の値に応じて、現在のリポジトリのログ
バッファで現在使用されている引数から取得される場合があります(*note
一時的引数とバッファ変数::)。

さまざまな引数の情報ついては→ *note (gitman)git-log::

スイッチ‘++order=VALUE’は、‘git log’に渡される前に、
‘--author-date-order’または‘--date-order’または‘--topo-order’のいずれか
に変換されます。

ログ一時コマンド(log transient)には、いくつかのreflogコマンドもあります
→*note Reflog::

‘l’     (‘magit-log’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

‘l l’     (‘magit-log-current’)

     現在のブランチのログを表示します。‘HEAD’が切り離されている
     (detached)か、前置引数が付いている場合、ミニバッファから読み取られ
     た1つ以上のrevのログを表示します。

‘l o’     (‘magit-log-other’)

     ミニバッファから読み取られた1つ以上のrevのログを表示します。ユーザ
     ーは、スペースまたは範囲で区切られた1つまたは複数のリビジョンを入力
     できますが、完了候補として使用できるのは、ブランチ、タグ、およびポ
     イントでのコミットの表現のみです。

‘l h’     (‘magit-log-head’)

     ‘HEAD’のログを表示します。

‘l L’     (‘magit-log-branches’)

     すべてのローカルブランチと‘HEAD’のログを表示します。

‘l b’     (‘magit-log-all-branches’)

     すべてのローカルブランチとリモートブランチと‘HEAD’のログを表示しま
     す。

‘l a’     (‘magit-log-all’)

     すべての参照(reference)と‘HEAD’のログを表示します。

現在のバッファでアクセスされているファイルまたはblobのログを表示する2つ
の追加コマンドが存在します→*note Commands for Buffers Visiting Files:: コ
マンド‘magit-cherry’もログを表示します→*note Cherries::

* Menu:

* Refreshing Logs::
* Log Buffer::
* Log Margin::
* Select from Log::
* Reflog::
* Cherries::


File: magit.ja.info,  Node: Refreshing Logs,  Next: Log Buffer,  Up: Logging

5.3.1 Refreshing Logs
---------------------

‘L’の一時前置コマンド‘magit-log-refresh’を使用すると、表示されるログを変
更せずに、現在のバッファで使用されているログ引数を変更できます。これは専
用のログバッファで機能しますが、ステータスバッファでも機能します。

‘L’     (‘magit-log-refresh’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

‘L g’     (‘magit-log-refresh’)

     この後置コマンドは、現在のバッファのローカルログ引数を設定します。

‘L s’     (‘magit-log-set-default-arguments’)

     この後置コマンドは、現在のバッファと同じタイプのバッファのデフォル
     トのログ引数を設定します。 同じタイプの他の既存のバッファは、ローカ
     ル値がすでに初期化されているため、影響を受けません。

‘L w’     (‘magit-log-save-default-arguments’)

     この後置コマンドは、現在のバッファと同じタイプのバッファのデフォル
     トのログ引数を設定し、将来のセッションのために値を保存します。 同じ
     タイプの他の既存のバッファは、ローカル値がすでに初期化されているた
     め、影響を受けません。

‘L t’     (‘magit-toggle-margin’)

     マージン(margin)を表示または非表示にします。


File: magit.ja.info,  Node: Log Buffer,  Next: Log Margin,  Prev: Refreshing Logs,  Up: Logging

5.3.2 Log Buffer
----------------

‘L’     (‘magit-log-refresh’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

     *note Refreshing Logs::

‘q’     (‘magit-log-bury-buffer’)

     現在のバッファまたはリビジョンバッファを同じフレームに埋め込み
     (bury)ます。‘magit-mode-bury-buffer’(を参照)と同様ですが、現在のフ
     レームに表示されている場合は、代わりに負の前置引数を使用してリビジ
     ョンバッファを埋め込みます。

‘C-c C-b’     (‘magit-go-backward’)

     現在のバッファの履歴を逆方向に移動します。

‘C-c C-f’     (‘magit-go-forward’)

     現在のバッファの履歴を順方向に進めます。

‘C-c C-n’     (‘magit-log-move-to-parent’)

     現在のコミットの親に移動します。デフォルトでは、これは最初の親です
     が、数値の接頭辞を使用して別の親を指定できます。

‘j’     (‘magit-log-move-to-revision’)

     リビジョンを読み取り、現在のログバッファでそのリビジョンに移動しま
     す。

     選択したreferenceまたはリビジョンが現在のログバッファに表示されてい
     ない場合は、そのことをユーザーに通知し、他に何もしません。

     ログバッファの外部で呼び出された場合は、最初に現在のリポジトリのロ
     グバッファを表示します。 必要に応じて作成します。

‘SPC’     (‘magit-diff-show-or-scroll-up’)

     ポイントしているモノのcommitまたはdiffバッファーを更新します。

     適切なバッファ内のポイントでコミットまたはスタッシュを表示するか、
     そのバッファが現在のフレームにすでに表示されていて、そのコミットま
     たはスタッシュに関する情報が含まれている場合は、代わりにバッファを
     上にスクロールします。ポイントにコミットまたはスタッシュがない場合
     は、コミットのプロンプトを表示します。

‘DEL’     (‘magit-diff-show-or-scroll-down’)

     ポイントしているモノのcommitまたはdiffバッファーを更新します。

     適切なバッファ内のポイントでコミットまたはスタッシュを表示するか、
     そのバッファが現在のフレームにすでに表示されていて、そのコミットま
     たはスタッシュに関する情報が含まれている場合は、代わりにバッファを
     下にスクロールします。ポイントにコミットまたはスタッシュがない場合
     は、コミットのプロンプトを表示します。

‘=’     (‘magit-log-toggle-commit-limit’)

     現在のログバッファで表示制限されているコミットの数を切り替えます。
     コミットの数が現在表示制限されている場合は、その制限を削除します。
     それ以外の場合は256に設定します。

‘+’     (‘magit-log-double-commit-limit’)

     現在のログバッファで表示制限されているコミット数を2倍に拡張します。

‘-’     (‘magit-log-half-commit-limit’)

     現在のログバッファのコミット数表示制限数を半分に狭めます。

 -- User Option: magit-log-auto-more

     最後のエントリを超えて移動すると、さらにログエントリが自動的に挿入
     されます。‘magit-goto-*-section’コマンドを使用して最後のエントリを
     通過する場合にのみ考慮されます。

 -- User Option: magit-log-show-refname-after-summary

     コミットの要約の後にrefnameを表示するかどうか。これは、あなたが非常
     に長いブランチ名を使用する場合に役立ちます。

Magitは、Gitの表示方法とは少し異なる方法でreferenceをログに表示します。

ローカルブランチは青で、リモートブランチは緑です。 もちろん、他の種類の
referenceに使用される色と同様に、使用するテーマによって異なります。 現在
のブランチは、それぞれのリモートの‘HEAD’ブランチであるリモートブランチと
同様に、枠で囲まれています。

ローカルブランチとそのプッシュターゲットポイントが同じコミットにある場合
、スペースを保持し、その関係を表示するために、それらの名前が組み合わされ
ます。 例えば:

     origin/feature
     [green][blue-]

     instead of

     feature origin/feature
     [blue-] [green-------]

また、一時コマンド(the transient)には‘--show-signature’引数がありますが
、Magitはデフォルトではコミットごとに1行しか使用しないため、有効にすると
実際には使用されないことに注意してください。代わりに、
‘magit-signature-*’という名前のface達を使用して、署名された(signed)コミ
ットオブジェクトの有効性を色分けして示します。各‘magit-signature-*’を参
照して下さい。

‘magit-log-margin’の説明については→*note Log Margin::


File: magit.ja.info,  Node: Log Margin,  Next: Select from Log,  Prev: Log Buffer,  Up: Logging

5.3.3 Log Margin
----------------

1つ以上のログを表示するバッファーでは、欄外(margin)内に各コミットに関す
る追加情報を表示することができます。欄外の構成に使用されるオプションの名
前は‘magit-INFIX-margin’です。ここで、INFIX(訳注:INFIX:インフィックス;中
置引数)はそれぞれのメジャーモード‘magit-INFIX-mode’と同じです。通常のロ
グバッファでは、‘magit-log-margin’になります。

 -- User Option: magit-log-margin

     このオプションは、欄外(margin)が最初にMagit-Logモードのバッファに表
     示されるかどうか、およびそのフォーマット方法を指定します。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、マージン(margin)が最初に表示されます。

        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。

        • WIDTHは、マージンの幅を制御します。これは上位互換性のために存
          在し、現在値を変更すべきではありません。

        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。

        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。

‘magit’がロードされる「前」に‘magit-log-margin’をカスタマイズすることで
、すべての‘magit-INFIX-margin’オプションのSTYLEとAUTHOR-WIDTHを同じ値に
変更できます。これを行うと、他のオプションのそれぞれの値は、デフォルトで
その変数に設定した値になります。同様に、‘magit-log-margin’のINITを
‘nil’に設定すると、それが他のすべてのオプションのデフォルトで使用されま
す。ただし、‘t’に設定する、つまりそのオプションのデフォルトを再適用して
も、他のオプションには適用されません。

 -- User Option: magit-log-margin-show-committer-date

     このオプションは、欄外(margin)にコミッターの日付を表示するかどうか
     を指定します。 このオプションは、作成者の日付の代わりにコミッターの
     日付を表示するかどうかのみを制御します。欄外に日付を表示するかどう
     か、および欄外を表示するかどうかは、他のオプションによって制御され
     ます。

‘L’     (‘magit-margin-settings’)

     この一時的な前置コマンドは、続く後置コマンドを結び付けます。各コマ
     ンドは、何らかの方法で欄外(margin)の外観を変更します。

欄外(margin)をサポートする一部のバッファでは、‘L’は代わりに
‘magit-log-refresh’に結び付けられますが、その一時コマンド(transient)は同
じコマンドを備え、それから他のいくつかの無関係なコマンドを備えています。

‘L L’     (‘magit-toggle-margin’)

     このコマンドは、欄外(margin)を表示または非表示にします。

‘L l’     (‘magit-cycle-margin-style’)

     このコマンドは、欄外(margin)に使用されるスタイルを循環させます。

‘L d’     (‘magit-toggle-margin-details’)

     このコマンドは、欄外(margin)の詳細を表示または非表示にします。


File: magit.ja.info,  Node: Select from Log,  Next: Reflog,  Prev: Log Margin,  Up: Logging

5.3.4 Select from Log
---------------------

ユーザーが‘HEAD’から到達可能な最近のコミットを選択する必要がある場合、通
常の補完を使用するのは不便です(ほとんどの人間は、少なくともダブルチェッ
クなしではハッシュまたは"HEAD~5"を覚えていないため)。代わりに、ログバッ
ファを使用してコミットを選択します。これには、コミットが順番にコミットメ
ッセージとともに表示されるという利点があります。

このような選択ログは、リベースの開始を選択するとき、およびsquashコミット
を選択するときに使用されます。

すべてのログバッファで使用可能なキーバインディングに加えて、以下の追加の
キーバインディングが選択ログバッファで使用できます:

‘C-c C-c’     (‘magit-log-select-pick’)

     ポイントでコミットを選択し、それに基づいて行動します。 選択したコミ
     ットを引数として‘magit-log-select-pick-function’を呼び出します。

‘C-c C-k’     (‘magit-log-select-quit’)

     コミットの選択を中止(abort)し、どのコミットに基づいて行動することも
     しません。

 -- User Option: magit-log-select-margin

     このオプションは、欄外(margin)が最初にMagit-Log-Selectモードのバッ
     ファに表示されるかどうか、およびそのフォーマット方法を指定します。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、マージン(margin)が最初に表示されます。

        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。

        • WIDTHは、マージンの幅を制御します。これは上位互換性のために存
          在し、現在値を変更すべきではありません。

        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。

        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。


File: magit.ja.info,  Node: Reflog,  Next: Cherries,  Prev: Select from Log,  Up: Logging

5.3.5 Reflog
------------

こちらもご覧下さい *note (gitman)git-reflog::

これらのreflogコマンドは、ログ一時コマンド(transient)ら使用できます
→*note Logging::

‘l r’     (‘magit-reflog-current’)

     現在のブランチのreflogを表示します。

‘l O’     (‘magit-reflog-other’)

     ブランチまたは別のrefのreflogを表示します。

‘l H’     (‘magit-reflog-head’)

     ‘HEAD’のreflogを表示します。

 -- User Option: magit-reflog-margin

     このオプションは、欄外(margin)が最初にMagit-Reflogモードのバッファ
     に表示されるかどうか、およびそのフォーマット方法を指定します。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、マージン(margin)が最初に表示されます。

        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。

        • WIDTHは、マージンの幅を制御します。これは上位互換性のために存
          在し、現在値を変更すべきではありません。

        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。

        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。


File: magit.ja.info,  Node: Cherries,  Prev: Reflog,  Up: Logging

5.3.6 Cherries
--------------

チェリー(cherry)は(まだ)アップストリームに適用されていないコミットであり
、通常はログを使用して視覚化されます。各コミットには、アップストリームに
同等のものがある場合は‘-’が接頭辞として付けられ、そうでない場合、つまり
チェリー(cherry)の場合は‘+’が接頭辞として付けられます。

コマンド‘magit-cherry’は、単一のブランチのチェリー(cherry)を表示しますが
、参照バッファ(*note References Buffer::)は、一度に複数の「アップストリ
ーム」のチェリー達を表示できます。

こちらもご覧下さい *note (gitman)git-reflog::

‘Y’     (‘magit-cherry’)

     特定のブランチにあるが、アップストリームブランチにマージされていな
     いコミットを表示します。

 -- User Option: magit-cherry-margin

     このオプションは、欄外(margin)が最初にMagit-Cherryモードのバッファ
     に表示されるかどうか、およびそのフォーマット方法を指定します。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、マージン(margin)が最初に表示されます。

        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。

        • WIDTHは、マージンの幅を制御します。これは上位互換性のために存
          在し、現在値を変更すべきではありません。

        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。

        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。


File: magit.ja.info,  Node: Diffing,  Next: Ediffing,  Prev: Logging,  Up: Inspecting

5.4 Diffing
===========

ステータスバッファには、ステージされたコミットとステージされていないコミ
ットの差分が含まれていますが、それだけでは明らかに不十分です。‘d’上の一
時プ前置コマンド‘magit-diff’は、個別のdiffバッファに特定のdiffを表示する
いくつかの後置コマンドを備えています。

他の一時的前置コマンドと同様に、‘magit-diff’も、後置コマンドの1つを呼び
出す前に変更できるいくつかの中置引数達を備えています。ただし、一時的
diff(diff transient)の場合、これらの引数は、
‘magit-prefix-use-buffer-arguments’の値に応じて、現在のリポジトリの
diffバッファで現在使用されている引数から取得される場合があります(*note
一時的引数とバッファ変数::)。

こちらもご覧下さい (*note (gitman)git-diff::)

‘d’     (‘magit-diff’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

‘d d’     (‘magit-diff-dwim’)

     その時点での変更を表示します。

‘d r’     (‘magit-diff-range’)

     2つのコミット間の違いを表示します。

     RANGEは範囲(A..B or A...B)である必要がありますが、単一のコミットに
     することもできます。範囲の片側を省略すると、デフォルトで‘HEAD’にな
     ります。コミットのみが指定された場合、そのコミットに関連する作業ツ
     リーの変更が表示されます。

     リージョンがアクティブな場合は、リージョンの最初と最後の行のリビジ
     ョンを使用します。前置引数を使用して、リビジョンを比較する代わりに
     、両方のリビジョンの共通の祖先から開始して、変更を表示するリビジョ
     ンを選択します(つまり、"..."の範囲を使用します)。

‘d w’     (‘magit-diff-working-tree’)

     現在の作業ツリーと‘HEAD’コミットの間の変更を表示します。前置引数を
     使用して、作業ツリーとミニバッファから読み取られたコミット間の変更
     を表示します。

‘d s’     (‘magit-diff-staged’)

     インデックスと‘HEAD’コミットの間の変更を表示します。前置引数を使用
     して、インデックスとミニバッファから読み取られたコミット間の変更を
     表示します。

‘d u’     (‘magit-diff-unstaged’)

     作業ツリーとインデックスの間の変更を表示します。

‘d p’     (‘magit-diff-paths’)

     ディスク上の任意の2つのファイル間の変更を表示します。

上記のすべての後置コマンドは、リポジトリのdiffバッファを更新します。
diff一時コマンド(transient)には、別のバッファの違いを示す2つのコマンドも
あります。

‘d c’     (‘magit-show-commit’)

     ポイントでコミットを表示します。ポイントにコミットがない場合、また
     は前置引数がある場合は、コミットのプロンプトを表示します。

‘d t’     (‘magit-stash-show’)

     バッファ内のstashのすべての差分を表示します。

現在のバッファでアクセスされているファイルまたはblobの差分を表示する2つ
の追加コマンドが存在します→*note Commands for Buffers Visiting Files::

* Menu:

* Refreshing Diffs::
* Commands Available in Diffs::
* Diff Options::
* Revision Buffer::


File: magit.ja.info,  Node: Refreshing Diffs,  Next: Commands Available in Diffs,  Up: Diffing

5.4.1 Refreshing Diffs
----------------------

‘D’の一時前置コマンド‘magit-diff-refresh’を使用すると、表示されるdiffを
変更せずに、現在のバッファで使用されているdiff引数を変更できます。これは
専用のdiffバッファで機能しますが、ステータスバッファでも機能します。

‘D’     (‘magit-diff-refresh’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

‘D g’     (‘magit-diff-refresh’)

     この後置コマンドは、現在のバッファのローカルdiff引数を設定します。

‘D s’     (‘magit-diff-set-default-arguments’)

     この後置コマンドは、現在のバッファと同じタイプのバッファのデフォル
     トのdiff引数を設定します。同じタイプの他の既存のバッファは、ローカ
     ル値がすでに初期化されているため、影響を受けません。

‘D w’     (‘magit-diff-save-default-arguments’)

     この後置コマンドは、現在のバッファと同じタイプのバッファのデフォル
     トのdiff引数を設定し、将来のセッションのために値を保存します。同じ
     タイプの他の既存のバッファは、ローカル値がすでに初期化されているた
     め、影響を受けません。

‘D t’     (‘magit-diff-toggle-refine-hunk’)

     このコマンドは、ハンクの絞り込みのオンとオフを切り替えます。

‘D r’     (‘magit-diff-switch-range-type’)

     このコマンドは、差分範囲タイプを"revA..revB"から"revB...revA"に、ま
     たはその逆に変換します。

‘D f’     (‘magit-diff-flip-revs’)

     このコマンドは、diff範囲のリビジョンを"revA..revB"から
     "revB..revA"に、またはその逆に交換します。

‘D F’     (‘magit-diff-toggle-file-filter’)

     このコマンドは、現在のバッファ内のdiffのファイル制限を切り替え、コ
     ミット内のすべての変更の表示と制限されたサブセットの表示をすばやく
     切り替えることができるようにします。特別な場合として、このコマンド
     がログバッファから呼び出されると、リポジトリのリビジョンバッファ内
     のファイル制限が切り替わります。これは、1つまたは複数のファイルに制
     限されているログバッファからリビジョンを表示する場合に役立ちます。

サポートされている引数のいずれかを変更できる上記の一時コマンド
(transient)に加えて、特定の引数のみを変更するコマンドもいくつか存在しま
す。

‘-’     (‘magit-diff-less-context’)

     このコマンドは、diffハンクのコンテキスト(the context)をCOUNT行ずつ
     減らします。

‘+’     (‘magit-diff-more-context’)

     このコマンドは、diffハンクのコンテキスト(the context)をCOUNT行増や
     します。

‘0’     (‘magit-diff-default-context’)

     このコマンドは、diffハンクのコンテキスト(the context)をデフォルトの
     行数にリセットします。

次のコマンドは、diff一時コマンド(transient)のいずれも使用せずに、表示さ
れているdiffをすばやく変更します。

‘C-c C-d’     (‘magit-diff-while-committing’)

     コミット中、このコマンドはコミットされようとしている変更を表示しま
     す。修正中にコマンドを再度呼び出すと、新しい変更のみを表示するか、
     コミットされるすべての変更を表示するかが切り替わります。

     このキーバインドは、diffバッファとcommitメッセージバッファで使用で
     きます。

‘C-c C-b’     (‘magit-go-backward’)

     このコマンドは、現在のバッファの履歴を逆方向に移動します。

‘C-c C-f’     (‘magit-go-forward’)

     このコマンドは、現在のバッファーの履歴を順方向に進めます。


File: magit.ja.info,  Node: Commands Available in Diffs,  Next: Diff Options,  Prev: Refreshing Diffs,  Up: Diffing

5.4.2 Commands Available in Diffs
---------------------------------

一部のコマンドは、ポイントがdiff内にある場合にのみ使用できます。

‘magit-diff-visit-file’および関連するコマンドは、その時点でのdiffが含ま
れているファイルの適切なバージョンにアクセスします。 同様に、
‘magit-diff-visit-worktree-file’および関連するコマンドは、その時点での
diffが含まれているファイルのワークツリーバージョンにアクセスします。詳細
とキーバインディングについては→*note Visiting Files and Blobs from a
Diff::

‘C-c C-t’     (‘magit-diff-trace-definition’)

     このコマンドは、ポイントでの定義(the definition)のログを表示します
     。

 -- User Option: magit-log-trace-definition-function

     このオプションで指定された関数は、‘magit-log-trace-definition’によ
     って使用され、ポイントでの関数を決定します。特別なニーズがあるメジ
     ャーモードの場合、モードのフックを使用してローカル値を設定できます
     。

‘C-c C-e’     (‘magit-diff-edit-hunk-commit’)

     このコマンドは、ハンクからそれぞれのコミットを編集し、ファイルにア
     クセスします。

     まず、‘magit-diff-visit-file’を使用して、ハンクによって正しい場所で
     変更されているファイルにアクセスします。これは実際にblobを訪問しま
     す。ポイントが個々のハンク内ではなくdiffヘッダー上にある場合、これ
     は最初のハンクが存在するblobにアクセスします。

     次に‘magit-edit-line-commit’を呼び出し、‘HEAD’からそのコミットを直
     接チェックチェックアウトすることで到達することは不可能な、インタラ
     クティブなリベースを使用してコミットを編集可能にし、これにより実際
     の作業ツリーのファイルにもアクセスできます。

     リベースの終了時に、blobもファイルバッファも強制終了(kill)されませ
     ん。それが望ましくない場合は、このコマンドの代わりに
     ‘magit-rebase-edit-command’を使用する方がよい場合があります。

‘j’     (‘magit-jump-to-diffstat-or-diff’)

     このコマンドは、diffstatまたはdiffにジャンプします。ポイントが
     diffstatセクション内のファイル上にある場合は、それぞれのdiffセクシ
     ョンにジャンプします。 それ以外の場合は、diffstatセクションまたはそ
     の子にジャンプします。

次の2つのコマンドは、Magit-Diffモード(または、さらに言えばMagitバッファ
)に固有のものではありませんが、ここでも使用できることを指摘しておく価値
があります。

‘SPC’     (‘scroll-up’)

     このコマンドは、テキストを上にスクロールします。

‘DEL’     (‘scroll-down’)

     このコマンドは、テキストを下にスクロールします。


File: magit.ja.info,  Node: Diff Options,  Next: Revision Buffer,  Prev: Commands Available in Diffs,  Up: Diffing

5.4.3 Diff Options
------------------

 -- User Option: magit-diff-refine-hunk

     diffハンク内で単語の粒度(word-granularity)のdiffを表示するかどうか
     。

        • ‘nil’ 細かい違いを表示しないでください。

        • ‘t’ 現在のdiffハンクのみの細かい違いを表示します。

        • ‘all’ 表示されているすべてのdiffハンクの細かい違いを表示します
          。

 -- User Option: magit-diff-refine-ignore-whitespace

     単語の粒度(word-granularity)の違いにおける空白の変更を無視するかど
     うか。

 -- User Option: magit-diff-adjust-tab-width

     diffでタブの幅を調整するかどうか。

     大きなファイルや多数のファイルを開く必要がある場合、正しい幅を決定
     するのはコストがかかる可能性があるため、幅は変数
     ‘magit-diff--tab-width-cache’にキャッシュされます。キャッシュを無効
     にするには、これをnilに設定します。

        • ‘nil’ タブ幅は調整しません。代わりに、Magitバッファ自体の
          ‘tab-width’の値を使います。

        • ‘t’ 対応するfile-visitingバッファが存在する場合は、そのバッフ
          ァの‘tab-width’の値を使用します。これを行うのは安価であるため
          、対応するキャッシュエントリが存在する場合でも、この値が使用さ
          れます。

        • ‘always’ そのようなバッファがない場合は、一時的(temporarily)に
          ファイルにアクセスして値を決定します。

        • NUMBER ‘always’と同様ですが、NUMBERバイトより大きいファイルに
          はアクセスしないでください。

 -- User Option: magit-diff-paint-whitespace

     空白エラー達を強調表示(highlight)する場所を指定します。

     ‘magit-diff-highlight-trailing’、
     ‘magit-diff-highlight-indentation’を参照してください。 シンボル
     ‘t’はすべての差分を意味し、‘status’はステータスバッファ内のみを意味
     し、nilはどこにも存在しないことを意味します。

        • ‘nil’ 空白エラーを強調表示(highlight)しません。

        • ‘t’ どこでも空白エラーを強調表示(highlight)します。

        • ‘uncommitted’ コミットされていない変更を示すdiff達の空白エラー
          のみを強調表示(highlight)します。下位互換性のために、
          ‘status’は同義語として扱われます。

 -- User Option: magit-diff-paint-whitespace-lines

     空白エラーを強調表示(highlight)する行の種類(kind of lines)を指定し
     ます。

        • ‘t’ 追加された行でのみ強調表示(highlight)します。

        • ‘both’ 追加および削除された行を強調表示(highlight)します。

        • ‘all’ 追加、削除、およびコンテキスト行で強調表示(highlight)し
          ます。

 -- User Option: magit-diff-highlight-trailing

     diff達の行末の空白を強調表示するかどうか。
     ‘magit-diff-paint-whitespace’がnil以外の場合にのみ使用されます。

 -- User Option: magit-diff-highlight-indentation

     このオプションは、「間違った」インデントスタイルを使用した場合にイ
     ンデントを強調表示(highlight)するかどうかを制御します。インデントは
     、‘magit-diff-paint-whitespace’もnil以外の場合にのみ強調表示されま
     す。

     値は、‘((REGEXP . INDENT)...)’の形式のalistです。現在のリポジトリへ
     のパスは、逆の順序で各要素と照合されます。したがって、REGEXPが一致
     する場合、以前の要素は試行されません。

     使用するインデントが‘tabs’の場合は、タブでインデントを強調表示
     (highlight)します。INDENTが整数の場合は、少なくともその数のスペース
     でインデントを強調表示します。それ以外の場合は、どちらも強調表示し
     ません。

 -- User Option: magit-diff-hide-trailing-cr-characters

     diff達の行末の ^M 文字を非表示にするかどうか。

 -- User Option: magit-diff-highlight-hunk-region-functions

     このオプションは、ハンク内部regionを強調表示(highlight)するために使
     用される関数を指定します。

     ‘magit-diff-highlight-hunk-region-dim-outside’は、ハンクの内部選択
     範囲(hunk internal selection)の外側に、追加および削除された行の背景
     色をコンテキスト行と同じにするfaceをオーバーレイします。この関数は
     、このオプションの値から削除すべきではありません。

     ‘magit-diff-highlight-hunk-region-using-overlays’と
     ‘magit-diff-highlight-hunk-region-using-underline’は、前後に区切り
     の水平線を配置することで、regionを強調します。これらの機能には両方
     とも、Emacsのディスプレイエンジンの制限のために修正できない欠陥
     (glitches)があります。詳細については
     →<https://github.com/magit/magit/issues/2758> ff

     境界線を強調する代わりに、またはそれに加えて、境界を強調するために
     、‘magit-diff-highlight-hunk-region-using-face’を使用して、テキスト
     自体を強調することができます。

     ターミナルフレームでは、オーバーレイとアンダーラインのバリエーショ
     ンが通常行うように線を描画することはできないため、代わりにface関数
     の呼び出しにフォールバックします。

 -- User Option: magit-diff-unmarked-lines-keep-foreground

     このオプションは、ハンク内部(hunk-internal)regionの外側に追加および
     削除された線が、明確な背景色のみを失うか、前景色も失うかを制御しま
     す。 領域の外側が暗くなるかどうかは、
     ‘magit-diff-highlight-hunk-region-functions’によって異なります。

 -- User Option: magit-diff-extra-stat-arguments

     このオプションは、‘--stat’と一緒に使用される追加の引数を指定します
     。

     値は、0個以上の引数のリスト、または引数をとらずにそのようなリストを
     返す関数です。一緒に使ってよい引数は‘--stat-width’と
     ‘--stat-name-width’と‘--stat-graph-width’と‘--compact-summary’です
     。こちらもご覧ください (*note (gitman)git-diff::)


File: magit.ja.info,  Node: Revision Buffer,  Prev: Diff Options,  Up: Diffing

5.4.4 Revision Buffer
---------------------

 -- User Option: magit-revision-insert-related-refs

     関連するブランチをリビジョンバッファに表示するかどうか。

        • ‘nil’ 関連するブランチを表示しません。

        • ‘t’ 関連するローカルブランチを表示します。

        • ‘all’ 関連するローカルブランチとリモートブランチを表示します。

        • ‘mixed’ 含まれているすべてのブランチとローカルのマージされたブ
          ランチを表示します。

 -- User Option: magit-revision-show-gravatars

     リビジョンバッファにGravatar画像を表示するかどうか。

     ‘nil’の場合はGravatar画像を挿入しません。‘t’の場合は両方の画像を挿
     入します。‘author’または‘committer’の場合は、それぞれの画像のみを挿
     入します。

     あなたがオプション‘magit-revision-headers-format’をカスタマイズして
     いて、画像を挿入したい場合は、どこに挿入するかも指定する必要があり
     ます。その場合、値は2つの正規表現のコンスセルである必要があります。
     carは、作者の画像を挿入する場所を指定します。画像の上半分は一致した
     テキストの直後に挿入され、下半分は同じ列の次の行に挿入されます。
     cdrは、それに応じてコミッターのイメージを挿入する場所を指定します。
     carかcdrのどちらかがnilかもしれません。

 -- User Option: magit-revision-use-hash-sections

     コミットメッセージ内のハッシュをセクションに変換するかどうか。

     nil以外の場合、コミットメッセージ内のハッシュは‘commit’セクションに
     変換されます。パフォーマンスと信頼性の間にはトレードオフがあります
     。

        • ‘slow’ 確実にすべての単語に対してgitを呼び出します。

        • ‘quick’ 7文字未満の単語をスキップします。

        • ‘quicker’ さらに、数字を含まない単語をスキップします。

        • ‘quickest’ 7文字以上の長さでかつ、1つ以上の数字かつ、1つ以上文
          字を含むすべての単語を使用します。

     nilの場合、ハッシュはセクションに変換されませんが、「RET」を使用し
     てその時点でコミットにアクセスできます。

リビジョンバッファに表示されるdiff達は、変更されたファイルのサブセットに
自動的に制限される場合があります。リビジョンバッファがログバッファから表
示される場合、リビジョンバッファは、そのログバッファと同じファイル制限を
共有します(コマンド‘magit-diff-toggle-file-filter’も参照してください)。

 -- User Option: magit-revision-filter-files-on-follow

     ログ引数に‘--follow’が含まれている場合に、ログバッファからのコミッ
     トを表示するかどうかは、ログのファイルフィルターを尊重します。

     このオプションがnilの場合、ログ引数に‘--follow’が含まれていると、ロ
     グからのコミットの表示はログのファイルフィルターを無視します。そう
     することで、名前変更イベントの前にコミット用のリビジョンバッファに
     空のdiffが表示されないようにします。このような場合、ログ一時コマン
     ド(transient)の‘--patch’引数を使用して、ファイル制限されたdiff達を
     インラインで表示できます。

     ‘--follow’がログ引数に存在する場合でもログのファイル制限を維持する
     には、このオプションを非nilに設定します。

リビジョンバッファがログバッファから表示されない場合、ファイル制限は通常
どおりに決定されます(*note 一時的引数とバッファ変数::)。


File: magit.ja.info,  Node: Ediffing,  Next: References Buffer,  Prev: Diffing,  Up: Inspecting

5.5 Ediffing
============

このセクションでは、MagitバッファからEdiffを入力する方法について説明しま
す。 Ediff自体の使用方法については→*note (ediff)Top::

‘e’     (‘magit-ediff-dwim’)

     Ediffを使用して比較(compare)またはステージ(stage)または解決
     (resolve)します。

     このコマンドは、Ediffを使用して、ユーザーが比較(compare)またはステ
     ージ(stage)または解決(resolve)したいファイルと、コミットまたは範囲
     (range)を推測しようとします。ファイルまたは範囲(range)/コミットのい
     ずれかを推測することしかできない場合があります。その場合、ユーザー
     はもう一方について尋ねられます。常に正しく推測できるとは限りません
     。その場合、適切な‘magit-ediff-*’コマンドを明示的に使用する必要があ
     ります。Magitがユーザーの心をまったく読み取れない場合は、実行するコ
     マンドをユーザーに要求します。

‘E’     (‘magit-ediff’)

     この一時的(transient)前置(prefix)コマンドは、それに続く後置
     (suffix)コマンドを結びつけ、後置(suffix)コマンドが呼び出されるまで
     一時バッファ(temporary buffer)に表示します。

‘E r’     (‘magit-ediff-compare’)

     Ediffを使用してファイルの2つのリビジョンを比較します。

     リージョンがアクティブな場合は、リージョンの最初と最後の行のリビジ
     ョンを使用します。前置引数を使用して、リビジョンを比較する代わりに
     、両方のリビジョンの共通の祖先から開始して、変更を表示するリビジョ
     ンを選択します(つまり、"..."の範囲を使用します)。

‘E m’     (‘magit-ediff-resolve’)

     Ediffを使用して、ファイル内の未解決の競合を解決します。デフォルトで
     は、ポイントの指すファイルになります。

     ‘merge.conflictstyle’の値が‘diff3’の場合、Ediff制御バッファで‘/’を
     使用してファイルのマージベースリビジョン(merge-base revision)を表示
     できます。

     まれに、Gitによって既に解決されているものを含め、あなたが、すべての
     競合を手動で解決したい場合は、
     ‘ediff-merge-revisions-with-ancestor’を使用してください。

‘E s’     (‘magit-ediff-stage’)

     Ediffを使用してファイルへの変更をステージ(stage)およびステージ解除
     (unstage)します。デフォルトではそのポイントのファイルを対象にします
     。

‘E u’     (‘magit-ediff-show-unstaged’)

     Ediffを使用して、ファイルへのステージされていない変更(unstaged
     changes)を表示します。

‘E i’     (‘magit-ediff-show-staged’)

     Ediffを使用してファイルのステージされた変更(staged changes)を表示し
     ます。

‘E w’     (‘magit-ediff-show-working-tree’)

     Ediffを使用して、‘HEAD’と作業ツリーの間のファイルの変更を表示します
     。

‘E c’     (‘magit-ediff-show-commit’)

     Ediffを使用したコミットによって導入されたファイル(file introduced)へ
     の変更を表示します。

‘E z’     (‘magit-ediff-show-stash’)

     Ediffを使用してstashによって導入されたファイルへの変更を表示します
     。

 -- User Option: magit-ediff-dwim-show-on-hunks

     このオプションは、ポイントがコミットされていないハンク上にあるとき
     に‘magit-ediff-dwim’が呼び出すコマンドを制御します。nilの場合、常に
     ‘magit-ediff-stage’を実行します。それ以外の場合は、
     ‘magit-ediff-show-staged’と‘magit-ediff-show-unstaged’を使用して、
     それぞれステージされた変更(staged changes)とステージされていない変
     更(unstaged changes)を表示します。

 -- User Option: magit-ediff-show-stash-with-index

     このオプションは、‘magit-ediff-show-stash’にスタッシュが作成された
     ときのインデックス内のファイルの状態を含むバッファを含めるかどうか
     を制御します。 これにより、スタッシュのどの変更がステージ(stage)さ
     れたかを知ることができます。

 -- User Option: magit-ediff-quit-hook

     このフックは、Magitコマンドを使用して作成されたEdiffセッションを終
     了した後に実行されます。フック関数はEdiff制御バッファ内で実行され、
     現在のバッファを変更すべきではありません。

     これは‘ediff-quit-hook’に似ていますが、Magitのニーズを考慮に入れて
     います。通常の‘ediff-quit-hook’は、Magitコマンドを使用して作成され
     たEdiffセッションでは無視されます。


File: magit.ja.info,  Node: References Buffer,  Next: Bisecting,  Prev: Ediffing,  Up: Inspecting

5.6 References Buffer
=====================

‘y’     (‘magit-show-refs’)

     このコマンドは、専用バッファ内のブランチとタグを一覧表示します。

     けれども、このコマンドがこのバッファから再度呼び出された場合、また
     は前置引数を指定して呼び出された場合は、一時的な前置コマンドとして
     機能し、次の後置コマンドといくつかの後置引数を結び付けます。

続くすべての後置コマンドは、まったく同じブランチとタグを一覧表示します。
唯一の違いは、‘magit-refs-show-commit-count’の値を変更することで有効にで
きるオプション機能です(以下を参照)。これらのコマンドは、他のすべての
referencesが比較される別のブランチまたはコミットを指定します。

‘y y’     (‘magit-show-refs-head’)

     このコマンドは、専用バッファ内のブランチとタグを一覧表示します。各
     referenceは‘HEAD’と比較されています。

‘y c’     (‘magit-show-refs-current’)

     このコマンドは、専用バッファ内のブランチとタグを一覧表示します。各
     referenceは、現在のブランチまたはdetachされている場合は‘HEAD’と比較
     されます。

‘y o’     (‘magit-show-refs-other’)

     このコマンドは、専用バッファ内のブランチとタグを一覧表示します。各
     referenceは、ユーザーから読み取られたブランチと比較されています。

 -- User Option: magit-refs-show-commit-count

     Magit-Refsモードのバッファでコミット数を表示するかどうか。

        • ‘all’ ブランチとタグのカウントを表示します。

        • ‘branch’ ブランチのカウントのみを表示します。

        • ‘nil’ カウントを表示しません。

     デフォルトは‘nil’です。他のものは非常に重い処理になる可能性があるた
     めです。

 -- User Option: magit-refs-pad-commit-counts

     Magit-Refsモードバッファのすべての脇(side)ですべてのコミットカウン
     トをパディングするかどうか。

     これがnilの場合、一部のコミットカウントは、カウントの横に表示される
     ブランチの1つのすぐ隣に、間にスペースを入れずに表示されます。ブラン
     チ名のfaceが‘magit-dimmed’に似すぎている場合、これは見栄えが悪い可
     能性があります。

     これがnil以外の場合、スペースがすべてのコミットカウントの両側に配置
     されます。

 -- User Option: magit-refs-show-remote-prefix

     リモートブランチのリストにremote prefixを表示するかどうか。

     リモートの名前はそのブランチのリストの前の見出しにすでに表示されて
     いるため、prefixの表示は冗長です。

 -- User Option: magit-refs-primary-column-width

     ‘magit-refs-mode’バッファのprimary列の幅。primary列は、現在の行が含
     まれているブランチの名前を含む列です。

     これが整数の場合、列の幅がその整数になります。それ以外の場合は、2つ
     の整数のコンスセルである必要があります。 1つ目は最小幅を指定し、2つ
     目は最大幅を指定します。その場合、実際の幅は、表示されているローカ
     ルブランチの名前の長さを使用して決定されます。(最適な幅に計算する場
     合、リモートブランチとタグは考慮されません。)

 -- User Option: magit-refs-focus-column-width

     ‘magit-refs-mode’バッファのfocus列の幅。

     focus列は最初の列であり、‘*’または‘@’を使用して、1つのブランチ(通常
     は現在のブランチ)をフォーカスされたブランチとしてマークします。他の
     referenceごとに、このfocus列はオプションで、フォーカスされたブラン
     チと‘<’の前にあるコミットの数を示します。前にない場合は、後ろにある
     コミットと‘>’を示します。前にも後ろにも無い場合は‘=’です。

     この列には、フォーカスされたブランチの‘*’または‘@’のみが表示される
     場合もあります。その場合、このオプションは無視されます。‘L v’を使用
     して、この列の詳細度を変更します。

 -- User Option: magit-refs-margin

     このオプションは、欄外(margin)が最初にMagit-Refsモードのバッファに
     表示されるかどうか、およびそのフォーマット方法を指定します。

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、マージン(margin)が最初に表示されます。

        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。

        • WIDTHは、マージンの幅を制御します。これは上位互換性のために存
          在し、現在値を変更すべきではありません。

        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。

        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。

 -- User Option: magit-refs-margin-for-tags

     このオプションは、欄外(margin)にタグに関する情報を表示するかどうか
     を指定します。タグが多いと遅いため、デフォルトでは無効になっていま
     す。

以下の変数は、個々のrefsの表示方法を制御します。これらの変数の1つ(特に
"%c"の部分)を変更する場合は、他の変数も変更して、調整を維持する必要があ
ります。以下の%シーケンスがサポートされています:

   • ‘%a’ このrefが比較したコミットを超えるコミットの数。

   • ‘%b’ 比較するrefのコミット数がこれを超えています。

   • ‘%c’ このrefが比較したコミットを超えるコミットの数。他のすべての
     refが比較されるrefの場合、これは、現在のブランチの場合は代わりに
     "@"、それ以外の場合は"#"になります。

   • ‘%C’ 他のすべてのrefが比較されるrefの場合、これは現在のブランチの場
     合は"@"、それ以外の場合は"#"です。 他のすべての参照は" "です。

   • ‘%h’ このrefのtipのハッシュ。

   • ‘%m’ このrefのtipの要約をコミットします。

   • ‘%n’ このrefの名前。

   • ‘%u’ このローカルブランチのupstream。

   • ‘%U’ このローカルブランチのアップストリームおよび追加のローカル情報
     とアップストリーム情報。

 -- User Option: magit-refs-filter-alist

     このオプションの目的は、名前に基づいて特定のrefを表示しないようにす
     ることです。特定のタイプのrefを表示したくない場合は、代わりに
     ‘magit-refs-sections-hook’から適切な関数を削除する必要があります。

     このalistは、‘magit-refs-mode’バッファに表示されないようにするタグ
     とブランチを制御します。‘nil’の場合、すべてのrefが表示されます
     (‘magit-refs-sections-hook’に従います)。

     1つが一致するまで、すべてのキーが順番に試行されます。 次に、その値
     が使用され、後続の要素は無視されます。値がnil以外の場合はその
     referenceが表示され、そうでない場合は表示されません。 一致する要素
     がない場合は、そのreferenceが表示されます。

     キーは、refnameが一致する必要のある正規表現、またはrefnameを引数と
     してのみ受け取り、ブール値を返す関数のいずれかです。
     "origin/master"などのリモートブランチは単に"master"として表示されま
     すが、この比較では前者が使用されます。

‘RET’     (‘magit-visit-ref’)

     このコマンドは、別のバッファ内のポイントで参照またはリビジョンにア
     クセスします。ポイントにリビジョンがない場合、または前置引数がある
     場合は、リビジョンの入力を求められます。

     This command behaves just like ‘magit-show-commit’ as described
     above, except if point is on a reference in a ‘magit-refs-mode’
     buffer, in which case the behavior may be different, but only if
     you have customized the option ‘magit-visit-ref-behavior’.

 -- User Option: magit-visit-ref-behavior

     This option controls how ‘magit-visit-ref’ behaves in
     ‘magit-refs-mode’ buffers.

     By default ‘magit-visit-ref’ behaves like ‘magit-show-commit’, in
     all buffers, including ‘magit-refs-mode’ buffers.  When the type of
     the section at point is ‘commit’ then "RET" is bound to
     ‘magit-show-commit’, and when the type is either ‘branch’ or ‘tag’
     then it is bound to ‘magit-visit-ref’.

     "RET" is one of Magit’s most essential keys and at least by default
     it should behave consistently across all of Magit, especially
     because users quickly learn that it does something very harmless;
     it shows more information about the thing at point in another
     buffer.

     However "RET" used to behave differently in ‘magit-refs-mode’
     buffers, doing surprising things, some of which cannot really be
     described as "visit this thing".  If you’ve grown accustomed this
     behavior, you can restore it by adding one or more of the below
     symbols to the value of this option.  But keep in mind that by
     doing so you don’t only introduce inconsistencies, you also lose
     some functionality and might have to resort to ‘M-x
     magit-show-commit’ to get it back.

     ‘magit-visit-ref’ looks for these symbols in the order in which
     they are described here.  If the presence of a symbol applies to
     the current situation, then the symbols that follow do not affect
     the outcome.

        • ‘focus-on-ref’

          With a prefix argument update the buffer to show commit counts
          and lists of cherry commits relative to the reference at point
          instead of relative to the current buffer or ‘HEAD’.

          Instead of adding this symbol, consider pressing "C-u y o
          RET".

        • ‘create-branch’

          If point is on a remote branch, then create a new local branch
          with the same name, use the remote branch as its upstream, and
          then check out the local branch.

          Instead of adding this symbol, consider pressing "b c RET
          RET", like you would do in other buffers.

        • ‘checkout-any’

          Check out the reference at point.  If that reference is a tag
          or a remote branch, then this results in a detached ‘HEAD’.

          Instead of adding this symbol, consider pressing "b b RET",
          like you would do in other buffers.

        • ‘checkout-branch’

          Check out the local branch at point.

          Instead of adding this symbol, consider pressing "b b RET",
          like you would do in other buffers.

* Menu:

* References Sections::


File: magit.ja.info,  Node: References Sections,  Up: References Buffer

5.6.1 References Sections
-------------------------

The contents of references buffers is controlled using the hook
‘magit-refs-sections-hook’.  See *note Section Hooks:: to learn about
such hooks and how to customize them.  All of the below functions are
members of the default value.  Note that it makes much less sense to
customize this hook than it does for the respective hook used for the
status buffer.

 -- User Option: magit-refs-sections-hook

     Hook run to insert sections into a references buffer.

 -- Function: magit-insert-local-branches

     Insert sections showing all local branches.

 -- Function: magit-insert-remote-branches

     Insert sections showing all remote-tracking branches.

 -- Function: magit-insert-tags

     Insert sections showing all tags.


File: magit.ja.info,  Node: Bisecting,  Next: Visiting Files and Blobs,  Prev: References Buffer,  Up: Inspecting

5.7 Bisecting
=============

こちらもご覧下さい *note (gitman)git-bisect::.

‘B’     (‘magit-bisect’)

     この一時的(transient)前置(prefix)コマンドは、それに続く後置
     (suffix)コマンドを結びつけ、後置(suffix)コマンドが呼び出されるまで
     一時バッファ(temporary buffer)に表示します。

When bisecting is not in progress, then the transient features the
following suffix commands.

‘B B’     (‘magit-bisect-start’)

     Start a bisect session.

     Bisecting a bug means to find the commit that introduced it.  This
     command starts such a bisect session by asking for a known good
     commit and a known bad commit.  If you’re bisecting a change that
     isn’t a regression, you can select alternate terms that are
     conceptually more fitting than "bad" and "good", but the infix
     arguments to do so are disabled by default.

‘B s’     (‘magit-bisect-run’)

     Bisect automatically by running commands after each step.

When bisecting in progress, then the transient instead features the
following suffix commands.

‘B b’     (‘magit-bisect-bad’)

     Mark the current commit as bad.  Use this after you have asserted
     that the commit does contain the bug in question.

‘B g’     (‘magit-bisect-good’)

     Mark the current commit as good.  Use this after you have asserted
     that the commit does not contain the bug in question.

‘B m’     (‘magit-bisect-mark’)

     Mark the current commit with one of the bisect terms.  This command
     provides an alternative to ‘magit-bisect-bad’ and
     ‘magit-bisect-good’ and is useful when using terms other than "bad"
     and "good".  This suffix is disabled by default.

‘B k’     (‘magit-bisect-skip’)

     Skip the current commit.  Use this if for some reason the current
     commit is not a good one to test.  This command lets Git choose a
     different one.

‘B r’     (‘magit-bisect-reset’)

     After bisecting, cleanup bisection state and return to original
     ‘HEAD’.

By default the status buffer shows information about the ongoing bisect
session.

 -- User Option: magit-bisect-show-graph

     This option controls whether a graph is displayed for the log of
     commits that still have to be bisected.


File: magit.ja.info,  Node: Visiting Files and Blobs,  Next: Blaming,  Prev: Bisecting,  Up: Inspecting

5.8 Visiting Files and Blobs
============================

Magit provides several commands that visit a file or blob (the version
of a file that is stored in a certain commit).  Actually it provides
several *groups* of such commands and the several *variants* within each
group.

* Menu:

* General-Purpose Visit Commands::
* Visiting Files and Blobs from a Diff::


File: magit.ja.info,  Node: General-Purpose Visit Commands,  Next: Visiting Files and Blobs from a Diff,  Up: Visiting Files and Blobs

5.8.1 General-Purpose Visit Commands
------------------------------------

These commands can be used anywhere to open any blob.  Currently no keys
are bound to these commands by default, but that is likely to change.

 -- Command: magit-find-file

     This command reads a filename and revision from the user and visits
     the respective blob in a buffer.  The buffer is displayed in the
     selected window.

 -- Command: magit-find-file-other-window

     This command reads a filename and revision from the user and visits
     the respective blob in a buffer.  The buffer is displayed in
     another window.

 -- Command: magit-find-file-other-frame

     This command reads a filename and revision from the user and visits
     the respective blob in a buffer.  The buffer is displayed in
     another frame.


File: magit.ja.info,  Node: Visiting Files and Blobs from a Diff,  Prev: General-Purpose Visit Commands,  Up: Visiting Files and Blobs

5.8.2 Visiting Files and Blobs from a Diff
------------------------------------------

These commands can only be used when point is inside a diff.

‘RET’     (‘magit-diff-visit-file’)

     This command visits the appropriate version of the file that the
     diff at point is about.

     This commands visits the worktree version of the appropriate file.
     The location of point inside the diff determines which file is
     being visited.  The visited version depends on what changes the
     diff is about.

        • If the diff shows uncommitted changes (i.e.  staged or
          unstaged changes), then visit the file in the working tree
          (i.e.  the same "real" file that ‘find-file’ would visit.  In
          all other cases visit a "blob" (i.e.  the version of a file as
          stored in some commit).

        • If point is on a removed line, then visit the blob for the
          first parent of the commit that removed that line, i.e.  the
          last commit where that line still exists.

        • If point is on an added or context line, then visit the blob
          that adds that line, or if the diff shows from more than a
          single commit, then visit the blob from the last of these
          commits.

     In the file-visiting buffer this command goes to the line that
     corresponds to the line that point is on in the diff.

     The buffer is displayed in the selected window.  With a prefix
     argument the buffer is displayed in another window instead.

 -- User Option: magit-diff-visit-previous-blob

     This option controls whether ‘magit-diff-visit-file’ may visit the
     previous blob.  When this is ‘t’ (the default) and point is on a
     removed line in a diff for a committed change, then
     ‘magit-diff-visit-file’ visits the blob from the last revision
     which still had that line.

     Currently this is only supported for committed changes, for staged
     and unstaged changes ‘magit-diff-visit-file’ always visits the file
     in the working tree.

‘C-<return>’     (‘magit-diff-visit-file-worktree’)

     This command visits the worktree version of the appropriate file.
     The location of point inside the diff determines which file is
     being visited.  Unlike ‘magit-diff-visit-file’ it always visits the
     "real" file in the working tree, i.e the "current version" of the
     file.

     In the file-visiting buffer this command goes to the line that
     corresponds to the line that point is on in the diff.  Lines that
     were added or removed in the working tree, the index and other
     commits in between are automatically accounted for.

     The buffer is displayed in the selected window.  With a prefix
     argument the buffer is displayed in another window instead.

Variants of the above two commands exist that instead visit the file in
another window or in another frame.  If you prefer such behavior, then
you may want to change the above key bindings, but note that the above
commands also use another window when invoked with a prefix argument.

 -- Command: magit-diff-visit-file-other-window
 -- Command: magit-diff-visit-file-other-frame
 -- Command: magit-diff-visit-worktree-file-other-window
 -- Command: magit-diff-visit-worktree-file-other-frame


File: magit.ja.info,  Node: Blaming,  Prev: Visiting Files and Blobs,  Up: Inspecting

5.9 Blaming
===========

こちらもご覧下さい *note (gitman)git-blame::.

To start blaming invoke the ‘magit-file-dispatch’ transient prefix
command by pressing ‘C-c M-g’.

The blaming suffix commands can be invoked from the dispatch transient.
However if you want to set an infix argument, then you have to enter the
blaming sub-transient first.

The key bindings shown below assume that you enter the dispatch
transient using the default binding.

‘C-c M-g B’     (‘magit-blame’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

Note that not all of the following suffixes are available at all times.
For example if ‘magit-blame-mode’ is not enabled, then the command whose
purpose is to turn off that mode would not be of any use and therefore
isn’t available.

‘C-c M-g b’     (‘magit-blame-addition’)
‘C-c M-g B b’     (‘magit-blame-addition’)

     This command augments each line or chunk of lines in the current
     file-visiting or blob-visiting buffer with information about what
     commits last touched these lines.

     If the buffer visits a revision of that file, then history up to
     that revision is considered.  Otherwise, the file’s full history is
     considered, including uncommitted changes.

     If Magit-Blame mode is already turned on in the current buffer then
     blaming is done recursively, by visiting REVISION:FILE (using
     ‘magit-find-file’), where REVISION is a parent of the revision that
     added the current line or chunk of lines.

‘C-c M-g r’     (‘magit-blame-removal’)
‘C-c M-g B r’     (‘magit-blame-removal’)

     This command augments each line or chunk of lines in the current
     blob-visiting buffer with information about the revision that
     removes it.  It cannot be used in file-visiting buffers.

     Like ‘magit-blame-addition’, this command can be used recursively.

‘C-c M-g f’     (‘magit-blame-reverse’)
‘C-c M-g B f’     (‘magit-blame-reverse’)

     This command augments each line or chunk of lines in the current
     file-visiting or blob-visiting buffer with information about the
     last revision in which a line still existed.

     Like ‘magit-blame-addition’, this command can be used recursively.

‘C-c M-g e’     (‘magit-blame-echo’)
‘C-c M-g B e’     (‘magit-blame-echo’)

     This command is like ‘magit-blame-addition’ except that it doesn’t
     turn on ‘read-only-mode’ and that it initially uses the
     visualization style specified by option ‘magit-blame-echo-style’.

The following key bindings are available when Magit-Blame mode is
enabled and Read-Only mode is not enabled.  These commands are also
available in other buffers; here only the behavior is described that is
relevant in file-visiting buffers that are being blamed.

‘RET’     (‘magit-show-commit’)

     This command shows the commit that last touched the line at point.

‘SPC’     (‘magit-diff-show-or-scroll-up’)

     This command updates the commit buffer.

     This either shows the commit that last touched the line at point in
     the appropriate buffer, or if that buffer is already being
     displayed in the current frame and if that buffer contains
     information about that commit, then the buffer is scrolled up
     instead.

‘DEL’     (‘magit-diff-show-or-scroll-down’)

     This command updates the commit buffer.

     This either shows the commit that last touched the line at point in
     the appropriate buffer, or if that buffer is already being
     displayed in the current frame and if that buffer contains
     information about that commit, then the buffer is scrolled down
     instead.

The following key bindings are available when both Magit-Blame mode and
Read-Only mode are enabled.

‘b’     (‘magit-blame’)

     See above.

‘n’     (‘magit-blame-next-chunk’)

     This command moves to the next chunk.

‘N’     (‘magit-blame-next-chunk-same-commit’)

     This command moves to the next chunk from the same commit.

‘p’     (‘magit-blame-previous-chunk’)

     This command moves to the previous chunk.

‘P’     (‘magit-blame-previous-chunk-same-commit’)

     This command moves to the previous chunk from the same commit.

‘q’     (‘magit-blame-quit’)

     This command turns off Magit-Blame mode.  If the buffer was created
     during a recursive blame, then it also kills the buffer.

‘M-w’     (‘magit-blame-copy-hash’)

     This command saves the hash of the current chunk’s commit to the
     kill ring.

     When the region is active, the command saves the region’s content
     instead of the hash, like ‘kill-ring-save’ would.

‘c’     (‘magit-blame-cycle-style’)

     This command changes how blame information is visualized in the
     current buffer by cycling through the styles specified using the
     option ‘magit-blame-styles’.

Blaming is also controlled using the following options.

 -- User Option: magit-blame-styles

     This option defines a list of styles used to visualize blame
     information.  For now see its doc-string to learn more.

 -- User Option: magit-blame-echo-style

     This option specifies the blame visualization style used by the
     command ‘magit-blame-echo’.  This must be a symbol that is used as
     the identifier for one of the styles defined in
     ‘magit-blame-styles’.

 -- User Option: magit-blame-time-format

     This option specifies the format string used to display times when
     showing blame information.

 -- User Option: magit-blame-read-only

     This option controls whether blaming a buffer also makes
     temporarily read-only.

 -- User Option: magit-blame-disable-modes

     This option lists incompatible minor-modes that should be disabled
     temporarily when a buffer contains blame information.  They are
     enabled again when the buffer no longer shows blame information.

 -- User Option: magit-blame-goto-chunk-hook

     This hook is run when moving between chunks.


File: magit.ja.info,  Node: Manipulating,  Next: Transferring,  Prev: Inspecting,  Up: Top

6 Manipulating
**************

* Menu:

* Creating Repository::
* Cloning Repository::
* Staging and Unstaging::
* Applying::
* Committing::
* Branching::
* Merging::
* Resolving Conflicts::
* Rebasing::
* Cherry Picking::
* Resetting::
* Stashing::


File: magit.ja.info,  Node: Creating Repository,  Next: Cloning Repository,  Up: Manipulating

6.1 Creating Repository
=======================

‘M-x magit-init’     (‘magit-init’)

     This command initializes a repository and then shows the status
     buffer for the new repository.

     If the directory is below an existing repository, then the user has
     to confirm that a new one should be created inside.  If the
     directory is the root of the existing repository, then the user has
     to confirm that it should be reinitialized.


File: magit.ja.info,  Node: Cloning Repository,  Next: Staging and Unstaging,  Prev: Creating Repository,  Up: Manipulating

6.2 Cloning Repository
======================

To clone a remote or local repository use ‘C’, which is bound to the
command ‘magit-clone’.  This command either act as a transient prefix
command, which binds several infix arguments and suffix commands, or it
can invoke ‘git clone’ directly, depending on whether a prefix argument
is used and on the value of ‘magit-clone-always-transient’.

 -- User Option: magit-clone-always-transient

     This option controls whether the command ‘magit-clone’ always acts
     as a transient prefix command, regardless of whether a prefix
     argument is used or not.  If ‘t’, then that command always acts as
     a transient prefix.  If ‘nil’, then a prefix argument has to be
     used for it to act as a transient.

‘C’     (‘magit-clone’)

     This command either acts as a transient prefix command as described
     above or does the same thing as ‘transient-clone-regular’ as
     described below.

     If it acts as a transient prefix, then it binds the following
     suffix commands and several infix arguments.

‘C C’     (‘magit-clone-regular’)

     This command creates a regular clone of an existing repository.
     The repository and the target directory are read from the user.

‘C s’     (‘magit-clone-shallow’)

     This command creates a shallow clone of an existing repository.
     The repository and the target directory are read from the user.  By
     default the depth of the cloned history is a single commit, but
     with a prefix argument the depth is read from the user.

‘C b’     (‘magit-clone-bare’)

     This command creates a bare clone of an existing repository.  The
     repository and the target directory are read from the user.

‘C m’     (‘magit-clone-mirror’)

     This command creates a mirror of an existing repository.  The
     repository and the target directory are read from the user.

The following suffixes are disabled by default.  See *note
(transient)Enabling and Disabling Suffixes:: for how to enable them.

‘C d’     (‘magit-clone-shallow-since’)

     This command creates a shallow clone of an existing repository.
     Only commits that were committed after a date are cloned, which is
     read from the user.  The repository and the target directory are
     also read from the user.

‘C e’     (‘magit-clone-shallow-exclude’)

     This command creates a shallow clone of an existing repository.
     This reads a branch or tag from the user.  Commits that are
     reachable from that are not cloned.  The repository and the target
     directory are also read from the user.

 -- User Option: magit-clone-set-remote-head

     This option controls whether cloning causes the reference
     ‘refs/remotes/<remote>/HEAD’ to be created in the clone.  The
     default is to delete the reference after running ‘git clone’, which
     insists on creating it.  This is because the reference has not been
     found to be particularly useful as it is not automatically updated
     when the ‘HEAD’ of the remote changes.  Setting this option to ‘t’
     preserves Git’s default behavior of creating the reference.

 -- User Option: magit-clone-set-remote.pushDefault

     This option controls whether the value of the Git variable
     ‘remote.pushDefault’ is set after cloning.

        • If ‘t’, then it is always set without asking.

        • If ‘ask’, then the users are asked every time they clone a
          repository.

        • If ‘nil’, then it is never set.

 -- User Option: magit-clone-default-directory

     This option control the default directory name used when reading
     the destination for a cloning operation.

        • If ‘nil’ (the default), then the value of ‘default-directory’
          is used.

        • If a directory, then that is used.

        • If a function, then that is called with the remote url as the
          only argument and the returned value is used.

 -- User Option: magit-clone-name-alist

     This option maps regular expressions, which match repository names,
     to repository urls, making it possible for users to enter short
     names instead of urls when cloning repositories.

     Each element has the form ‘(REGEXP HOSTNAME USER)’.  When the user
     enters a name when a cloning command asks for a name or url, then
     that is looked up in this list.  The first element whose REGEXP
     matches is used.

     The format specified by option ‘magit-clone-url-format’ is used to
     turn the name into an url, using HOSTNAME and the repository name.
     If the provided name contains a slash, then that is used.
     Otherwise if the name omits the owner of the repository, then the
     default user specified in the matched entry is used.

     If USER contains a dot, then it is treated as a Git variable and
     the value of that is used as the username.  Otherwise it is used as
     the username itself.

 -- User Option: magit-clone-url-format

     The format specified by this option is used when turning repository
     names into urls.  ‘%h’ is the hostname and ‘%n’ is the repository
     name, including the name of the owner.


File: magit.ja.info,  Node: Staging and Unstaging,  Next: Applying,  Prev: Cloning Repository,  Up: Manipulating

6.3 Staging and Unstaging
=========================

もちろん、Gitと同様Magitは、完全なファイルをステージ(stage)およびステー
ジ解除(unstage)できます。Gitとは異なり、ユーザーは個々のハンクやハンクの
一部を適切にステージ/ステージ解除することもできます。Gitを直接使用して個
々のハンクとハンクの一部をステージするには、‘git add --interactive’セッ
ションの、モーダルでかなり不器用なインターフェースを使用する必要がありま
す。

一方、Magitを使用すると、ステータスバッファまたは別のdiffバッファに表示
されているdiff内のそれぞれのセクションにポイントを移動し、‘s’または‘u’と
入力するだけで、個々のハンクのステージを解除(unstage)/ステージ(stage)で
きます。ハンクの一部だけを操作するには、リージョンを使用してステージ/ス
テージ解除する必要のある変更にマークを付けてから、ステージ/ステージ解除
に使用するのと同じキーを押します。複数のファイルまたはハンクを一度にステ
ージするには、そのようなセクションの見出しの内側で始まり、同じタイプの兄
弟セクションの見出しの内側で終わるリージョンを使用します。

ステージ(stage)とステージ解除(unstage)に加えて、Magitは、ファイルや一度
に複数のファイルやハンクや一度に複数のハンクやハンクの一部を操作できる他
のいくつかの「適用バリエーション」(apply variants)も提供します。 これら
の適用バリエーション(apply variants)については、次の節で説明します。

あなたはEdiffを使用してステージ(stage)およびステージ解除(unstage)するこ
ともできます→*note Ediffing::

‘s’     (‘magit-stage’)

     ポイントでの変更をステージ領域に追加します。

     前置引数と追跡されていないファイル(untracked file)(または複数のファ
     イル)をポイントに指定して、ファイルをステージしますが、その内容はス
     テージしません。これにより、新しいファイルの変更のサブセットのみを
     ステージすることが可能になります。

‘S’     (‘magit-stage-modified’)

     ワークツリー内で変更されたファイルへのすべての変更をステージします
     。追跡中のファイルのすべての新しいコンテンツをステージし、作業ツリ
     ーに存在しなくなった追跡中のファイルもインデックスから削除します。
     前置引数を使用すると、まだ追跡中でない(ただし無視されない)ファイル
     もステージされます。

‘u’     (‘magit-unstage’)

     ステージ領域からポイントされた変更(the change)を削除します。

     ステージされた変更のみがステージ解除できます。 ただし、デフォルトで
     は、このコマンドは、コミットされた変更で呼び出されたときに、ステー
     ジ解除にいくらか似たアクションを実行します。インデックスの変更を元
     に戻しますが、作業ツリーでは元に戻しません。

‘U’     (‘magit-unstage-all’)

     ステージ領域からすべての変更を削除します。

 -- User Option: magit-unstage-committed

     このオプションは、‘magit-unstage’が変更をコミットしたかどうかを、作
     業ツリーではなくインデックスで逆にすることによって制御します。別の
     方法は、エラーを発生させることです。

‘M-x magit-reverse-in-index’     (‘magit-reverse-in-index’)

     このコマンドは、作業ツリーではなく、インデックス内のポイントでコミ
     ットされた変更を元に戻します。デフォルトでは、このコマンドに直接結
     び付けられたキーはありませんが、コミットされた変更で
     ‘u’(‘magit-unstage’)が押されると、間接的に呼び出されます。

     これにより、‘HEAD’から変更を抽出し、作業ツリーに残しておくことがで
     きるため、後で別のコミットを使用してコミットできます。典型的なワー
     クフローは以下のとおりです:

        • オプションで、コミットされていない変更がないことを確認します。

        • ‘HEAD’コミットにアクセスし、そのコミットに含まれるべきではなか
          った変更に移動します。

        • ‘u’(‘magit-unstage’)と入力して、インデックスで逆にします。これ
          は、‘magit-unstage-committed-changes’がnil以外であることを前提
          としています。

        • ‘c e’と入力して、‘HEAD’を拡張し、以前に既にステージされた変更
          を含めます。

        • オプションで、‘s’または‘S’を使用して残りの変更をステージし、‘c
          c’と入力して新しいコミットを作成します。

‘M-x magit-reset-index’     (‘magit-reset-index’)

     インデックスをコミットにリセットします(Reset the index to some
     commit)。コミットはユーザーから読み取られ、デフォルトでその時点でコ
     ミットされます。その時点でコミットがない場合、デフォルトで‘HEAD’に
     なります。

* Menu:

* Staging from File-Visiting Buffers::


File: magit.ja.info,  Node: Staging from File-Visiting Buffers,  Up: Staging and Unstaging

6.3.1 Staging from File-Visiting Buffers
----------------------------------------

きめ細かいステージ/ステージ解除は、ステータスまたはdiffバッファから実行
する必要がありますが、現在のバッファでアクセスされたファイルに加えられた
すべての変更を、そのバッファ内から直接ステージ/ステージ解除することもで
きます。

‘M-x magit-stage-file’     (‘magit-stage-file’)

     file-visitingバッファ内で呼び出されると、そのファイルへのすべての変
     更をステージします。Magitバッファで、ファイルがある場合はその時点で
     ステージします。それ以外の場合は、ステージするファイルの入力を求め
     ます。前置引数を使用すると、file-visitingバッファ内やポイントにファ
     イルセクションがある場合でも、常にユーザーにファイルの入力を求める
     プロンプトが表示されます。

‘M-x magit-unstage-file’     (‘magit-unstage-file’)

     file-visitingバッファ内で呼び出された場合は、そのファイルへのすべて
     の変更をステージ解除します。 Magitバッファで、ある場合はその時点で
     ファイルのステージを解除します。それ以外の場合は、ファイルのステー
     ジを解除するように求められます。前置引数を使用すると、
     file-visitingバッファ内やポイントにファイルセクションがある場合でも
     、常にユーザーにファイルの入力を求めるプロンプトが表示されます。


File: magit.ja.info,  Node: Applying,  Next: Committing,  Prev: Staging and Unstaging,  Up: Manipulating

6.4 Applying
============

Magitはいくつかの適用バリエーションを提供します。それはステージ(stage)と
ステージ解除(unstage)と破棄(discard)と戻し(reverse)と通常のapply(regular
apply)です。少なくともハンクで操作する場合、それらはすべて‘git apply’を
使用して実装されます。そのため、これらは適用バリエーション("apply
variants")と呼ばれます。

   • ステージ(stage)。作業ツリーからインデックスに変更を適用(apply)しま
     す。変更は作業ツリーにも残ります。

   • ステージ解除(unstage)。インデックスから変更を削除します。 変更は作
     業ツリーに残ります。

   • 破棄(discard)。ステージされた変更(staged change)において、作業ツリ
     ーとインデックスから削除します。ステージされていない変更(unstaged
     change)では、作業ツリーからのみ削除します。

   • 戻し(reverse)。作業ツリーの変更を元に戻します。 コミットされた変更
     とステージされた変更(staged changes)の両方を元に戻すことができます
     。ステージされていない変更(unstaged changes)を元に戻すことはできま
     せん。代わりにそれらを破棄(discard)してください。

   • 適用(apply)。作業ツリーに変更を適用します。コミットされた変更とステ
     ージされた変更(staged changes)の両方を適用できます。ステージされて
     いない変更(unstaged changes)は適用できません。なぜならそれはすでに
     適用されているためです。

前節は、ステージコマンドとステージ解除コマンドについて説明しました。以下
は、残りの適用バリエーションを実装するコマンドです。

‘a’     (‘magit-apply’)

     ポイントでの変更を作業ツリーに適用(apply)します。

     前置引数を使用して、3方向マージにフォールバックします。これを行うと
     、変更がインデックスにも適用されます。

‘k’     (‘magit-discard’)

     Remove the change at point from the working tree.

‘v’     (‘magit-reverse’)

     Reverse the change at point in the working tree.

     前置引数を使用して、3方向マージにフォールバックします。これを行うと
     、変更がインデックスにも適用されます。

With a prefix argument all apply variants attempt a 3-way merge when
appropriate (i.e.  when ‘git apply’ is used internally).


File: magit.ja.info,  Node: Committing,  Next: Branching,  Prev: Applying,  Up: Manipulating

6.5 Committing
==============

When the user initiates a commit, Magit calls ‘git commit’ without any
arguments, so Git has to get it from the user.  It creates the file
‘.git/COMMIT_EDITMSG’ and then opens that file in an editor.  Magit
arranges for that editor to be the Emacsclient.  Once the user finishes
the editing session, the Emacsclient exits and Git creates the commit
using the file’s content as message.

* Menu:

* コミット開始::
* コミットメッセージ編集::


File: magit.ja.info,  Node: コミット開始,  Next: コミットメッセージ編集,  Up: Committing

6.5.1 コミット開始
------------------

こちらもご覧下さい *note (gitman)git-commit::.

‘c’     (‘magit-commit’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

‘c c’     (‘magit-commit-create’)

     ‘HEAD’に新しいコミットを作成します。プレフィックス引数を伴うと、代
     わりに‘HEAD’でコミットを修正(amend)します。

‘c a’     (‘magit-commit-amend’)

     最後のコミットを修正(amend)。

‘c e’     (‘magit-commit-extend’)

     メッセージを編集せずに、最後のコミットを修正します。プレフィックス
     引数を伴うとコミッターの日付(committer date)を保持します。それ以外
     の場合は変更します。 オプション
     ‘magit-commit-extend-override-date’を使用して、プレフィックス引数の
     意味を逆にすることができます。

     オプションのOVERRIDE-DATE引数を非対話的に尊重し、オプションを無視し
     ます。

‘c w’     (‘magit-commit-reword’)

     ステージされた変更を無視して、最後のコミットをreword(言い換え)しま
     す。 プレフィックス引数を使用してコミッターの日付を保持します。それ
     以外の場合は変更します。オプション
     ‘magit-commit-reword-override-date’を使用して、プレフィックス引数の
     意味を逆にすることができます。

     オプションのOVERRIDE-DATE引数を非対話的に尊重し、オプションを無視し
     ます。

‘c f’     (‘magit-commit-fixup’)

     Create a fixup commit.

     プレフィックス引数を使用して、ターゲットコミットを確認する必要があ
     ります。 それ以外の場合、オプション‘magit-commit-squash-confirm’の
     値によっては、その時点でのコミットが確認なしで使用される可能性があ
     ります。

‘c F’     (‘magit-commit-instant-fixup’)

     fixupコミットを作成し、即座にリベースします。

‘c s’     (‘magit-commit-squash’)

     Create a squash commit, without editing the squash message.

     プレフィックス引数を使用して、ターゲットコミットを確認する必要があ
     ります。 それ以外の場合、オプション‘magit-commit-squash-confirm’の
     値によっては、その時点でのコミットが確認なしで使用される可能性があ
     ります。

‘c S’     (‘magit-commit-instant-squash’)

     Create a squash commit and instantly rebase.

‘c A’     (‘magit-commit-augment’)

     Create a squash commit, editing the squash message.

     プレフィックス引数を使用して、ターゲットコミットを確認する必要があ
     ります。 それ以外の場合、オプション‘magit-commit-squash-confirm’の
     値によっては、その時点でのコミットが確認なしで使用される可能性があ
     ります。

 -- User Option: magit-commit-ask-to-stage

     Whether to ask to stage all unstaged changes when committing and
     nothing is staged.

 -- User Option: magit-commit-show-diff

     Whether the relevant diff is automatically shown when committing.

 -- User Option: magit-commit-extend-override-date

     Whether using ‘magit-commit-extend’ changes the committer date.

 -- User Option: magit-commit-reword-override-date

     Whether using ‘magit-commit-reword’ changes the committer date.

 -- User Option: magit-commit-squash-confirm

     Whether the commit targeted by squash and fixup has to be
     confirmed.  When non-nil then the commit at point (if any) is used
     as default choice.  Otherwise it has to be confirmed.  This option
     only affects ‘magit-commit-squash’ and ‘magit-commit-fixup’.  The
     "instant" variants always require confirmation because making an
     error while using those is harder to recover from.

 -- User Option: magit-post-commit-hook

     Hook run after creating a commit without the user editing a
     message.

     This hook is run by ‘magit-refresh’ if ‘this-command’ is a member
     of ‘magit-post-stage-hook-commands’.  This only includes commands
     named ‘magit-commit-*’ that do *not* require that the user edits
     the commit message in a buffer.

     Also see ‘git-commit-post-finish-hook’.


File: magit.ja.info,  Node: コミットメッセージ編集,  Prev: コミット開始,  Up: Committing

6.5.2 コミットメッセージ編集
----------------------------

前節で説明したようにコミットを開始すると、2つの新しいバッファが表示され
ます。1つはコミットされようとしている変更を示し、もう1つはメッセージの書
き込みに使用されます。

コミットメッセージは編集セッションで編集されます。バックグラウンドで
‘git’は、エディタ(この場合は‘emacsclient’)がコミットメッセージをファイル
(ほとんどの場合‘.git/COMMIT_EDITMSG’)に保存するのを待機しています。そし
て戻ります。エディタがゼロ以外の終了ステータスで戻った場合、‘git’はコミ
ットを作成しません。したがって、最も重要なコマンドは、コミットを終了およ
び中止するためのコマンドです。

‘C-c C-c’     (‘with-editor-finish’)

     終了コード0で戻ることにより、現在の編集セッションを終了します。次に
     、Gitは、ファイル内で見つけたメッセージを使用してコミットを作成しま
     す。

‘C-c C-k’     (‘with-editor-cancel’)

     終了コード1で戻ることにより、現在の編集セッションをキャンセルします
     。Gitはコミットをキャンセルしますが、ファイルは変更されません。

‘git commit’によって使用されることに加えて、メッセージはEmacsが閉じられ
るまで持続するリング(ring)に保存されることもあります。デフォルトでは、メ
ッセージは、(セッションが正常に終了したかキャンセルされたかに関係なく、
)編集セッションの開始時と終了時に保存されます。そのリングからメッセージ
を戻すと便利な場合があります。

‘C-c M-s’     (‘git-commit-save-message’)

     現在のバッファの内容をコミットメッセージリングに保存します。

‘M-p’     (‘git-commit-prev-message’)

     現在のメッセージをリングに保存した後、コミットメッセージリングを逆
     方向に循環します。数字の接頭辞ARGを付けて、コメントをARG個戻ります
     。

‘M-n’     (‘git-commit-next-message’)

     現在のメッセージをリングに保存した後、コミットメッセージリングを順
     方向に循環します。数字の接頭辞ARGを付けて、コメントをARG個戻ります
     。

デフォルトでは、コミットしようとしている変更のdiffは、コミットを呼び出す
ときに自動的に表示されます。これを防ぐには、‘server-switch-hook’から
‘magit-commit-diff’を削除します。

既存のコミットを修正するときは、そのコミットに追加されようとしている変更
を表示するか、すでにコミットされている変更と一緒にそれらの変更を表示する
と便利な場合があります。

‘C-c C-d’     (‘magit-diff-while-committing’)

     コミット中に、コミットしようとしている変更を表示します。修正中にコ
     マンドを再度呼び出すと、新しい変更のみを表示するか、コミットされる
     すべての変更を表示するかが切り替わります。

* Menu:

* Using the Revision Stack::
* Commit Pseudo Headers::
* Commit Mode and Hooks::
* Commit Message Conventions::


File: magit.ja.info,  Node: Using the Revision Stack,  Next: Commit Pseudo Headers,  Up: コミットメッセージ編集

Using the Revision Stack
........................

‘C-c C-w’     (‘magit-pop-revision-stack’)

     This command inserts a representation of a revision into the
     current buffer.  It can be used inside buffers used to write commit
     messages but also in other buffers such as buffers used to edit
     emails or ChangeLog files.

     By default this command pops the revision which was last added to
     the ‘magit-revision-stack’ and inserts it into the current buffer
     according to ‘magit-pop-revision-stack-format’.  Revisions can be
     put on the stack using ‘magit-copy-section-value’ and
     ‘magit-copy-buffer-revision’.

     If the stack is empty or with a prefix argument it instead reads a
     revision in the minibuffer.  By using the minibuffer history this
     allows selecting an item which was popped earlier or to insert an
     arbitrary reference or revision without first pushing it onto the
     stack.

     When reading the revision from the minibuffer, then it might not be
     possible to guess the correct repository.  When this command is
     called inside a repository (e.g.  while composing a commit
     message), then that repository is used.  Otherwise (e.g.  while
     composing an email) then the repository recorded for the top
     element of the stack is used (even though we insert another
     revision).  If not called inside a repository and with an empty
     stack, or with two prefix arguments, then read the repository in
     the minibuffer too.

 -- User Option: magit-pop-revision-stack-format

     This option controls how the command ‘magit-pop-revision-stack’
     inserts a revision into the current buffer.

     The entries on the stack have the format ‘(HASH TOPLEVEL)’ and this
     option has the format ‘(POINT-FORMAT EOB-FORMAT INDEX-REGEXP)’, all
     of which may be nil or a string (though either one of EOB-FORMAT or
     POINT-FORMAT should be a string, and if INDEX-REGEXP is non-nil,
     then the two formats should be too).

     First INDEX-REGEXP is used to find the previously inserted entry,
     by searching backward from point.  The first submatch must match
     the index number.  That number is incremented by one, and becomes
     the index number of the entry to be inserted.  If you don’t want to
     number the inserted revisions, then use nil for INDEX-REGEXP.

     If INDEX-REGEXP is non-nil then both POINT-FORMAT and EOB-FORMAT
     should contain \"%N\", which is replaced with the number that was
     determined in the previous step.

     Both formats, if non-nil and after removing %N, are then expanded
     using ‘git show --format=FORMAT ...’ inside TOPLEVEL.

     The expansion of POINT-FORMAT is inserted at point, and the
     expansion of EOB-FORMAT is inserted at the end of the buffer (if
     the buffer ends with a comment, then it is inserted right before
     that).


File: magit.ja.info,  Node: Commit Pseudo Headers,  Next: Commit Mode and Hooks,  Prev: Using the Revision Stack,  Up: コミットメッセージ編集

Commit Pseudo Headers
.....................

Some projects use pseudo headers in commit messages.  Magit colorizes
such headers and provides some commands to insert such headers.

 -- User Option: git-commit-known-pseudo-headers

     A list of Git pseudo headers to be highlighted.

‘C-c C-i’     (‘git-commit-insert-pseudo-header’)

     Insert a commit message pseudo header.

‘C-c C-a’     (‘git-commit-ack’)

     Insert a header acknowledging that you have looked at the commit.

‘C-c C-r’     (‘git-commit-review’)

     Insert a header acknowledging that you have reviewed the commit.

‘C-c C-s’     (‘git-commit-signoff’)

     Insert a header to sign off the commit.

‘C-c C-t’     (‘git-commit-test’)

     Insert a header acknowledging that you have tested the commit.

‘C-c C-o’     (‘git-commit-cc’)

     Insert a header mentioning someone who might be interested.

‘C-c C-p’     (‘git-commit-reported’)

     Insert a header mentioning the person who reported the issue being
     fixed by the commit.

‘C-c M-i’     (‘git-commit-suggested’)

     Insert a header mentioning the person who suggested the change.


File: magit.ja.info,  Node: Commit Mode and Hooks,  Next: Commit Message Conventions,  Prev: Commit Pseudo Headers,  Up: コミットメッセージ編集

Commit Mode and Hooks
.....................

‘git-commit-mode’ is a minor mode that is only used to establish certain
key bindings.  This makes it possible to use an arbitrary major mode in
buffers used to edit commit messages.  It is even possible to use
different major modes in different repositories, which is useful when
different projects impose different commit message conventions.

 -- User Option: git-commit-major-mode

     The value of this option is the major mode used to edit Git commit
     messages.

Because ‘git-commit-mode’ is a minor mode, we don’t use its mode hook to
setup the buffer, except for the key bindings.  All other setup happens
in the function ‘git-commit-setup’, which among other things runs the
hook ‘git-commit-setup-hook’.

 -- User Option: git-commit-setup-hook

     Hook run at the end of ‘git-commit-setup’.

The following functions are suitable for this hook:

 -- Function: git-commit-save-message

     現在のバッファの内容をコミットメッセージリングに保存します。

 -- Function: git-commit-setup-changelog-support

     After this function is called, ChangeLog entries are treated as
     paragraphs.

 -- Function: git-commit-turn-on-auto-fill

     Turn on ‘auto-fill-mode’ and set ‘fill-column’ to the value of
     ‘git-commit-fill-column’.

 -- Function: git-commit-turn-on-flyspell

     Turn on Flyspell mode.  Also prevent comments from being checked
     and finally check current non-comment text.

 -- Function: git-commit-propertize-diff

     Propertize the diff shown inside the commit message buffer.  Git
     inserts such diffs into the commit message template when the
     ‘--verbose’ argument is used.  ‘magit-commit’ by default does not
     offer that argument because the diff that is shown in a separate
     buffer is more useful.  But some users disagree, which is why this
     function exists.

 -- Function: bug-reference-mode

     Hyperlink bug references in the buffer.

 -- Function: with-editor-usage-message

     Show usage information in the echo area.

 -- User Option: git-commit-setup-hook

     Hook run after the user finished writing a commit message.

     This hook is only run after pressing ‘C-c C-c’ in a buffer used to
     edit a commit message.  If a commit is created without the user
     typing a message into a buffer, then this hook is not run.

     This hook is not run until the new commit has been created.  If
     doing so takes Git longer than one second, then this hook isn’t run
     at all.  For certain commands such as ‘magit-rebase-continue’ this
     hook is never run because doing so would lead to a race condition.

     This hook is only run if ‘magit’ is available.

     Also see ‘magit-post-commit-hook’.


File: magit.ja.info,  Node: Commit Message Conventions,  Prev: Commit Mode and Hooks,  Up: コミットメッセージ編集

Commit Message Conventions
..........................

Git-Commit highlights certain violations of commonly accepted commit
message conventions.  Certain violations even cause Git-Commit to ask
you to confirm that you really want to do that.  This nagging can of
course be turned off, but the result of doing that usually is that
instead of some code it’s now the human who is reviewing your commits
who has to waste some time telling you to fix your commits.

 -- User Option: git-commit-summary-max-length

     The intended maximal length of the summary line of commit messages.
     Characters beyond this column are colorized to indicate that this
     preference has been violated.

 -- User Option: git-commit-fill-column

     Column beyond which automatic line-wrapping should happen in commit
     message buffers.

 -- User Option: git-commit-finish-query-functions

     List of functions called to query before performing commit.

     The commit message buffer is current while the functions are
     called.  If any of them returns nil, then the commit is not
     performed and the buffer is not killed.  The user should then fix
     the issue and try again.

     The functions are called with one argument.  If it is non-nil then
     that indicates that the user used a prefix argument to force
     finishing the session despite issues.  Functions should usually
     honor this wish and return non-nil.

     By default the only member is ‘git-commit-check-style-conventions’.

 -- Function: git-commit-check-style-conventions

     This function checks for violations of certain basic style
     conventions.  For each violation it asks users if they want to
     proceed anyway.

 -- User Option: git-commit-style-convention-checks

     This option controls what conventions the function by the same name
     tries to enforce.  The value is a list of self-explanatory symbols
     identifying certain conventions; ‘non-empty-second-line’ and
     ‘overlong-summary-line’.


File: magit.ja.info,  Node: Branching,  Next: Merging,  Prev: Committing,  Up: Manipulating

6.6 Branching
=============

* Menu:

* The Two Remotes::
* Branch Commands::
* Branch Git Variables::
* Auxiliary Branch Commands::


File: magit.ja.info,  Node: The Two Remotes,  Next: Branch Commands,  Up: Branching

6.6.1 The Two Remotes
---------------------

The upstream branch of some local branch is the branch into which the
commits on that local branch should eventually be merged, usually
something like ‘origin/master’.  For the ‘master’ branch itself the
upstream branch and the branch it is being pushed to, are usually the
same remote branch.  But for a feature branch the upstream branch and
the branch it is being pushed to should differ.

The commits on feature branches too should _eventually_ end up in a
remote branch such as ‘origin/master’ or ‘origin/maint’.  Such a branch
should therefore be used as the upstream.  But feature branches
shouldn’t be pushed directly to such branches.  Instead a feature branch
‘my-feature’ is usually pushed to ‘my-fork/my-feature’ or if you are a
contributor ‘origin/my-feature’.  After the new feature has been
reviewed, the maintainer merges the feature into ‘master’.  And finally
‘master’ (not ‘my-feature’ itself) is pushed to ‘origin/master’.

But new features seldom are perfect on the first try, and so feature
branches usually have to be reviewed, improved, and re-pushed several
times.  Pushing should therefore be easy to do, and for that reason many
Git users have concluded that it is best to use the remote branch to
which the local feature branch is being pushed as its upstream.

But luckily Git has long ago gained support for a push-remote which can
be configured separately from the upstream branch, using the variables
‘branch.<name>.pushRemote’ and ‘remote.pushDefault’.  So we no longer
have to choose which of the two remotes should be used as "the remote".

Each of the fetching, pulling, and pushing transient commands features
three suffix commands that act on the current branch and some other
branch.  Of these, ‘p’ is bound to a command which acts on the
push-remote, ‘u’ is bound to a command which acts on the upstream, and
‘e’ is bound to a command which acts on any other branch.  The status
buffer shows unpushed and unpulled commits for both the push-remote and
the upstream.

It’s fairly simple to configure these two remotes.  The values of all
the variables that are related to fetching, pulling, and pushing (as
well as some other branch-related variables) can be inspected and
changed using the command ‘magit-branch-configure’, which is available
from many transient prefix commands that deal with branches.  It is also
possible to set the push-remote or upstream while pushing (see *note
Pushing::).


File: magit.ja.info,  Node: Branch Commands,  Next: Branch Git Variables,  Prev: The Two Remotes,  Up: Branching

6.6.2 Branch Commands
---------------------

The transient prefix command ‘magit-branch’ is used to create and
checkout branches, and to make changes to existing branches.  It is not
used to fetch, pull, merge, rebase, or push branches, i.e.  this command
deals with branches themselves, not with the commits reachable from
them.  Those features are available from separate transient command.

‘b’     (‘magit-branch’)

     この一時的(transient)前置(prefix)コマンドは、それに続く後置
     (suffix)コマンドを結びつけ、後置(suffix)コマンドが呼び出されるまで
     一時バッファ(temporary buffer)に表示します。

     By default it also binds and displays the values of some
     branch-related Git variables and allows changing their values.

 -- User Option: magit-branch-direct-configure

     This option controls whether the transient command ‘magit-branch’
     can be used to directly change the values of Git variables.  This
     defaults to ‘t’ (to avoid changing key bindings).  When set to
     ‘nil’, then no variables are displayed by that transient command,
     and its suffix command ‘magit-branch-configure’ has to be used
     instead to view and change branch related variables.

‘b C’     (‘magit-branch-configure’)
‘f C’     (‘magit-branch-configure’)
‘F C’     (‘magit-branch-configure’)
‘P C’     (‘magit-branch-configure’)

     この一時(transient)前置(prefix)コマンドは、ブランチ関連変数の値を設
     定するコマンドを結び付け、一時(transient)コマンドが終了するまでそれ
     らを一時バッファ(temporary buffer)に表示します。

     With a prefix argument, this command always prompts for a branch.

     Without a prefix argument this depends on whether it was invoked as
     a suffix of ‘magit-branch’ and on the
     ‘magit-branch-direct-configure’ option.  If ‘magit-branch’ already
     displays the variables for the current branch, then it isn’t useful
     to invoke another transient that displays them for the same branch.
     In that case this command prompts for a branch.

The variables are described in *note Branch Git Variables::.

‘b b’     (‘magit-checkout’)

     Checkout a revision read in the minibuffer and defaulting to the
     branch or arbitrary revision at point.  If the revision is a local
     branch then that becomes the current branch.  If it is something
     else then ‘HEAD’ becomes detached.  Checkout fails if the working
     tree or the staging area contain changes.

‘b n’     (‘magit-branch-create’)

     Create a new branch.  The user is asked for a branch or arbitrary
     revision to use as the starting point of the new branch.  When a
     branch name is provided, then that becomes the upstream branch of
     the new branch.  The name of the new branch is also read in the
     minibuffer.

     Also see option ‘magit-branch-prefer-remote-upstream’.

‘b c’     (‘magit-branch-and-checkout’)

     This command creates a new branch like ‘magit-branch-create’, but
     then also checks it out.

     Also see option ‘magit-branch-prefer-remote-upstream’.

‘b l’     (‘magit-branch-checkout’)

     This command checks out an existing or new local branch.  It reads
     a branch name from the user offering all local branches and a
     subset of remote branches as candidates.  Remote branches for which
     a local branch by the same name exists are omitted from the list of
     candidates.  The user can also enter a completely new branch name.

        • If the user selects an existing local branch, then that is
          checked out.

        • If the user selects a remote branch, then it creates and
          checks out a new local branch with the same name, and
          configures the selected remote branch as the push target.

        • If the user enters a new branch name, then it creates and
          checks that out, after also reading the starting-point from
          the user.

     In the latter two cases the upstream is also set.  Whether it is
     set to the chosen starting point or something else depends on the
     value of ‘magit-branch-adjust-remote-upstream-alist’.

‘b s’     (‘magit-branch-spinoff’)

     This command creates and checks out a new branch starting at and
     tracking the current branch.  That branch in turn is reset to the
     last commit it shares with its upstream.  If the current branch has
     no upstream or no unpushed commits, then the new branch is created
     anyway and the previously current branch is not touched.

     This is useful to create a feature branch after work has already
     began on the old branch (likely but not necessarily "master").

     If the current branch is a member of the value of option
     ‘magit-branch-prefer-remote-upstream’ (which see), then the current
     branch will be used as the starting point as usual, but the
     upstream of the starting-point may be used as the upstream of the
     new branch, instead of the starting-point itself.

     If optional FROM is non-nil, then the source branch is reset to
     ‘FROM~’, instead of to the last commit it shares with its upstream.
     Interactively, FROM is only ever non-nil, if the region selects
     some commits, and among those commits, FROM is the commit that is
     the fewest commits ahead of the source branch.

     The commit at the other end of the selection actually does not
     matter, all commits between FROM and ‘HEAD’ are moved to the new
     branch.  If FROM is not reachable from ‘HEAD’ or is reachable from
     the source branch’s upstream, then an error is raised.

‘b S’     (‘magit-branch-spinout’)

     This command behaves like ‘magit-branch-spinoff’, except that it
     does not change the current branch.  If there are any uncommitted
     changes, then it behaves exactly like ‘magit-branch-spinoff’.

‘b x’     (‘magit-branch-reset’)

     This command resets a branch, defaulting to the branch at point, to
     the tip of another branch or any other commit.

     When the branch being reset is the current branch, then a hard
     reset is performed.  If there are any uncommitted changes, then the
     user has to confirm the reset because those changes would be lost.

     This is useful when you have started work on a feature branch but
     realize it’s all crap and want to start over.

     When resetting to another branch and a prefix argument is used,
     then the target branch is set as the upstream of the branch that is
     being reset.

‘b k’     (‘magit-branch-delete’)

     Delete one or multiple branches.  If the region marks multiple
     branches, then offer to delete those.  Otherwise, prompt for a
     single branch to be deleted, defaulting to the branch at point.

‘b r’     (‘magit-branch-rename’)

     Rename a branch.  The branch and the new name are read in the
     minibuffer.  With prefix argument the branch is renamed even if
     that name conflicts with an existing branch.

 -- User Option: magit-branch-read-upstream-first

     When creating a branch, whether to read the upstream branch before
     the name of the branch that is to be created.  The default is ‘t’,
     and I recommend you leave it at that.

 -- User Option: magit-branch-prefer-remote-upstream

     This option specifies whether remote upstreams are favored over
     local upstreams when creating new branches.

     When a new branch is created, then the branch, commit, or stash at
     point is suggested as the starting point of the new branch, or if
     there is no such revision at point the current branch.  In either
     case the user may choose another starting point.

     If the chosen starting point is a branch, then it may also be set
     as the upstream of the new branch, depending on the value of the
     Git variable ‘branch.autoSetupMerge’.  By default this is done for
     remote branches, but not for local branches.

     You might prefer to always use some remote branch as upstream.  If
     the chosen starting point is (1) a local branch, (2) whose name
     matches a member of the value of this option, (3) the upstream of
     that local branch is a remote branch with the same name, and (4)
     that remote branch can be fast-forwarded to the local branch, then
     the chosen branch is used as starting point, but its own upstream
     is used as the upstream of the new branch.

     Members of this option’s value are treated as branch names that
     have to match exactly unless they contain a character that makes
     them invalid as a branch name.  Recommended characters to use to
     trigger interpretation as a regexp are "*" and "^".  Some other
     characters which you might expect to be invalid, actually are not,
     e.g.  ".+$" are all perfectly valid.  More precisely, if ‘git
     check-ref-format --branch STRING’ exits with a non-zero status,
     then treat STRING as a regexp.

     Assuming the chosen branch matches these conditions you would end
     up with with e.g.:

          feature --upstream--> origin/master

     instead of

          feature --upstream--> master --upstream--> origin/master

     Which you prefer is a matter of personal preference.  If you do
     prefer the former, then you should add branches such as ‘master’,
     ‘next’, and ‘maint’ to the value of this options.

 -- User Option: magit-branch-adjust-remote-upstream-alist

     The value of this option is an alist of branches to be used as the
     upstream when branching a remote branch.

     When creating a local branch from an ephemeral branch located on a
     remote, e.g.  a feature or hotfix branch, then that remote branch
     should usually not be used as the upstream branch, since the
     push-remote already allows accessing it and having both the
     upstream and the push-remote reference the same related branch
     would be wasteful.  Instead a branch like "maint" or "master"
     should be used as the upstream.

     This option allows specifying the branch that should be used as the
     upstream when branching certain remote branches.  The value is an
     alist of the form ‘((UPSTREAM . RULE)...)’.  The first matching
     element is used, the following elements are ignored.

     UPSTREAM is the branch to be used as the upstream for branches
     specified by RULE.  It can be a local or a remote branch.

     RULE can either be a regular expression, matching branches whose
     upstream should be the one specified by UPSTREAM.  Or it can be a
     list of the only branches that should *not* use UPSTREAM; all other
     branches will.  Matching is done after stripping the remote part of
     the name of the branch that is being branched from.

     If you use a finite set of non-ephemeral branches across all your
     repositories, then you might use something like:

          (("origin/master" . ("master" "next" "maint")))

     Or if the names of all your ephemeral branches contain a slash, at
     least in some repositories, then a good value could be:

          (("origin/master" . "/"))

     Of course you can also fine-tune:

          (("origin/maint" . "\\`hotfix/")
           ("origin/master" . "\\`feature/"))

     UPSTREAM can be a local branch:

          (("master" . ("master" "next" "maint")))

Because the main branch is no longer almost always named "master" you
should also account for other common names:

     (("main"  . ("main" "master" "next" "maint"))
      ("master" . ("main" "master" "next" "maint")))

 -- Command: magit-branch-orphan

     This command creates and checks out a new orphan branch with
     contents from a given revision.

 -- Command: magit-branch-or-checkout

     This command is a hybrid between ‘magit-checkout’ and
     ‘magit-branch-and-checkout’ and is intended as a replacement for
     the former in ‘magit-branch’.

     It first asks the user for an existing branch or revision.  If the
     user input actually can be resolved as a branch or revision, then
     it checks that out, just like ‘magit-checkout’ would.

     Otherwise it creates and checks out a new branch using the input as
     its name.  Before doing so it reads the starting-point for the new
     branch.  This is similar to what ‘magit-branch-and-checkout’ does.

     To use this command instead of ‘magit-checkout’ add this to your
     init file:

          (transient-replace-suffix 'magit-branch 'magit-checkout
            '("b" "dwim" magit-branch-or-checkout))


File: magit.ja.info,  Node: Branch Git Variables,  Next: Auxiliary Branch Commands,  Prev: Branch Commands,  Up: Branching

6.6.3 Branch Git Variables
--------------------------

These variables can be set from the transient prefix command
‘magit-branch-configure’.  By default they can also be set from
‘magit-branch’.  See *note Branch Commands::.

 -- Variable: branch.NAME.merge

     Together with ‘branch.NAME.remote’ this variable defines the
     upstream branch of the local branch named NAME.  The value of this
     variable is the full reference of the upstream _branch_.

 -- Variable: branch.NAME.remote

     Together with ‘branch.NAME.merge’ this variable defines the
     upstream branch of the local branch named NAME.  The value of this
     variable is the name of the upstream _remote_.

 -- Variable: branch.NAME.rebase

     This variable controls whether pulling into the branch named NAME
     is done by rebasing or by merging the fetched branch.

        • When ‘true’ then pulling is done by rebasing.

        • When ‘false’ then pulling is done by merging.

        • When undefined then the value of ‘pull.rebase’ is used.  The
          default of that variable is ‘false’.

 -- Variable: branch.NAME.pushRemote

     This variable specifies the remote that the branch named NAME is
     usually pushed to.  The value has to be the name of an existing
     remote.

     It is not possible to specify the name of _branch_ to push the
     local branch to.  The name of the remote branch is always the same
     as the name of the local branch.

     If this variable is undefined but ‘remote.pushDefault’ is defined,
     then the value of the latter is used.  By default
     ‘remote.pushDefault’ is undefined.

 -- Variable: branch.NAME.description

     This variable can be used to describe the branch named NAME.  That
     description is used e.g.  when turning the branch into a series of
     patches.

The following variables specify defaults which are used if the above
branch-specific variables are not set.

 -- Variable: pull.rebase

     This variable specifies whether pulling is done by rebasing or by
     merging.  It can be overwritten using ‘branch.NAME.rebase’.

        • When ‘true’ then pulling is done by rebasing.

        • When ‘false’ (the default) then pulling is done by merging.

     Since it is never a good idea to merge the upstream branch into a
     feature or hotfix branch and most branches are such branches, you
     should consider setting this to ‘true’, and ‘branch.master.rebase’
     to ‘false’.

 -- Variable: remote.pushDefault

     This variable specifies what remote the local branches are usually
     pushed to.  This can be overwritten per branch using
     ‘branch.NAME.pushRemote’.

The following variables are used during the creation of a branch and
control whether the various branch-specific variables are automatically
set at this time.

 -- Variable: branch.autoSetupMerge

     This variable specifies under what circumstances creating a branch
     NAME should result in the variables ‘branch.NAME.merge’ and
     ‘branch.NAME.remote’ being set according to the starting point used
     to create the branch.  If the starting point isn’t a branch, then
     these variables are never set.

        • When ‘always’ then the variables are set regardless of whether
          the starting point is a local or a remote branch.

        • When ‘true’ (the default) then the variables are set when the
          starting point is a remote branch, but not when it is a local
          branch.

        • When ‘false’ then the variables are never set.

 -- Variable: branch.autoSetupRebase

     This variable specifies whether creating a branch NAME should
     result in the variable ‘branch.NAME.rebase’ being set to ‘true’.

        • When ‘always’ then the variable is set regardless of whether
          the starting point is a local or a remote branch.

        • When ‘local’ then the variable are set when the starting point
          is a local branch, but not when it is a remote branch.

        • When ‘remote’ then the variable are set when the starting
          point is a remote branch, but not when it is a local branch.

        • When ‘never’ (the default) then the variable is never set.

Note that the respective commands always change the repository-local
values.  If you want to change the global value, which is used when the
local value is undefined, then you have to do so on the command line,
e.g.:

     git config --global remote.autoSetupMerge always

For more information about these variables you should also see

*note (gitman)git-config::.  こちらもご覧下さい *note
(gitman)git-branch::.  , *note (gitman)git-checkout::.  and *note
Pushing::.

 -- User Option: magit-prefer-remote-upstream

     This option controls whether commands that read a branch from the
     user and then set it as the upstream branch, offer a local or a
     remote branch as default completion candidate, when they have the
     choice.

     This affects all commands that use ‘magit-read-upstream-branch’ or
     ‘magit-read-starting-point’, which includes all commands that
     change the upstream and many which create new branches.


File: magit.ja.info,  Node: Auxiliary Branch Commands,  Prev: Branch Git Variables,  Up: Branching

6.6.4 Auxiliary Branch Commands
-------------------------------

These commands are not available from the transient ‘magit-branch’ by
default.

 -- magit-branch-shelve: コマンド

     This command shelves a branch.  This is done by deleting the
     branch, and creating a new reference "refs/shelved/BRANCH-NAME"
     pointing at the same commit as the branch pointed at.  If the
     deleted branch had a reflog, then that is preserved as the reflog
     of the new reference.

     This is useful if you want to move a branch out of sight, but are
     not ready to completely discard it yet.

 -- magit-branch-unshelve: コマンド

     This command unshelves a branch that was previously shelved using
     ‘magit-branch-shelve’.  This is done by deleting the reference
     "refs/shelved/BRANCH-NAME" and creating a branch "BRANCH-NAME"
     pointing at the same commit as the deleted reference pointed at.
     If the deleted reference had a reflog, then that is restored as the
     reflog of the branch.


File: magit.ja.info,  Node: Merging,  Next: Resolving Conflicts,  Prev: Branching,  Up: Manipulating

6.7 Merging
===========

こちらもご覧下さい *note (gitman)git-merge:: マージの競合を解決する方法
については、次節を参照してください。

‘m’     (‘magit-merge’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

マージが進行中でない場合、一時コマンドに(transient)は以下の後置コマンド
があります。

‘m m’     (‘magit-merge-plain’)

     このコマンドは、別のブランチまたは任意のリビジョンを現在のブランチ
     にマージします。 マージされるブランチまたはリビジョンはミニバッファ
     に読み込まれ、デフォルトでその時点のブランチになります。

     競合があるか、前置引数が使用されていない限り、結果のマージコミット
     は一般的なコミットメッセージを使用し、ユーザーはコミットが作成され
     る前にそれを検査または変更する機会がありません。前置引数を使用する
     と、実際にはマージコミットが作成されないため、競合がどのように解決
     されたかを検査し、コミットメッセージを調整できます。

‘m e’     (‘magit-merge-editmsg’)

     このコマンドは、別のブランチまたは任意のリビジョンを現在のブランチ
     にマージし、コミットメッセージバッファを開いて、ユーザーが調整でき
     るようにします。コミットは、ユーザーが‘C-c C-c’で終了するまで実際に
     は作成されません。

‘m n’     (‘magit-merge-nocommit’)

     このコマンドは、別のブランチまたは任意のリビジョンを現在のブランチ
     にマージしますが、実際にはマージコミットを作成しません。その後、ユ
     ーザーは、自動競合解決が成功した場合でも、マージをさらに調整したり
     、コミットメッセージを調整したりできます。

‘m a’     (‘magit-merge-absorb’)

     このコマンドは、別のローカルブランチを現在のブランチにマージしてか
     ら、前者を削除します。

     ソースブランチがマージされる前に、それぞれのリモートブランチがすで
     に存在する場合、最初にプッシュリモートに強制的にプッシュされます。
     これにより、それぞれのプルリクエスト(存在する場合)が、マージされて
     いるコミットの廃止されたバージョンでスタックすることがなくなります
     。最後に、‘magit-branch-pull-request’を使用してマージされたブランチ
     を作成した場合、それぞれのリモートブランチも削除されます。

‘m i’     (‘magit-merge-into’)

     このコマンドは、現在のブランチを別のローカルブランチにマージしてか
     ら、前者を削除します。後者が新しい現在のブランチになります。

     ソースブランチがマージされる前に、それぞれのリモートブランチがすで
     に存在する場合、最初にプッシュリモートに強制的にプッシュされます。
     これにより、それぞれのプルリクエスト(存在する場合)が、マージされて
     いるコミットの廃止されたバージョンでスタックすることがなくなります
     。最後に、‘magit-branch-pull-request’を使用してマージされたブランチ
     を作成した場合、それぞれのリモートブランチも削除されます。

‘m s’     (‘magit-merge-squash’)

     このコマンドは、別のブランチまたは任意のリビジョンによって現在のブ
     ランチに導入された変更を破棄します。これは、squashコミットによって
     行われた変更にのみ適用されます。 実際のマージコミットの作成を可能に
     する情報は保持されません。このコマンドの代わりに、apply一時コマンド
     からのコマンドを使用する必要があります。

‘m p’     (‘magit-merge-preview’)

     このコマンドは、別のブランチまたは任意のリビジョンを現在のブランチ
     にマージするプレビューを表示します。

マージが進行中の場合、一時コマンドは代わりに以下の後置コマンドを備えてい
ます。

‘m m’     (‘magit-merge’)

     ユーザーが競合を解決した後、このコマンドはマージを続行します。一部
     の競合が解決されなかった場合、このコマンドは失敗します。

‘m a’     (‘magit-merge-abort’)

     このコマンドは、現在のマージ操作を中止(abort)します。


File: magit.ja.info,  Node: Resolving Conflicts,  Next: Rebasing,  Prev: Merging,  Up: Manipulating

6.8 Resolving Conflicts
=======================

ブランチをマージする(または履歴を結合または変更する)と、競合が発生する可
能性があります。 同じファイルの2つの完全に異なる部分を2つのブランチで編
集してから、これらのブランチの1つを別のブランチにマージすると、Gitはそれ
を独自に解決できますが、ファイルの同じ領域を編集する場合は、人間が必要で
す。 2つのバージョン、つまり「競合の側面」を1つに組み合わせる方法を決定
します。

ここでは、主題の簡単な紹介のみを提供し、役立ついくつかのツールを紹介しま
す。これが初めての場合は、Git独自の文書やその他のリソースも参照してくだ
さい。

ファイルに競合があり、Gitがそれ自体で解決できない場合は、ファイルの未解
決部分の境界と異なるバージョン間の境界を示すことを目的とした特別なマーカ
ーとともに、両方のバージョンを影響を受けるファイルに配置します。 これら
の境界線は、‘<’、‘|’、‘=’、‘>’のいずれかの6個の同じ文字で構成される文字
列で始まり、その後にそれぞれのバージョンのソースに関する情報が続きます。
例:

     <<<<<<< HEAD
     Take the blue pill.
     =======
     Take the red pill.
     >>>>>>> feature

この場合、1つのブランチで赤い薬(red pill)を服用し、別のブランチで青い薬
(blue pill)を選択しました。 これらの2つの分岐するブランチをマージしてい
るので、Gitはどちらの薬を服用したいかをおそらく知ることができません。

この競合を解決するには、ファイルの影響を受ける領域のバージョンを作成する
必要があります。一方の側だけを保持し、場合によってはもう一方の側から変更
を取り込むために編集して、他のバージョンとマーカーを削除します。次に結果
をステージします。 考えられる解決策は次のとおりです:

     Take both pills.

多くの場合、競合の2つの側面だけでなく、ファイルの同じ領域が異なるブラン
チで2回変更される前の「元の」バージョンも確認すると便利です。 このコマン
ドを1回実行して、そのバージョンも挿入するようにGitに指示します:

     git config --global merge.conflictStyle diff3

上記の競合は以下のようになっているかもしれません:

     <<<<<<< HEAD
     Take the blue pill.
     ||||||| merged common ancestors
     Take either the blue or the red pill, but not both.
     =======
     Take the red pill.
     >>>>>>> feature

その場合、上記の競合解決は正しくありませんでした。これは、競合するバージ
ョンと一緒に元のバージョンを表示することが役立つ理由を示しています。

あなたは競合の解決を手動で完全に実行できますが、Emacsには、この処理に役
立ついくつかのパッケージ（Smerge、Ediff(*note (ediff)Top::)、
Emerge(*note (emacs)Emerge::))も用意されています。 Magitは、競合を解決す
るための独自のツールを提供していませんが、SmergeとEdiffの使用をより便利
にします。(EdiffはEmergeに取って代わるので、あなたはEmergeを使いたくなく
なる事でしょう。)

Magitステータスバッファでは、競合が解決されていないファイルが"Unstaged
changes"または"Staged changes"セクションに一覧表示されます。 これらの前
には"unmerged"という単語が付いています。これは、この文脈では本質的に
"unresolved"の同義語です。

ポイントがそのようなファイルセクションにあるときに‘RET’を押すと、そのフ
ァイルを訪れている(visit)バッファが表示され、そのバッファで
‘smerge-mode’がオンになり、競合のある最初の領域内にポイントが配置されま
す。それから、あなたは、通常の編集コマンドやSmergeコマンドを使用してその
競合を解決する必要があります。

残念ながら、Smergeにはマニュアルがありませんが、コマンドのリストを取得し
て‘C-c ^ C-h’をバインドし、ポイントがコマンド名にあるときに‘RET’を押して
ドキュメントを読むことができます。

通常、1つのバージョンを編集してから、そのバージョンのみを保持するように
Smergeに指示します。‘C-c ^ m’(‘smerge-keep-mine’)を使用して‘HEAD’バージ
ョンを保持するか、‘C-c ^ o’(‘smerge-keep-other’)を使用して"|||||||"に続
くバージョンを保持します。次に、‘C-c ^ n’を使用して、同じファイル内の次
の競合する領域に移動します。競合の解決が完了したら、Magitステータスバッ
ファに戻ります。 最後の競合を解決した後にバッファを保存すると、Smergeが
ファイルを自動的にステージするため、ファイルは"unmerged"として表示されな
くなり、"modified"として表示されます。

あるいは、ファイルのバージョンごとに別々のバッファを使用するEdiffを使用
することもできます。 Ediffを使用してファイル内の競合を解決するには、ステ
ータスバッファ内のそのようなファイル上にポイントがあるときに‘e’を押しま
す。

Ediffは他の目的にも使用できます。MagitからEdiffに入る方法の詳細について
は→*note Ediffing:: Ediffの使用方法の説明は、このマニュアルの範囲を超え
ています。代わりに→*note (ediff)Top::

SmergeとEdiffのどちらを使用すべきかわからない場合は、前者を使用してくだ
さい。理解して使用する方がはるかに簡単であり、本当に複雑な競合を除いて、
後者は通常やり過ぎです。


File: magit.ja.info,  Node: Rebasing,  Next: Cherry Picking,  Prev: Resolving Conflicts,  Up: Manipulating

6.9 Rebasing
============

こちらもご覧下さい *note (gitman)git-rebase:: リベース中に発生する競合を
解決する方法については、前節を参照してください。

‘r’     (‘magit-rebase’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

When no rebase is in progress, then the transient features the following
suffix commands.

Using one of these commands _starts_ a rebase sequence.  Git might then
stop somewhere along the way, either because you told it to do so, or
because applying a commit failed due to a conflict.  When that happens,
then the status buffer shows information about the rebase sequence which
is in progress in a section similar to a log section.  See *note
Information About In-Progress Rebase::.

For information about the upstream and the push-remote, see *note The
Two Remotes::.

‘r p’     (‘magit-rebase-onto-pushremote’)

     This command rebases the current branch onto its push-remote.

     With a prefix argument or when the push-remote is either not
     configured or unusable, then let the user first configure the
     push-remote.

‘r u’     (‘magit-rebase-onto-upstream’)

     This command rebases the current branch onto its upstream branch.

     With a prefix argument or when the upstream is either not
     configured or unusable, then let the user first configure the
     upstream.

‘r e’     (‘magit-rebase-branch’)

     This command rebases the current branch onto a branch read in the
     minibuffer.  All commits that are reachable from head but not from
     the selected branch TARGET are being rebased.

‘r s’     (‘magit-rebase-subset’)

     This command starts a non-interactive rebase sequence to transfer
     commits from START to ‘HEAD’ onto NEWBASE.  START has to be
     selected from a list of recent commits.

By default Magit uses the ‘--autostash’ argument, which causes
uncommitted changes to be stored in a stash before the rebase begins.
These changes are restored after the rebase completes and if possible
the stash is removed.  If the stash does not apply cleanly, then the
stash is not removed.  In case something goes wrong when resolving the
conflicts, this allows you to start over.

Even though one of the actions is dedicated to interactive rebases, the
transient also features the infix argument ‘--interactive’.  This can be
used to turn one of the other, non-interactive rebase variants into an
interactive rebase.

For example if you want to clean up a feature branch and at the same
time rebase it onto ‘master’, then you could use ‘r-iu’.  But we
recommend that you instead do that in two steps.  First use ‘ri’ to
cleanup the feature branch, and then in a second step ‘ru’ to rebase it
onto ‘master’.  That way if things turn out to be more complicated than
you thought and/or you make a mistake and have to start over, then you
only have to redo half the work.

Explicitly enabling ‘--interactive’ won’t have an effect on the
following commands as they always use that argument anyway, even if it
is not enabled in the transient.

‘r i’     (‘magit-rebase-interactive’)

     This command starts an interactive rebase sequence.

‘r f’     (‘magit-rebase-autosquash’)

     This command combines squash and fixup commits with their intended
     targets.

‘r m’     (‘magit-rebase-edit-commit’)

     This command starts an interactive rebase sequence that lets the
     user edit a single older commit.

‘r w’     (‘magit-rebase-reword-commit’)

     This command starts an interactive rebase sequence that lets the
     user reword a single older commit.

‘r k’     (‘magit-rebase-remove-commit’)

     This command removes a single older commit using rebase.

When a rebase is in progress, then the transient instead features the
following suffix commands.

‘r r’     (‘magit-rebase-continue’)

     This command restart the current rebasing operation.

     In some cases this pops up a commit message buffer for you do edit.
     With a prefix argument the old message is reused as-is.

‘r s’     (‘magit-rebase-skip’)

     This command skips the current commit and restarts the current
     rebase operation.

‘r e’     (‘magit-rebase-edit’)

     This command lets the user edit the todo list of the current rebase
     operation.

‘r a’     (‘magit-rebase-abort’)

     This command aborts the current rebase operation, restoring the
     original branch.

* Menu:

* Editing Rebase Sequences::
* Information About In-Progress Rebase::


File: magit.ja.info,  Node: Editing Rebase Sequences,  Next: Information About In-Progress Rebase,  Up: Rebasing

6.9.1 Editing Rebase Sequences
------------------------------

‘C-c C-c’     (‘with-editor-finish’)

     Finish the current editing session by returning with exit code 0.
     Git then uses the rebase instructions it finds in the file.

‘C-c C-k’     (‘with-editor-cancel’)

     Cancel the current editing session by returning with exit code 1.
     Git then forgoes starting the rebase sequence.

‘RET’     (‘git-rebase-show-commit’)

     Show the commit on the current line in another buffer and select
     that buffer.

‘SPC’     (‘git-rebase-show-or-scroll-up’)

     Show the commit on the current line in another buffer without
     selecting that buffer.  If the revision buffer is already visible
     in another window of the current frame, then instead scroll that
     window up.

‘DEL’     (‘git-rebase-show-or-scroll-down’)

     Show the commit on the current line in another buffer without
     selecting that buffer.  If the revision buffer is already visible
     in another window of the current frame, then instead scroll that
     window down.

‘p’     (‘git-rebase-backward-line’)

     Move to previous line.

‘n’     (‘forward-line’)

     Move to next line.

‘M-p’     (‘git-rebase-move-line-up’)

     Move the current commit (or command) up.

‘M-n’     (‘git-rebase-move-line-down’)

     Move the current commit (or command) down.

‘r’     (‘git-rebase-reword’)

     Edit message of commit on current line.

‘e’     (‘git-rebase-edit’)

     Stop at the commit on the current line.

‘s’     (‘git-rebase-squash’)

     Meld commit on current line into previous commit, and edit message.

‘f’     (‘git-rebase-fixup’)

     Meld commit on current line into previous commit, discarding the
     current commit’s message.

‘k’     (‘git-rebase-kill-line’)

     Kill the current action line.

‘c’     (‘git-rebase-pick’)

     Use commit on current line.

‘x’     (‘git-rebase-exec’)

     Insert a shell command to be run after the proceeding commit.

     If there already is such a command on the current line, then edit
     that instead.  With a prefix argument insert a new command even
     when there already is one on the current line.  With empty input
     remove the command on the current line, if any.

‘b’     (‘git-rebase-break’)

     Insert a break action before the current line, instructing Git to
     return control to the user.

‘y’     (‘git-rebase-insert’)

     Read an arbitrary commit and insert it below current line.

‘C-x u’     (‘git-rebase-undo’)

     Undo some previous changes.  Like ‘undo’ but works in read-only
     buffers.

 -- User Option: git-rebase-auto-advance

     Whether to move to next line after changing a line.

 -- User Option: git-rebase-show-instructions

     Whether to show usage instructions inside the rebase buffer.

 -- User Option: git-rebase-confirm-cancel

     Whether confirmation is required to cancel.

When a rebase is performed with the ‘--rebase-merges’ option, the
sequence will include a few other types of actions and the following
commands become relevant.

‘l’     (‘git-rebase-label’)

     This commands inserts a label action or edits the one at point.

‘t’     (‘git-rebase-reset’)

     This command inserts a reset action or edits the one at point.  The
     prompt will offer the labels that are currently present in the
     buffer.

‘MM’     (‘git-rebase-merge’)

     The command inserts a merge action or edits the one at point.  The
     prompt will offer the labels that are currently present in the
     buffer.  Specifying a message to reuse via ‘-c’ or ‘-C’ is not
     supported; an editor will always be invoked for the merge.

‘Mt’     (‘git-rebase-merge-toggle-editmsg’)

     This command toggles between the ‘-C’ and ‘-c’ options of the merge
     action at point.  These options both specify a commit whose message
     should be reused.  The lower-case variant instructs Git to invoke
     the editor when creating the merge, allowing the user to edit the
     message.


File: magit.ja.info,  Node: Information About In-Progress Rebase,  Prev: Editing Rebase Sequences,  Up: Rebasing

6.9.2 Information About In-Progress Rebase
------------------------------------------

While a rebase sequence is in progress, the status buffer features a
section that lists the commits that have already been applied as well as
the commits that still have to be applied.

The commits are split in two halves.  When rebase stops at a commit,
either because the user has to deal with a conflict or because s/he
explicitly requested that rebase stops at that commit, then point is
placed on the commit that separates the two groups, i.e.  on ‘HEAD’.
The commits above it have not been applied yet, while the ‘HEAD’ and the
commits below it have already been applied.  In between these two groups
of applied and yet-to-be applied commits, there sometimes is a commit
which has been dropped.

Each commit is prefixed with a word and these words are additionally
shown in different colors to indicate the status of the commits.

The following colors are used:

   • Yellow commits have not been applied yet.

   • Gray commits have already been applied.

   • The blue commit is the ‘HEAD’ commit.

   • The green commit is the commit the rebase sequence stopped at.  If
     this is the same commit as ‘HEAD’ (e.g.  because you haven’t done
     anything yet after rebase stopped at the commit, then this commit
     is shown in blue, not green).  There can only be a green *and* a
     blue commit at the same time, if you create one or more new commits
     after rebase stops at a commit.

   • Red commits have been dropped.  They are shown for reference only,
     e.g.  to make it easier to diff.

Of course these colors are subject to the color-theme in use.

The following words are used:

   • Commits prefixed with ‘pick’, ‘reword’, ‘edit’, ‘squash’, and
     ‘fixup’ have not been applied yet.  These words have the same
     meaning here as they do in the buffer used to edit the rebase
     sequence.  See *note Editing Rebase Sequences::.  When the
     ‘--rebase-merges’ option was specified, ‘reset’, ‘label’, and
     ‘merge’ lines may also be present.

   • Commits prefixed with ‘done’ and ‘onto’ have already been applied.
     It is possible for such a commit to be the ‘HEAD’, in which case it
     is blue.  Otherwise it is grey.

        • The commit prefixed with ‘onto’ is the commit on top of which
          all the other commits are being re-applied.  This commit
          itself did not have to be re-applied, it is the commit rebase
          did rewind to before starting to re-apply other commits.

        • Commits prefixed with ‘done’ have already been re-applied.
          This includes commits that have been re-applied but also new
          commits that you have created during the rebase.

   • All other commits, those not prefixed with any of the above words,
     are in some way related to the commit at which rebase stopped.

     To determine whether a commit is related to the stopped-at commit
     their hashes, trees and patch-ids (1) are being compared.  The
     commit message is not used for this purpose.

     Generally speaking commits that are related to the stopped-at
     commit can have any of the used colors, though not all color/word
     combinations are possible.

     Words used for stopped-at commits are:

        • When a commit is prefixed with ‘void’, then that indicates
          that Magit knows for sure that all the changes in that commit
          have been applied using several new commits.  This commit is
          no longer reachable from ‘HEAD’, and it also isn’t one of the
          commits that will be applied when resuming the session.

        • When a commit is prefixed with ‘join’, then that indicates
          that the rebase sequence stopped at that commit due to a
          conflict - you now have to join (merge) the changes with what
          has already been applied.  In a sense this is the commit
          rebase stopped at, but while its effect is already in the
          index and in the worktree (with conflict markers), the commit
          itself has not actually been applied yet (it isn’t the
          ‘HEAD’).  So it is shown in yellow, like the other commits
          that still have to be applied.

        • When a commit is prefixed with ‘stop’ or a _blue_ or _green_
          ‘same’, then that indicates that rebase stopped at this
          commit, that it is still applied or has been applied again,
          and that at least its patch-id is unchanged.

             • When a commit is prefixed with ‘stop’, then that
               indicates that rebase stopped at that commit because you
               requested that earlier, and its patch-id is unchanged.
               It might even still be the exact same commit.

             • When a commit is prefixed with a _blue_ or _green_
               ‘same’, then that indicates that while its tree or hash
               changed, its patch-id did not.  If it is blue, then it is
               the ‘HEAD’ commit (as always for blue).  When it is
               green, then it no longer is ‘HEAD’ because other commit
               have been created since (but before continuing the
               rebase).

        • When a commit is prefixed with ‘goal’, a _yellow_ ‘same,’ or
          ‘work’, then that indicates that rebase applied that commit
          but that you then reset ‘HEAD’ to an earlier commit (likely to
          split it up into multiple commits), and that there are some
          uncommitted changes remaining which likely (but not
          necessarily) originate from that commit.

             • When a commit is prefixed with ‘goal’, then that
               indicates that it is still possible to create a new
               commit with the exact same tree (the "goal") without
               manually editing any files, by committing the index, or
               by staging all changes and then committing that.  This is
               the case when the original tree still exists in the index
               or worktree in untainted form.

             • When a commit is prefixed with a yellow ‘same’, then that
               indicates that it is no longer possible to create a
               commit with the exact same tree, but that it is still
               possible to create a commit with the same patch-id.  This
               would be the case if you created a new commit with other
               changes, but the changes from the original commit still
               exist in the index or working tree in untainted form.

             • When a commit is prefixed with ‘work’, then that
               indicates that you reset ‘HEAD’ to an earlier commit, and
               that there are some staged and/or unstaged changes
               (likely, but not necessarily) originating from that
               commit.  However it is no longer possible to create a new
               commit with the same tree or at least the same patch-id
               because you have already made other changes.

        • When a commit is prefixed with ‘poof’ or ‘gone’, then that
          indicates that rebase applied that commit but that you then
          reset ‘HEAD’ to an earlier commit (likely to split it up into
          multiple commits), and that there are no uncommitted changes.

             • When a commit is prefixed with ‘poof’, then that
               indicates that it is no longer reachable from ‘HEAD’, but
               that it has been replaced with one or more commits, which
               together have the exact same effect.

             • When a commit is prefixed with ‘gone’, then that
               indicates that it is no longer reachable from ‘HEAD’ and
               that we also cannot determine whether its changes are
               still in effect in one or more new commits.  They might
               be, but if so, then there must also be other changes
               which makes it impossible to know for sure.

Do not worry if you do not fully understand the above.  That’s okay, you
will acquire a good enough understanding through practice.

For other sequence operations such as cherry-picking, a similar section
is displayed, but they lack some of the features described above, due to
limitations in the git commands used to implement them.  Most
importantly these sequences only support "picking" a commit but not
other actions such as "rewording", and they do not keep track of the
commits which have already been applied.

   ---------- Footnotes ----------

   (1) The patch-id is a hash of the _changes_ introduced by a commit.
It differs from the hash of the commit itself, which is a hash of the
result of applying that change (i.e.  the resulting trees and blobs) as
well as author and committer information, the commit message, and the
hashes of the parents of the commit.  The patch-id hash on the other
hand is created only from the added and removed lines, even line numbers
and whitespace changes are ignored when calculating this hash.  The
patch-ids of two commits can be used to answer the question "Do these
commits make the same change?".


File: magit.ja.info,  Node: Cherry Picking,  Next: Resetting,  Prev: Rebasing,  Up: Manipulating

6.10 Cherry Picking
===================

こちらもご覧下さい *note (gitman)git-cherry-pick::

‘A’     (‘magit-cherry-pick’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

When no cherry-pick or revert is in progress, then the transient
features the following suffix commands.

‘A A’     (‘magit-cherry-copy’)

     This command copies COMMITS from another branch onto the current
     branch.  If the region selects multiple commits, then those are
     copied, without prompting.  Otherwise the user is prompted for a
     commit or range, defaulting to the commit at point.

‘A a’     (‘magit-cherry-apply’)

     This command applies the changes in COMMITS from another branch
     onto the current branch.  If the region selects multiple commits,
     then those are used, without prompting.  Otherwise the user is
     prompted for a commit or range, defaulting to the commit at point.

     This command also has a top-level binding, which can be invoked
     without using the transient by typing ‘a’ at the top-level.

The following commands not only apply some commits to some branch, but
also remove them from some other branch.  The removal is performed using
either ‘git-update-ref’ or if necessary ‘git-rebase’.  Both applying
commits as well as removing them using ‘git-rebase’ can lead to
conflicts.  If that happens, then these commands abort and you not only
have to resolve the conflicts but also finish the process the same way
you would have to if these commands didn’t exist at all.

‘A h’     (‘magit-cherry-harvest’)

     This command moves the selected COMMITS that must be located on
     another BRANCH onto the current branch instead, removing them from
     the former.  When this command succeeds, then the same branch is
     current as before.

     Applying the commits on the current branch or removing them from
     the other branch can lead to conflicts.  When that happens, then
     this command stops and you have to resolve the conflicts and then
     finish the process manually.

‘A d’     (‘magit-cherry-donate’)

     This command moves the selected COMMITS from the current branch
     onto another existing BRANCH, removing them from the former.  When
     this command succeeds, then the same branch is current as before.

     Applying the commits on the other branch or removing them from the
     current branch can lead to conflicts.  When that happens, then this
     command stops and you have to resolve the conflicts and then finish
     the process manually.

‘A n’     (‘magit-cherry-spinout’)

     This command moves the selected COMMITS from the current branch
     onto a new branch BRANCH, removing them from the former.  When this
     command succeeds, then the same branch is current as before.

     Applying the commits on the other branch or removing them from the
     current branch can lead to conflicts.  When that happens, then this
     command stops and you have to resolve the conflicts and then finish
     the process manually.

‘A s’     (‘magit-cherry-spinoff’)

     This command moves the selected COMMITS from the current branch
     onto a new branch BRANCH, removing them from the former.  When this
     command succeeds, then the new branch is checked out.

     Applying the commits on the other branch or removing them from the
     current branch can lead to conflicts.  When that happens, then this
     command stops and you have to resolve the conflicts and then finish
     the process manually.

When a cherry-pick or revert is in progress, then the transient instead
features the following suffix commands.

‘A A’     (‘magit-sequence-continue’)

     Resume the current cherry-pick or revert sequence.

‘A s’     (‘magit-sequence-skip’)

     Skip the stopped at commit during a cherry-pick or revert sequence.

‘A a’     (‘magit-sequence-abort’)

     Abort the current cherry-pick or revert sequence.  This discards
     all changes made since the sequence started.

* Menu:

* Reverting::


File: magit.ja.info,  Node: Reverting,  Up: Cherry Picking

6.10.1 Reverting
----------------

‘V’     (‘magit-revert’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

When no cherry-pick or revert is in progress, then the transient
features the following suffix commands.

‘V V’     (‘magit-revert-and-commit’)

     Revert a commit by creating a new commit.  Prompt for a commit,
     defaulting to the commit at point.  If the region selects multiple
     commits, then revert all of them, without prompting.

‘V v’     (‘magit-revert-no-commit’)

     Revert a commit by applying it in reverse to the working tree.
     Prompt for a commit, defaulting to the commit at point.  If the
     region selects multiple commits, then revert all of them, without
     prompting.

When a cherry-pick or revert is in progress, then the transient instead
features the following suffix commands.

‘V A’     (‘magit-sequence-continue’)

     Resume the current cherry-pick or revert sequence.

‘V s’     (‘magit-sequence-skip’)

     Skip the stopped at commit during a cherry-pick or revert sequence.

‘V a’     (‘magit-sequence-abort’)

     Abort the current cherry-pick or revert sequence.  This discards
     all changes made since the sequence started.


File: magit.ja.info,  Node: Resetting,  Next: Stashing,  Prev: Cherry Picking,  Up: Manipulating

6.11 Resetting
==============

こちらもご覧下さい *note (gitman)git-reset::

‘x’     (‘magit-reset-quickly’)

     Reset the ‘HEAD’ and index to some commit read from the user and
     defaulting to the commit at point, and possibly also reset the
     working tree.  With a prefix argument reset the working tree
     otherwise don’t.

‘X m’     (‘magit-reset-mixed’)

     Reset the ‘HEAD’ and index to some commit read from the user and
     defaulting to the commit at point.  The working tree is kept as-is.

‘X s’     (‘magit-reset-soft’)

     Reset the ‘HEAD’ to some commit read from the user and defaulting
     to the commit at point.  The index and the working tree are kept
     as-is.

‘X h’     (‘magit-reset-hard’)

     Reset the ‘HEAD’, index, and working tree to some commit read from
     the user and defaulting to the commit at point.

‘X k’     (‘magit-reset-keep’)

     Reset the ‘HEAD’, index, and working tree to some commit read from
     the user and defaulting to the commit at point.  Uncommitted
     changes are kept as-is.

‘X i’     (‘magit-reset-index’)

     Reset the index to some commit read from the user and defaulting to
     the commit at point.  Keep the ‘HEAD’ and working tree as-is, so if
     the commit refers to the ‘HEAD’, then this effectively unstages all
     changes.

‘X w’     (‘magit-reset-worktree’)

     Reset the working tree to some commit read from the user and
     defaulting to the commit at point.  Keep the ‘HEAD’ and index
     as-is.

‘X f’     (‘magit-file-checkout’)

     Update file in the working tree and index to the contents from a
     revision.  Both the revision and file are read from the user.


File: magit.ja.info,  Node: Stashing,  Prev: Resetting,  Up: Manipulating

6.12 Stashing
=============

こちらもご覧下さい *note (gitman)git-stash::

‘z’     (‘magit-stash’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

‘z z’     (‘magit-stash-both’)

     Create a stash of the index and working tree.  Untracked files are
     included according to infix arguments.  One prefix argument is
     equivalent to ‘--include-untracked’ while two prefix arguments are
     equivalent to ‘--all’.

‘z i’     (‘magit-stash-index’)

     Create a stash of the index only.  Unstaged and untracked changes
     are not stashed.

‘z w’     (‘magit-stash-worktree’)

     Create a stash of unstaged changes in the working tree.  Untracked
     files are included according to infix arguments.  One prefix
     argument is equivalent to ‘--include-untracked’ while two prefix
     arguments are equivalent to ‘--all’.

‘z x’     (‘magit-stash-keep-index’)

     Create a stash of the index and working tree, keeping index intact.
     Untracked files are included according to infix arguments.  One
     prefix argument is equivalent to ‘--include-untracked’ while two
     prefix arguments are equivalent to ‘--all’.

‘z Z’     (‘magit-snapshot-both’)

     Create a snapshot of the index and working tree.  Untracked files
     are included according to infix arguments.  One prefix argument is
     equivalent to ‘--include-untracked’ while two prefix arguments are
     equivalent to ‘--all’.

‘z I’     (‘magit-snapshot-index’)

     Create a snapshot of the index only.  Unstaged and untracked
     changes are not stashed.

‘z W’     (‘magit-snapshot-worktree’)

     Create a snapshot of unstaged changes in the working tree.
     Untracked files are included according to infix arguments.  One
     prefix argument is equivalent to ‘--include-untracked’ while two
     prefix arguments are equivalent to ‘--all’-.

‘z a’     (‘magit-stash-apply’)

     Apply a stash to the working tree.  Try to preserve the stash
     index.  If that fails because there are staged changes, apply
     without preserving the stash index.

‘z p’     (‘magit-stash-pop’)

     Apply a stash to the working tree and remove it from stash list.
     Try to preserve the stash index.  If that fails because there are
     staged changes, apply without preserving the stash index and forgo
     removing the stash.

‘z k’     (‘magit-stash-drop’)

     Remove a stash from the stash list.  When the region is active,
     offer to drop all contained stashes.

‘z v’     (‘magit-stash-show’)

     バッファ内のstashのすべての差分を表示します。

‘z b’     (‘magit-stash-branch’)

     Create and checkout a new BRANCH from STASH.  The branch starts at
     the commit that was current when the stash was created.

‘z B’     (‘magit-stash-branch-here’)

     Create and checkout a new BRANCH using ‘magit-branch’ with the
     current branch or ‘HEAD’ as the starting-point.  Then apply STASH,
     dropping it if it applies cleanly.

‘z f’     (‘magit-stash-format-patch’)

     Create a patch from STASH.

‘k’     (‘magit-stash-clear’)

     Remove all stashes saved in REF’s reflog by deleting REF.

‘z l’     (‘magit-stash-list’)

     List all stashes in a buffer.

 -- User Option: magit-stashes-margin

     This option specifies whether the margin is initially shown in
     stashes buffers and how it is formatted.

     値の形式は‘(INIT STYLE WIDTH AUTHOR AUTHOR-WIDTH)’です。

        • INITがnil以外の場合、マージン(margin)が最初に表示されます。

        • STYLEは、作成者(author)またはコミッター(committer)の日付をフォ
          ーマットする方法を制御します。‘age’(コミットの経過時間を示す
          )または‘age-abbreviated’(時間単位を文字に短縮する)または実際の
          日付を表す文字列(‘format-time-string’に適しています)のいずれか
          になります。オプション‘magit-log-margin-show-committer-date’は
          、表示される日付を制御します。

        • WIDTHは、マージンの幅を制御します。これは上位互換性のために存
          在し、現在値を変更すべきではありません。

        • AUTHORは、作成者の名前もデフォルトで表示されるかどうかを制御し
          ます。

        • AUTHOR-WIDTHは整数である必要があります。作成者の名前が表示され
          ている場合、これはそのために使用されるスペース(空き)の量を指定
          します。


File: magit.ja.info,  Node: Transferring,  Next: Miscellaneous,  Prev: Manipulating,  Up: Top

7 Transferring
**************

* Menu:

* Remotes::
* Fetching::
* Pulling::
* Pushing::
* Plain Patches::
* Maildir Patches::


File: magit.ja.info,  Node: Remotes,  Next: Fetching,  Up: Transferring

7.1 Remotes
===========

* Menu:

* Remote Commands::
* Remote Git Variables::


File: magit.ja.info,  Node: Remote Commands,  Next: Remote Git Variables,  Up: Remotes

7.1.1 Remote Commands
---------------------

The transient prefix command ‘magit-remote’ is used to add remotes and
to make changes to existing remotes.  This command only deals with
remotes themselves, not with branches or the transfer of commits.  Those
features are available from separate transient commands.

こちらもご覧下さい *note (gitman)git-remote::

‘M’     (‘magit-remote’)

     この一時的(transient)前置(prefix)コマンドは、それに続く後置
     (suffix)コマンドを結びつけ、後置(suffix)コマンドが呼び出されるまで
     一時バッファ(temporary buffer)に表示します。

     By default it also binds and displays the values of some
     remote-related Git variables and allows changing their values.

 -- User Option: magit-remote-direct-configure

     This option controls whether remote-related Git variables are
     accessible directly from the transient ‘magit-remote’.

     If ‘t’ (the default) and a local branch is checked out, then
     ‘magit-remote’ features the variables for the upstream remote of
     that branch, or if ‘HEAD’ is detached, for ‘origin’, provided that
     exists.

     If ‘nil’, then ‘magit-remote-configure’ has to be used to do so.

‘M C’     (‘magit-remote-configure’)

     This transient prefix command binds commands that set the value of
     remote-related variables and displays them in a temporary buffer
     until the transient is exited.

     With a prefix argument, this command always prompts for a remote.

     Without a prefix argument this depends on whether it was invoked as
     a suffix of ‘magit-remote’ and on the
     ‘magit-remote-direct-configure’ option.  If ‘magit-remote’ already
     displays the variables for the upstream, then it does not make
     sense to invoke another transient that displays them for the same
     remote.  In that case this command prompts for a remote.

The variables are described in *note Remote Git Variables::.

‘M a’     (‘magit-remote-add’)

     This command add a remote and fetches it.  The remote name and url
     are read in the minibuffer.

‘M r’     (‘magit-remote-rename’)

     This command renames a remote.  Both the old and the new names are
     read in the minibuffer.

‘M u’     (‘magit-remote-set-url’)

     This command changes the url of a remote.  Both the remote and the
     new url are read in the minibuffer.

‘M k’     (‘magit-remote-remove’)

     This command deletes a remote, read in the minibuffer.

‘M p’     (‘magit-remote-prune’)

     This command removes stale remote-tracking branches for a remote
     read in the minibuffer.

‘M P’     (‘magit-remote-prune-refspecs’)

     This command removes stale refspecs for a remote read in the
     minibuffer.

     A refspec is stale if there no longer exists at least one branch on
     the remote that would be fetched due to that refspec.  A stale
     refspec is problematic because its existence causes Git to refuse
     to fetch according to the remaining non-stale refspecs.

     If only stale refspecs remain, then this command offers to either
     delete the remote or to replace the stale refspecs with the default
     refspec ("+refs/heads/*:refs/remotes/REMOTE/*").

     This command also removes the remote-tracking branches that were
     created due to the now stale refspecs.  Other stale branches are
     not removed.

 -- User Option: magit-remote-add-set-remote.pushDefault

     This option controls whether the user is asked whether they want to
     set ‘remote.pushDefault’ after adding a remote.

     If ‘ask’, then users is always ask.  If ‘ask-if-unset’, then the
     user is only if the variable isn’t set already.  If ‘nil’, then the
     user isn’t asked and the variable isn’t set.  If the value is a
     string, then the variable is set without the user being asked,
     provided that the name of the added remote is equal to that string
     and the variable isn’t already set.


File: magit.ja.info,  Node: Remote Git Variables,  Prev: Remote Commands,  Up: Remotes

7.1.2 Remote Git Variables
--------------------------

These variables can be set from the transient prefix command
‘magit-remote-configure’.  By default they can also be set from
‘magit-remote’.  See *note Remote Commands::.

 -- Variable: remote.NAME.url

     This variable specifies the url of the remote named NAME.  It can
     have multiple values.

 -- Variable: remote.NAME.fetch

     The refspec used when fetching from the remote named NAME.  It can
     have multiple values.

 -- Variable: remote.NAME.pushurl

     This variable specifies the url used for fetching from the remote
     named NAME.  If it is not specified, then ‘remote.NAME.url’ is used
     instead.  It can have multiple values.

 -- Variable: remote.NAME.push

     The refspec used when pushing to the remote named NAME.  It can
     have multiple values.

 -- Variable: remote.NAME.tagOpts

     This variable specifies what tags are fetched by default.  If the
     value is ‘--no-tags’ then no tags are fetched.  If the value is
     ‘--tags’, then all tags are fetched.  If this variable has no
     value, then only tags are fetched that are reachable from fetched
     branches.


File: magit.ja.info,  Node: Fetching,  Next: Pulling,  Prev: Remotes,  Up: Transferring

7.2 Fetching
============

こちらもご覧下さい *note (gitman)git-fetch:: For information about the
upstream and the push-remote, see *note The Two Remotes::.

‘f’     (‘magit-fetch’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

‘f p’     (‘magit-fetch-from-pushremote’)

     This command fetches from the current push-remote.

     With a prefix argument or when the push-remote is either not
     configured or unusable, then let the user first configure the
     push-remote.

‘f u’     (‘magit-fetch-from-upstream’)

     This command fetch from the upstream of the current branch.

     If the upstream is configured for the current branch and names an
     existing remote, then use that.  Otherwise try to use another
     remote: If only a single remote is configured, then use that.
     Otherwise if a remote named "origin" exists, then use that.

     If no remote can be determined, then this command is not available
     from the ‘magit-fetch’ transient prefix and invoking it directly
     results in an error.

‘f e’     (‘magit-fetch-other’)

     This command fetch from a repository read from the minibuffer.

‘f o’     (‘magit-fetch-branch’)

     This command fetches a branch from a remote, both of which are read
     from the minibuffer.

‘f r’     (‘magit-fetch-refspec’)

     This command fetches from a remote using an explicit refspec, both
     of which are read from the minibuffer.

‘f a’     (‘magit-fetch-all’)

     This command fetches from all remotes.

‘f m’     (‘magit-submodule-fetch’)

     This command fetches all submodules.  With a prefix argument it
     fetches all remotes of all submodules.

 -- User Option: magit-pull-or-fetch

     By default fetch and pull commands are available from separate
     transient prefix command.  Setting this to ‘t’ adds some (but not
     all) of the above suffix commands to the ‘magit-pull’ transient.

     If you do that, then you might also want to change the key binding
     for these prefix commands, e.g.:

          (setq magit-pull-or-fetch t)
          (define-key magit-mode-map "f" 'magit-pull) ; was magit-fetch
          (define-key magit-mode-map "F" nil)         ; was magit-pull


File: magit.ja.info,  Node: Pulling,  Next: Pushing,  Prev: Fetching,  Up: Transferring

7.3 Pulling
===========

こちらもご覧下さい *note (gitman)git-pull:: For information about the
upstream and the push-remote, see *note The Two Remotes::.

‘F’     (‘magit-pull’)

     この一時的(transient)前置(prefix)コマンドは、それに続く後置
     (suffix)コマンドを結びつけ、後置(suffix)コマンドが呼び出されるまで
     一時バッファ(temporary buffer)に表示します。

‘F p’     (‘magit-pull-from-pushremote’)

     This command pulls from the push-remote of the current branch.

     With a prefix argument or when the push-remote is either not
     configured or unusable, then let the user first configure the
     push-remote.

‘F u’     (‘magit-pull-from-upstream’)

     This command pulls from the upstream of the current branch.

     With a prefix argument or when the upstream is either not
     configured or unusable, then let the user first configure the
     upstream.

‘F e’     (‘magit-pull-branch’)

     This command pulls from a branch read in the minibuffer.


File: magit.ja.info,  Node: Pushing,  Next: Plain Patches,  Prev: Pulling,  Up: Transferring

7.4 Pushing
===========

こちらもご覧下さい *note (gitman)git-push:: For information about the
upstream and the push-remote, see *note The Two Remotes::.

‘P’     (‘magit-push’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

‘P p’     (‘magit-push-current-to-pushremote’)

     This command pushes the current branch to its push-remote.

     With a prefix argument or when the push-remote is either not
     configured or unusable, then let the user first configure the
     push-remote.

‘P u’     (‘magit-push-current-to-upstream’)

     This command pushes the current branch to its upstream branch.

     With a prefix argument or when the upstream is either not
     configured or unusable, then let the user first configure the
     upstream.

‘P e’     (‘magit-push-current’)

     This command pushes the current branch to a branch read in the
     minibuffer.

‘P o’     (‘magit-push-other’)

     This command pushes an arbitrary branch or commit somewhere.  Both
     the source and the target are read in the minibuffer.

‘P r’     (‘magit-push-refspecs’)

     This command pushes one or multiple refspecs to a remote, both of
     which are read in the minibuffer.

     To use multiple refspecs, separate them with commas.  Completion is
     only available for the part before the colon, or when no colon is
     used.

‘P m’     (‘magit-push-matching’)

     This command pushes all matching branches to another repository.

     If only one remote exists, then push to that.  Otherwise prompt for
     a remote, offering the remote configured for the current branch as
     default.

‘P t’     (‘magit-push-tags’)

     This command pushes all tags to another repository.

     If only one remote exists, then push to that.  Otherwise prompt for
     a remote, offering the remote configured for the current branch as
     default.

‘P T’     (‘magit-push-tag’)

     This command pushes a tag to another repository.

One of the infix arguments, ‘--force-with-lease’, deserves a word of
caution.  It is passed without a value, which means "permit a force push
as long as the remote-tracking branches match their counterparts on the
remote end".  If you’ve set up a tool to do automatic fetches (Magit
itself does not provide such functionality), using ‘--force-with-lease’
can be dangerous because you don’t actually control or know the state of
the remote-tracking refs.  In that case, you should consider setting
‘push.useForceIfIncludes’ to ‘true’ (available since Git 2.30).

Two more push commands exist, which by default are not available from
the push transient.  See their doc-strings for instructions on how to
add them to the transient.

 -- Command: magit-push-implicitly args

     This command pushes somewhere without using an explicit refspec.

     This command simply runs ‘git push -v [ARGS]’.  ARGS are the infix
     arguments.  No explicit refspec arguments are used.  Instead the
     behavior depends on at least these Git variables: ‘push.default’,
     ‘remote.pushDefault’, ‘branch.<branch>.pushRemote’,
     ‘branch.<branch>.remote’, ‘branch.<branch>.merge’, and
     ‘remote.<remote>.push’.

     If you add this suffix to a transient prefix without explicitly
     specifying the description, then an attempt is made to predict what
     this command will do.  For example:

          (transient-insert-suffix 'magit-push \"p\"
            '(\"i\" magit-push-implicitly))"

 -- Command: magit-push-to-remote remote args

     This command pushes to the remote REMOTE without using an explicit
     refspec.  The remote is read in the minibuffer.

     This command simply runs ‘git push -v [ARGS] REMOTE’.  ARGS are the
     infix arguments.  No refspec arguments are used.  Instead the
     behavior depends on at least these Git variables: ‘push.default’,
     ‘remote.pushDefault’, ‘branch.<branch>.pushRemote’,
     ‘branch.<branch>.remote’, ‘branch.<branch>.merge’, and
     ‘remote.<remote>.push’.


File: magit.ja.info,  Node: Plain Patches,  Next: Maildir Patches,  Prev: Pushing,  Up: Transferring

7.5 Plain Patches
=================

‘W’     (‘magit-patch’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

‘W c’     (‘magit-patch-create’)

     This command creates patches for a set commits.  If the region
     marks several commits, then it creates patches for all of them.
     Otherwise it functions as a transient prefix command, which
     features several infix arguments and binds itself as a suffix
     command.  When this command is invoked as a suffix of itself, then
     it creates a patch using the specified infix arguments.

‘w a’     (‘magit-patch-apply’)

     This command applies a patch.  This is a transient prefix command,
     which features several infix arguments and binds itself as a suffix
     command.  When this command is invoked as a suffix of itself, then
     it applies a patch using the specified infix arguments.

‘W s’     (‘magit-patch-save’)

     This command creates a patch from the current diff.

     Inside ‘magit-diff-mode’ or ‘magit-revision-mode’ buffers, ‘C-x
     C-w’ is also bound to this command.

It is also possible to save a plain patch file by using ‘C-x C-w’ inside
a ‘magit-diff-mode’ or ‘magit-revision-mode’ buffer.


File: magit.ja.info,  Node: Maildir Patches,  Prev: Plain Patches,  Up: Transferring

7.6 Maildir Patches
===================

こちらもご覧下さい *note (gitman)git-am:: and *note (gitman)git-apply::

‘w’     (‘magit-am’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

‘w w’     (‘magit-am-apply-patches’)

     This command applies one or more patches.  If the region marks
     files, then those are applied as patches.  Otherwise this command
     reads a file-name in the minibuffer, defaulting to the file at
     point.

‘w m’     (‘magit-am-apply-maildir’)

     This command applies patches from a maildir.

‘w a’     (‘magit-patch-apply’)

     This command applies a plain patch.  For a longer description see
     *note Plain Patches::.  This command is only available from the
     ‘magit-am’ transient for historic reasons.

When an "am" operation is in progress, then the transient instead
features the following suffix commands.

‘w w’     (‘magit-am-continue’)

     This command resumes the current patch applying sequence.

‘w s’     (‘magit-am-skip’)

     This command skips the stopped at patch during a patch applying
     sequence.

‘w a’     (‘magit-am-abort’)

     This command aborts the current patch applying sequence.  This
     discards all changes made since the sequence started.


File: magit.ja.info,  Node: Miscellaneous,  Next: Customizing,  Prev: Transferring,  Up: Top

8 Miscellaneous
***************

* Menu:

* Tagging::
* Notes::
* Submodules::
* Subtree::
* Worktree::
* Common Commands::
* Wip Modes::
* Commands for Buffers Visiting Files::
* Minor Mode for Buffers Visiting Blobs::


File: magit.ja.info,  Node: Tagging,  Next: Notes,  Up: Miscellaneous

8.1 Tagging
===========

こちらもご覧下さい *note (gitman)git-tag::

‘t’     (‘magit-tag’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

‘t t’     (‘magit-tag-create’)

     このコマンドは、REV@で指定されたNAMEを使用して新しいタグを作成しま
     す。プレフィックス引数を使用して、注釈付きタグ(annotated tag)を作成
     します。

‘t r’     (‘magit-tag-release’)

     このコマンドはリリースタグを作成します。リリースタグが
     ‘magit-release-tag-regexp’と一致することを前提としています。

     最初に、既存の最も最近のタグを初期入力として表示して新しいタグの名
     前の入力を求め、バージョン文字列の部分をインクリメントするようにユ
     ーザーに任せます。 型破りなリリースタグまたはバージョン番号(例:
     ‘v1.2.3-custom.1’)を使用する場合、あなたは
     ‘magit-release-tag-regexp’と‘magit-tag-version-regexp-alist’変数を
     設定できます。

     ‘--annotate’が有効になっている場合は、新しいタグのメッセージ入力を
     求められます。提案されたタグメッセージは、対応するバージョン文字列
     を含み、その代わりに新しいバージョン文字列を使用するという条件で、
     最も最近のタグのメッセージに基づいています。それ以外の場合は、例え
     ば、TAG "v1.2.3"と"/path/to/foo-bar"のようなリポジトリであれば
     ."Foo-Bar 1.2.3"のようなものを提案します。

‘t k’     (‘magit-tag-delete’)

     This command deletes one or more tags.  If the region marks
     multiple tags (and nothing else), then it offers to delete those.
     Otherwise, it prompts for a single tag to be deleted, defaulting to
     the tag at point.

‘t p’     (‘magit-tag-prune’)

     このコマンドは、REMOTEからローカルに欠落しているタグを削除すること
     を提案します。その逆も同様です。


File: magit.ja.info,  Node: Notes,  Next: Submodules,  Prev: Tagging,  Up: Miscellaneous

8.2 Notes
=========

こちらもご覧下さい *note (gitman)git-notes::.

‘T’     (‘magit-notes’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

‘T T’     (‘magit-notes-edit’)

     コミットに添付されたnoteを編集します。デフォルトでは、その時点での
     コミットになります。

     デフォルトでは、Git変数‘core.notesRef’または "refs/notes/commits"の
     値が未定義の場合は、その値を使用します。

‘T r’     (‘magit-notes-remove’)

     Remove the note attached to a commit, defaulting to the commit at
     point.

     デフォルトでは、Git変数‘core.notesRef’または "refs/notes/commits"の
     値が未定義の場合は、その値を使用します。

‘T p’     (‘magit-notes-prune’)

     Remove notes about unreachable commits.

1つのnote refを別のnote refにマージすることが可能です。 その結果、一時的
なワークツリー ".git/NOTES_MERGE_WORKTREE" で解決する必要のある競合が発
生する可能性があります。

‘T m’     (‘magit-notes-merge’)

     Merge the notes of a ref read from the user into the current notes
     ref.  The current notes ref is the value of Git variable
     ‘core.notesRef’ or "refs/notes/commits" if that is undefined.

When a notes merge is in progress then the transient features the
following suffix commands, instead of those listed above.

‘T c’     (‘magit-notes-merge-commit’)

     Commit the current notes ref merge, after manually resolving
     conflicts.

‘T a’     (‘magit-notes-merge-abort’)

     Abort the current notes ref merge.

The following variables control what notes reference ‘magit-notes-*’,
‘git notes’ and ‘git show’ act on and display.  Both the local and
global values are displayed and can be modified.

 -- Variable: core.notesRef

     This variable specifies the notes ref that is displayed by default
     and which commands act on by default.

 -- Variable: notes.displayRef

     This variable specifies additional notes ref to be displayed in
     addition to the ref specified by ‘core.notesRef’.  It can have
     multiple values and may end with ‘*’ to display all refs in the
     ‘refs/notes/’ namespace (or ‘**’ if some names contain slashes).


File: magit.ja.info,  Node: Submodules,  Next: Subtree,  Prev: Notes,  Up: Miscellaneous

8.3 Submodules
==============

こちらもご覧下さい *note (gitman)git-submodule::

* Menu:

* Listing Submodules::
* 一時的サブモジュール::


File: magit.ja.info,  Node: Listing Submodules,  Next: 一時的サブモジュール,  Up: Submodules

8.3.1 Listing Submodules
------------------------

The command ‘magit-list-submodules’ displays a list of the current
repository’s submodules in a separate buffer.  It’s also possible to
display information about submodules directly in the status buffer of
the super-repository by adding ‘magit-insert-modules’ to the hook
‘magit-status-sections-hook’ as described in *note Status Module
Sections::.

 -- Command: magit-list-submodules

     This command displays a list of the current repository’s submodules
     in a separate buffer.

     It can be invoked by pressing ‘RET’ on the section titled
     "Modules".

 -- User Option: magit-submodule-list-columns

     This option controls what columns are displayed by the command
     ‘magit-list-submodules’ and how they are displayed.

     各要素の形式は‘(HEADER WIDTH FORMAT PROPS)’です。

     HEADERは、ヘッダーに表示される文字列です。WIDTHは、列の幅です。
     FORMATは、1つの引数とリポジトリID(通常はそのベース名)と作業ツリーの
     最上位に結び付けられたされた‘default-directory’を使用して呼び出され
     る関数です。挿入する文字列またはnilを返す必要があります。PROPSは、
     キー‘:right-align’と‘:pad-right’‘：right-align’をサポートするリスト
     です。


File: magit.ja.info,  Node: 一時的サブモジュール,  Prev: Listing Submodules,  Up: Submodules

8.3.2 一時的サブモジュール
--------------------------

‘o’     (‘magit-submodule’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

Some of the below commands default to act on the modules that are
selected using the region.  For brevity their description talk about
"the selected modules", but if no modules are selected, then they act on
the current module instead, or if point isn’t on a module, then the read
a single module to act on.  With a prefix argument these commands ignore
the selection and the current module and instead act on all suitable
modules.

‘o a’     (‘magit-submodule-add’)

     This commands adds the repository at URL as a module.  Optional
     PATH is the path to the module relative to the root of the
     super-project.  If it is nil then the path is determined based on
     URL.

‘o r’     (‘magit-submodule-register’)

     This command registers the selected modules by copying their urls
     from ".gitmodules" to "$GIT_DIR/config".  These values can then be
     edited before running ‘magit-submodule-populate’.  If you don’t
     need to edit any urls, then use the latter directly.

‘o p’     (‘magit-submodule-populate’)

     This command creates the working directory or directories of the
     selected modules, checking out the recorded commits.

‘o u’     (‘magit-submodule-update’)

     This command updates the selected modules checking out the recorded
     commits.

‘o s’     (‘magit-submodule-synchronize’)

     This command synchronizes the urls of the selected modules, copying
     the values from ".gitmodules" to the ".git/config" of the
     super-project as well those of the modules.

‘o d’     (‘magit-submodule-unpopulate’)

     This command removes the working directory of the selected modules.

‘o l’     (‘magit-list-submodules’)

     This command displays a list of the current repository’s modules.

‘o f’     (‘magit-fetch-modules’)

     This command fetches all modules.

     Option ‘magit-fetch-modules-jobs’ controls how many submodules are
     being fetched in parallel.  Also fetch the super-repository,
     because ‘git fetch’ does not support not doing that.  With a prefix
     argument fetch all remotes.


File: magit.ja.info,  Node: Subtree,  Next: Worktree,  Prev: Submodules,  Up: Miscellaneous

8.4 Subtree
===========

こちらもご覧下さい *note (gitman)git-subtree::

‘O’     (‘magit-subtree’)

     This transient prefix command binds the two sub-transients; one for
     importing a subtree and one for exporting a subtree.

‘O i’     (‘magit-subtree-import’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

     The suffixes of this command import subtrees.

     If the ‘--prefix’ argument is set, then the suffix commands use
     that prefix without prompting the user.  If it is unset, then they
     read the prefix in the minibuffer.

‘O i a’     (‘magit-subtree-add’)

     This command adds COMMIT from REPOSITORY as a new subtree at
     PREFIX.

‘O i c’     (‘magit-subtree-add-commit’)

     This command add COMMIT as a new subtree at PREFIX.

‘O i m’     (‘magit-subtree-merge’)

     This command merges COMMIT into the PREFIX subtree.

‘O i f’     (‘magit-subtree-pull’)

     This command pulls COMMIT from REPOSITORY into the PREFIX subtree.

‘O e’     (‘magit-subtree-export’)

     この一時的(transient)な前置(prefix)スコマンドは、続く後置(suffix)コ
     マンドを適切な中置引数(infix arguments)とともに結び付け、後置
     (suffix)が呼び出されるまで一時バッファ(temporary buffer)に表示しま
     す。

     The suffixes of this command export subtrees.

     If the ‘--prefix’ argument is set, then the suffix commands use
     that prefix without prompting the user.  If it is unset, then they
     read the prefix in the minibuffer.

‘O e p’     (‘magit-subtree-push’)

     This command extract the history of the subtree PREFIX and pushes
     it to REF on REPOSITORY.

‘O e s’     (‘magit-subtree-split’)

     This command extracts the history of the subtree PREFIX.


File: magit.ja.info,  Node: Worktree,  Next: Common Commands,  Prev: Subtree,  Up: Miscellaneous

8.5 Worktree
============

こちらもご覧下さい *note (gitman)git-worktree::

‘%’     (‘magit-worktree’)

     この一時的(transient)前置(prefix)コマンドは、それに続く後置
     (suffix)コマンドを結びつけ、後置(suffix)コマンドが呼び出されるまで
     一時バッファ(temporary buffer)に表示します。

‘% b’     (‘magit-worktree-checkout’)

     Checkout BRANCH in a new worktree at PATH.

‘% c’     (‘magit-worktree-branch’)

     Create a new BRANCH and check it out in a new worktree at PATH.

‘% m’     (‘magit-worktree-move’)

     Move an existing worktree to a new PATH.

‘% k’     (‘magit-worktree-delete’)

     Delete a worktree, defaulting to the worktree at point.  The
     primary worktree cannot be deleted.

‘% g’     (‘magit-worktree-status’)

     Show the status for the worktree at point.

     If there is no worktree at point, then read one in the minibuffer.
     If the worktree at point is the one whose status is already being
     displayed in the current buffer, then show it in Dired instead.


File: magit.ja.info,  Node: Common Commands,  Next: Wip Modes,  Prev: Worktree,  Up: Miscellaneous

8.6 Common Commands
===================

 -- magit-switch-to-repository-buffer: コマンド
 -- magit-switch-to-repository-buffer-other-window: コマンド
 -- magit-switch-to-repository-buffer-other-frame: コマンド
 -- magit-display-repository-buffer: コマンド

     These commands read any existing Magit buffer that belongs to the
     current repository from the user and then switch to the selected
     buffer (without refreshing it).

     The last variant uses ‘magit-display-buffer’ to do so and thus
     respects ‘magit-display-buffer-function’.

These are some of the commands that can be used in all buffers whose
major-modes derive from ‘magit-mode’.  There are other common commands
beside the ones below, but these didn’t fit well anywhere else.

‘C-w’     (‘magit-copy-section-value’)

     This command saves the value of the current section to the
     ‘kill-ring’, and, provided that the current section is a commit,
     branch, or tag section, it also pushes the (referenced) revision to
     the ‘magit-revision-stack’.

     When the current section is a branch or a tag, and a prefix
     argument is used, then it saves the revision at its tip to the
     ‘kill-ring’ instead of the reference name.

     When the region is active, this command saves that to the
     ‘kill-ring’, like ‘kill-ring-save’ would, instead of behaving as
     described above.  If a prefix argument is used and the region is
     within a hunk, then it strips the diff marker column and keeps only
     either the added or removed lines, depending on the sign of the
     prefix argument.

‘M-w’     (‘magit-copy-buffer-revision’)

     This command saves the revision being displayed in the current
     buffer to the ‘kill-ring’ and also pushes it to the
     ‘magit-revision-stack’.  It is mainly intended for use in
     ‘magit-revision-mode’ buffers, the only buffers where it is always
     unambiguous exactly which revision should be saved.

     Most other Magit buffers usually show more than one revision, in
     some way or another, so this command has to select one of them, and
     that choice might not always be the one you think would have been
     the best pick.

Outside of Magit ‘M-w’ and ‘C-w’ are usually bound to ‘kill-ring-save’
and ‘kill-region’, and these commands would also be useful in Magit
buffers.  Therefore when the region is active, then both of these
commands behave like ‘kill-ring-save’ instead of as described above.


File: magit.ja.info,  Node: Wip Modes,  Next: Commands for Buffers Visiting Files,  Prev: Common Commands,  Up: Miscellaneous

8.7 Wip Modes
=============

Git keeps *committed* changes around long enough for users to recover
changes they have accidentally deleted.  It does so by not garbage
collecting any committed but no longer referenced objects for a certain
period of time, by default 30 days.

But Git does *not* keep track of *uncommitted* changes in the working
tree and not even the index (the staging area).  Because Magit makes it
so convenient to modify uncommitted changes, it also makes it easy to
shoot yourself in the foot in the process.

For that reason Magit provides a global mode that saves *tracked* files
to work-in-progress references after or before certain actions.  (At
present untracked files are never saved and for technical reasons
nothing is saved before the first commit has been created).

Two separate work-in-progress references are used to track the state of
the index and of the working tree: ‘refs/wip/index/<branchref>’ and
‘refs/wip/wtree/<branchref>’, where ‘<branchref>’ is the full ref of the
current branch, e.g.  ‘refs/heads/master’.  When the ‘HEAD’ is detached
then ‘HEAD’ is used in place of ‘<branchref>’.

Checking out another branch (or detaching ‘HEAD’) causes the use of
different wip refs for subsequent changes.

 -- User Option: magit-wip-mode

     When this mode is enabled, then uncommitted changes are committed
     to dedicated work-in-progress refs whenever appropriate (i.e.  when
     dataloss would be a possibility otherwise).

     Setting this variable directly does not take effect; either use the
     Custom interface to do so or call the respective mode function.

     For historic reasons this mode is implemented on top of four other
     ‘magit-wip-*’ modes, which can also be used individually, if you
     want finer control over when the wip refs are updated; but that is
     discouraged.  See *note Legacy Wip Modes::.

To view the log for a branch and its wip refs use the commands
‘magit-wip-log’ and ‘magit-wip-log-current’.  You should use ‘--graph’
when using these commands.

 -- magit-wip-log: コマンド

     This command shows the log for a branch and its wip refs.  With a
     negative prefix argument only the worktree wip ref is shown.

     The absolute numeric value of the prefix argument controls how many
     "branches" of each wip ref are shown.  This is only relevant if the
     value of ‘magit-wip-merge-branch’ is ‘nil’.

 -- magit-wip-log-current: コマンド

     This command shows the log for the current branch and its wip refs.
     With a negative prefix argument only the worktree wip ref is shown.

     The absolute numeric value of the prefix argument controls how many
     "branches" of each wip ref are shown.  This is only relevant if the
     value of ‘magit-wip-merge-branch’ is ‘nil’.

‘X w’     (‘magit-reset-worktree’)

     This command resets the working tree to some commit read from the
     user and defaulting to the commit at point, while keeping the
     ‘HEAD’ and index as-is.

     This can be used to restore files to the state committed to a wip
     ref.  Note that this will discard any unstaged changes that might
     have existed before invoking this command (but of course only after
     committing that to the working tree wip ref).

Note that even if you enable ‘magit-wip-mode’ this won’t give you
perfect protection.  The most likely scenario for losing changes despite
the use of ‘magit-wip-mode’ is making a change outside Emacs and then
destroying it also outside Emacs.  In some such a scenario, Magit, being
an Emacs package, didn’t get the opportunity to keep you from shooting
yourself in the foot.

When you are unsure whether Magit did commit a change to the wip refs,
then you can explicitly request that all changes to all tracked files
are being committed.

‘M-x magit-wip-commit’     (‘magit-wip-commit’)

     This command commits all changes to all tracked files to the index
     and working tree work-in-progress refs.  Like the modes described
     above, it does not commit untracked files, but it does check all
     tracked files for changes.  Use this command when you suspect that
     the modes might have overlooked a change made outside Emacs/Magit.

 -- User Option: magit-wip-namespace

     The namespace used for work-in-progress refs.  It has to end with a
     slash.  The wip refs are named ‘<namespace>index/<branchref>’ and
     ‘<namespace>wtree/<branchref>’.  When snapshots are created while
     the ‘HEAD’ is detached then ‘HEAD’ is used in place of
     ‘<branchref>’.

 -- User Option: magit-wip-mode-lighter

     Mode-line lighter for ‘magit-wip--mode’.

* Menu:

* Wip Graph::
* Legacy Wip Modes::


File: magit.ja.info,  Node: Wip Graph,  Next: Legacy Wip Modes,  Up: Wip Modes

8.7.1 Wip Graph
---------------

 -- User Option: magit-wip-merge-branch

     This option controls whether the current branch is merged into the
     wip refs after a new commit was created on the branch.

     If non-nil and the current branch has new commits, then it is
     merged into the wip ref before creating a new wip commit.  This
     makes it easier to inspect wip history and the wip commits are
     never garbage collected.

     If nil and the current branch has new commits, then the wip ref is
     reset to the tip of the branch before creating a new wip commit.
     With this setting wip commits are eventually garbage collected.

When ‘magit-wip-merge-branch’ is ‘t’, then the history looks like this:

       *--*--*--*--*--*       refs/wip/index/refs/heads/master
      /     /     /
     A-----B-----C            refs/heads/master

When ‘magit-wip-merge-branch’ is ‘nil’, then creating a commit on the
real branch and then making a change causes the wip refs to be recreated
to fork from the new commit.  But the old commits on the wip refs are
not lost.  They are still available from the reflog.  To make it easier
to see when the fork point of a wip ref was changed, an additional
commit with the message "restart autosaving" is created on it (‘xxO’
commits below are such boundary commits).

Starting with

           BI0---BI1    refs/wip/index/refs/heads/master
          /
     A---B              refs/heads/master
          \
           BW0---BW1    refs/wip/wtree/refs/heads/master

and committing the staged changes and editing and saving a file would
result in

           BI0---BI1        refs/wip/index/refs/heads/master
          /
     A---B---C              refs/heads/master
          \   \
           \   CW0---CW1    refs/wip/wtree/refs/heads/master
            \
             BW0---BW1      refs/wip/wtree/refs/heads/master@{2}

The fork-point of the index wip ref is not changed until some change is
being staged.  Likewise just checking out a branch or creating a commit
does not change the fork-point of the working tree wip ref.  The
fork-points are not adjusted until there actually is a change that
should be committed to the respective wip ref.


File: magit.ja.info,  Node: Legacy Wip Modes,  Prev: Wip Graph,  Up: Wip Modes

8.7.2 Legacy Wip Modes
----------------------

It is recommended that you use the mode ‘magit-wip-mode’ (which see) and
ignore the existence of the following modes, which are preserved for
historic reasons.

Setting the following variables directly does not take effect; either
use the Custom interface to do so or call the respective mode functions.

 -- User Option: magit-wip-after-save-mode

     When this mode is enabled, then saving a buffer that visits a file
     tracked in a Git repository causes its current state to be
     committed to the working tree wip ref for the current branch.

 -- User Option: magit-wip-after-apply-mode

     When this mode is enabled, then applying (i.e.  staging, unstaging,
     discarding, reversing, and regularly applying) a change to a file
     tracked in a Git repository causes its current state to be
     committed to the index and/or working tree wip refs for the current
     branch.

If you only ever edit files using Emacs and only ever interact with Git
using Magit, then the above two modes should be enough to protect each
and every change from accidental loss.  In practice nobody does that.
Two additional modes exists that do commit to the wip refs before making
changes that could cause the loss of earlier changes.

 -- User Option: magit-wip-before-change-mode

     When this mode is enabled, then certain commands commit the
     existing changes to the files they are about to make changes to.

 -- User Option: magit-wip-initial-backup-mode

     When this mode is enabled, then the current version of a file is
     committed to the worktree wip ref before the buffer visiting that
     file is saved for the first time since the buffer was created.

     This backs up the same version of the file that ‘backup-buffer’
     would save.  While ‘backup-buffer’ uses a backup file, this mode
     uses the same worktree wip ref as used by the other Magit Wip
     modes.  Like ‘backup-buffer’, it only does this once; unless you
     kill the buffer and visit the file again only one backup will be
     created per Emacs session.

     This mode ignores the variables that affect ‘backup-buffer’ and can
     be used along-side that function, which is recommended because it
     only backs up files that are tracked in a Git repository.

 -- User Option: magit-wip-after-save-local-mode-lighter

     Mode-line lighter for ‘magit-wip-after-save-local-mode’.

 -- User Option: magit-wip-after-apply-mode-lighter

     Mode-line lighter for ‘magit-wip-after-apply-mode’.

 -- User Option: magit-wip-before-change-mode-lighter

     Mode-line lighter for ‘magit-wip-before-change-mode’.

 -- User Option: magit-wip-initial-backup-mode-lighter

     Mode-line lighter for ‘magit-wip-initial-backup-mode’.


File: magit.ja.info,  Node: Commands for Buffers Visiting Files,  Next: Minor Mode for Buffers Visiting Blobs,  Prev: Wip Modes,  Up: Miscellaneous

8.8 Commands for Buffers Visiting Files
=======================================

Magit defines a few global key bindings unless the user sets
‘magit-define-global-key-bindings’ to ‘nil’.  This includes binding ‘C-c
M-g’ to ‘magit-file-dispatch’.  ‘C-c g’ would be a much better binding
but the ‘C-c <letter>’ namespace is reserved for users, meaning that
packages are not allowed to use it.  If you want to use ‘C-c g’, then
you have to add that binding yourself.  Also see *note Default
Bindings:: and *note (elisp)Key Binding Conventions::.

If you want a better binding, you have to add it yourself:

     (global-set-key (kbd "C-c g") 'magit-file-dispatch)

The key bindings shown below assume that you have not improved the
binding for ‘magit-file-dispatch’.

‘C-c M-g’     (‘magit-file-dispatch’)

     この一時的(transient)前置(prefix)コマンドは、それに続く後置
     (suffix)コマンドを結びつけ、後置(suffix)コマンドが呼び出されるまで
     一時バッファ(temporary buffer)に表示します。

     When invoked in a buffer that does not visit a file, then it falls
     back to regular ‘magit-dispatch’.

‘C-c M-g s’     (‘magit-stage-file’)

     Stage all changes to the file being visited in the current buffer.

‘C-c M-g u’     (‘magit-unstage-file’)

     Unstage all changes to the file being visited in the current
     buffer.

‘C-c M-g c’     (‘magit-commit’)

     この一時的な前置コマンドは、続く後置コマンドを適切な中置引数ととも
     にバインドし、後置が呼び出されるまで一時バッファに表示します(*note
     コミット開始::)。

‘C-c M-g D’     (‘magit-diff’)

     This transient prefix command binds several diff suffix commands
     and infix arguments and displays them in a temporary buffer until a
     suffix is invoked.  See *note Diffing::.

     This is the same command that ‘d’ is bound to in Magit buffers.  If
     this command is invoked from a file-visiting buffer, then the
     initial value of the option (‘--’) that limits the diff to certain
     file(s) is set to the visited file.

‘C-c M-g d’     (‘magit-diff-buffer-file’)

     This command shows the diff for the file of blob that the current
     buffer visits.

 -- User Option: magit-diff-buffer-file-locked

     This option controls whether ‘magit-diff-buffer-file’ uses a
     dedicated buffer.  See *note Modes and Buffers::.

‘C-c M-g L’     (‘magit-log’)

     This transient prefix command binds several log suffix commands and
     infix arguments and displays them in a temporary buffer until a
     suffix is invoked.  See *note Logging::.

     This is the same command that ‘l’ is bound to in Magit buffers.  If
     this command is invoked from a file-visiting buffer, then the
     initial value of the option (‘--’) that limits the log to certain
     file(s) is set to the visited file.

‘C-c M-g l’     (‘magit-log-buffer-file’)

     This command shows the log for the file of blob that the current
     buffer visits.  Renames are followed when a prefix argument is used
     or when ‘--follow’ is an active log argument.  When the region is
     active, the log is restricted to the selected line range.

‘C-c M-g t’     (‘magit-log-trace-definition’)

     This command shows the log for the definition at point.

 -- User Option: magit-log-buffer-file-locked

     This option controls whether ‘magit-log-buffer-file’ uses a
     dedicated buffer.  See *note Modes and Buffers::.

‘C-c M-g B’     (‘magit-blame’)

     This transient prefix command binds all blaming suffix commands
     along with the appropriate infix arguments and displays them in a
     temporary buffer until a suffix is invoked.

     For more information about this and the following commands also see
     *note Blaming::.

In addition to the ‘magit-blame’ sub-transient, the dispatch transient
also binds several blaming suffix commands directly.  See *note
Blaming:: for information about those commands and bindings.

‘C-c M-g e’     (‘magit-edit-line-commit’)

     This command makes the commit editable that added the current line.

     With a prefix argument it makes the commit editable that removes
     the line, if any.  The commit is determined using ‘git blame’ and
     made editable using ‘git rebase --interactive’ if it is reachable
     from ‘HEAD’, or by checking out the commit (or a branch that points
     at it) otherwise.

‘C-c M-g p’     (‘magit-blob-previous’)

     Visit the previous blob which modified the current file.

There are a few additional commands that operate on a single file but
are not enabled in the file transient command by default:

 -- magit-file-rename: コマンド

     This command renames a file read from the user.

 -- magit-file-delete: コマンド

     This command deletes a file read from the user.

 -- magit-file-untrack: コマンド

     This command untracks a file read from the user.

 -- magit-file-checkout: コマンド

     This command updates a file in the working tree and index to the
     contents from a revision.  Both the revision and file are read from
     the user.

To enable them invoke the transient (‘C-c M-g’), enter "edit mode" (‘C-x
l’), set the "transient level" (‘C-x l’ again), enter ‘5’, and leave
edit mode (‘C-g’).  Also see *note (transient)Enabling and Disabling
Suffixes::.


File: magit.ja.info,  Node: Minor Mode for Buffers Visiting Blobs,  Prev: Commands for Buffers Visiting Files,  Up: Miscellaneous

8.9 Minor Mode for Buffers Visiting Blobs
=========================================

The ‘magit-blob-mode’ enables certain Magit features in blob-visiting
buffers.  Such buffers can be created using ‘magit-find-file’ and some
of the commands mentioned below, which also take care of turning on this
minor mode.  Currently this mode only establishes a few key bindings,
but this might be extended.

‘p’     (‘magit-blob-previous’)

     Visit the previous blob which modified the current file.

‘n’     (‘magit-blob-next’)

     Visit the next blob which modified the current file.

‘q’     (‘magit-kill-this-buffer’)

     Kill the current buffer.


File: magit.ja.info,  Node: Customizing,  Next: 配管コマンド(Plumbing),  Prev: Miscellaneous,  Up: Top

9 Customizing
*************

GitとEmacsはどちらも高度にカスタマイズ可能です。MagitはGit磁器であると同
時にEmacsパッケージでもあるため、Git変数とEmacsオプションの両方を使用し
てカスタマイズすることは理にかなっています。ただし、この柔軟性には、以下
のような問題もあります。

   • 一部のGit変数は、明示的なサポートを必要とせずに、Magitで自動的に効
     果を発揮します。それが望ましい場合もあれば、一方でMagitを壊す場合も
     あります。

     特定のGit設定がMagitを壊したが、コマンドラインでその設定を使い続け
     たい場合は、‘magit-git-global-arguments’に‘("-c"
     "some.variable=compatible-value")’のようなものを追加してMagitの値を
     オーバーライドすることで実現できます。

   • ‘fetch.prune=true’のような特定の設定は、(単にそれぞれのGitコマンド
     を呼び出すため)Magitコマンドによって尊重されますが、それらの値はそ
     れぞれの一時バッファに反映されません。この場合、‘magit-fetch’の
     ‘--prune’引数はアクティブまたは非アクティブである可能性がありますが
     、それでもGit変数が後置コマンドによって尊重されることを妨げません。
     したがって、‘--prune’引数が、pruningが発生しないことを示しているよ
     うに見える方法で表示されているにもかかわらず、pruningが発生する可能
     性があります。

今後のリリースで、これらの問題や同様の問題に対処する予定です。

* Menu:

* Per-Repository Configuration::
* 基本設定::


File: magit.ja.info,  Node: Per-Repository Configuration,  Next: 基本設定,  Up: Customizing

9.1 Per-Repository Configuration
================================

Magit can be configured on a per-repository level using both Git
variables as well as Emacs options.

To set a Git variable for one repository only, simply set it in
‘/path/to/repo/.git/config’ instead of ‘$HOME/.gitconfig’ or
‘/etc/gitconfig’.  See *note (gitman)git-config::.

Similarly, Emacs options can be set for one repository only by editing
‘/path/to/repo/.dir-locals.el’.  See *note (emacs)Directory Variables::.
For example to disable automatic refreshes of file-visiting buffers in
just one huge repository use this:

   • ‘/path/to/huge/repo/.dir-locals.el’

          ((nil . ((magit-refresh-buffers . nil))))

It might only be costly to insert certain information into Magit buffers
for repositories that are exceptionally large, in which case you can
disable the respective section inserters just for that repository:

   • ‘/path/to/tag/invested/repo/.dir-locals.el’

          ((magit-status-mode
            . ((eval . (magit-disable-section-inserter 'magit-insert-tags-header)))))

 -- Function: magit-disable-section-inserter fn

     This function disables the section inserter FN in the current
     repository.  It is only intended for use in ‘.dir-locals.el’ and
     ‘.dir-locals-2.el’.

If you want to apply the same settings to several, but not all,
repositories then keeping the repository-local config files in sync
would quickly become annoying.  To avoid that you can create config
files for certain classes of repositories (e.g.  "huge repositories")
and then include those files in the per-repository config files.  For
example:

   • ‘/path/to/huge/repo/.git/config’

          [include]
                  path = /path/to/huge-gitconfig

   • ‘/path/to/huge-gitconfig’

          [status]
                  showUntrackedFiles = no

   • ‘$HOME/.emacs.d/init.el’

          (dir-locals-set-class-variables 'huge-git-repository
             '((nil . ((magit-refresh-buffers . nil)))))

          (dir-locals-set-directory-class
             "/path/to/huge/repo/" 'huge-git-repository)


File: magit.ja.info,  Node: 基本設定,  Prev: Per-Repository Configuration,  Up: Customizing

9.2 基本設定
============

The next two sections list and discuss several variables that many users
might want to customize, for safety and/or performance reasons.

* Menu:

* Safety::
* Performance::
* Default Bindings::


File: magit.ja.info,  Node: Safety,  Next: Performance,  Up: 基本設定

9.2.1 Safety
------------

This section discusses various variables that you might want to change
(or *not* change) for safety reasons.

Git keeps *committed* changes around long enough for users to recover
changes they have accidentally been deleted.  It does not do the same
for *uncommitted* changes in the working tree and not even the index
(the staging area).  Because Magit makes it so easy to modify
uncommitted changes, it also makes it easy to shoot yourself in the foot
in the process.  For that reason Magit provides three global modes that
save *tracked* files to work-in-progress references after or before
certain actions.  See *note Wip Modes::.

これらのモードは、パフォーマンス上の懸念から、デフォルトでは有効になって
いません。 代わりに、破壊的な可能性のあるコマンドの多くは、使用するたび
に確認が必要です。多くの場合、これは‘magit-no-confirm’にシンボルを追加す
ることで無効にできます(*note 補完と確認::)。 さまざまなwipモードを有効に
する場合は、このリストに‘safe-with-wip’を追加する必要があります。

Similarly it isn’t necessary to require confirmation before moving a
file to the system trash - if you trashed a file by mistake then you can
recover it from there.  Option ‘magit-delete-by-moving-to-trash’
controls whether the system trash is used, which is the case by default.
Nevertheless, ‘trash’ isn’t a member of ‘magit-no-confirm’ - you might
want to change that.

デフォルトでは、訪問したファイルがディスク上で変更されると、訪問したファ
イルは自動的に元に戻されます。 これは見た目ほど危険ではありませんが、十
分な情報に基づいて決定を下すには確認が必要です→*note
自動的に元に戻るリスク::


File: magit.ja.info,  Node: Performance,  Next: Default Bindings,  Prev: Safety,  Up: 基本設定

9.2.2 Performance
-----------------

After Magit has run ‘git’ for side-effects, it also refreshes the
current Magit buffer and the respective status buffer.  This is
necessary because otherwise outdated information might be displayed
without the user noticing.  Magit buffers are updated by recreating
their content from scratch, which makes updating simpler and less
error-prone, but also more costly.  Keeping it simple and just
re-creating everything from scratch is an old design decision and
departing from that will require major refactoring.

I plan to do that in time for the next major release.  I also intend to
create logs and diffs asynchronously, which should also help a lot but
also requires major refactoring.

Meanwhile you can tell Magit to only automatically refresh the current
Magit buffer, but not the status buffer.  If you do that, then the
status buffer is only refreshed automatically if it is the current
buffer.

     (setq magit-refresh-status-buffer nil)

You should also check whether any third-party packages have added
anything to ‘magit-refresh-buffer-hook’, ‘magit-status-refresh-hook’,
‘magit-pre-refresh-hook’, and ‘magit-post-refresh-hook’.  If so, then
check whether those additions impact performance significantly.

Magit can be told to refresh buffers verbosely using ‘M-x
magit-toggle-verbose-refresh’.  Enabling this helps figuring out which
sections are bottlenecks.  The additional output can be found in the
‘*Messages*’ buffer.

Magit also reverts buffers for visited files located inside the current
repository when the visited file changes on disk.  That is implemented
on top of ‘auto-revert-mode’ from the built-in library ‘autorevert’.  To
figure out whether that impacts performance, check whether performance
is significantly worse, when many buffers exist and/or when some buffers
visit files using TRAMP.  If so, then this should help.

     (setq auto-revert-buffer-list-filter
           'magit-auto-revert-repository-buffer-p)

For alternative approaches see *note Automatic Reverting of
File-Visiting Buffers::.

If you have enabled any features that are disabled by default, then you
should check whether they impact performance significantly.  It’s likely
that they were not enabled by default because it is known that they
reduce performance at least in large repositories.

If performance is only slow inside certain unusually large repositories,
then you might want to disable certain features on a per-repository or
per-repository-class basis only.  See *note Per-Repository
Configuration::.  For example it takes a long time to determine the next
and current tag in repository with exceptional numbers of tags.  It
would therefore be a good idea to disable ‘magit-insert-tags-headers’,
as explained at the mentioned node.

* Menu:

* Microsoft Windows Performance::
* MacOS Performance::

Log Performance
...............

When showing logs, Magit limits the number of commits initially shown in
the hope that this avoids unnecessary work.  When using ‘--graph’ is
used, then this unfortunately does not have the desired effect for large
histories.  Junio, Git’s maintainer, said on the git mailing list
(<http://www.spinics.net/lists/git/msg232230.html>): "‘--graph’ wants to
compute the whole history and the max-count only affects the output
phase after ‘--graph’ does its computation".

In other words, it’s not that Git is slow at outputting the differences,
or that Magit is slow at parsing the output - the problem is that Git
first goes outside and has a smoke.

We actually work around this issue by limiting the number of commits not
only by using ‘-<N>’ but by also using a range.  But unfortunately
that’s not always possible.

When more than a few thousand commits are shown, then the use of
‘--graph’ can slow things down.

Using ‘--color --graph’ is even slower.  Magit uses code that is part of
Emacs to turn control characters into faces.  That code is pretty slow
and this is quite noticeable when showing a log with many branches and
merges.  For that reason ‘--color’ is not enabled by default anymore.
Consider leaving it at that.

Diff Performance
................

If diffs are slow, then consider turning off some optional diff features
by setting all or some of the following variables to ‘nil’:
‘magit-diff-highlight-indentation’, ‘magit-diff-highlight-trailing’,
‘magit-diff-paint-whitespace’, ‘magit-diff-highlight-hunk-body’, and
‘magit-diff-refine-hunk’.

When showing a commit instead of some arbitrary diff, then some
additional information is displayed.  Calculating this information can
be quite expensive given certain circumstances.  If looking at a commit
using ‘magit-revision-mode’ takes considerably more time than looking at
the same commit in ‘magit-diff-mode’, then consider setting
‘magit-revision-insert-related-refs’ to ‘nil’.

When you are often confronted with diffs that contain deleted files,
then you might want to enable the ‘--irreversible-delete’ argument.  If
you do that then diffs still show that a file was deleted but without
also showing the complete deleted content of the file.  This argument is
not available by default, see *note (transient)Enabling and Disabling
Suffixes::.  Once you have done that you should enable it and save that
setting, see *note (transient)Saving Values::.  You should do this in
both the diff (‘d’) and the diff refresh (‘D’) transient popups.

Refs Buffer Performance
.......................

When refreshing the "references buffer" is slow, then that’s usually
because several hundred refs are being displayed.  The best way to
address that is to display fewer refs, obviously.

If you are not, or only mildly, interested in seeing the list of tags,
then start by not displaying them:

     (remove-hook 'magit-refs-sections-hook 'magit-insert-tags)

Then you should also make sure that the listed remote branches actually
all exist.  You can do so by pruning branches which no longer exist
using ‘f-pa’.

Committing Performance
......................

When you initiate a commit, then Magit by default automatically shows a
diff of the changes you are about to commit.  For large commits this can
take a long time, which is especially distracting when you are
committing large amounts of generated data which you don’t actually
intend to inspect before committing.  This behavior can be turned off
using:

     (remove-hook 'server-switch-hook 'magit-commit-diff)

Then you can type ‘C-c C-d’ to show the diff when you actually want to
see it, but only then.  Alternatively you can leave the hook alone and
just type ‘C-g’ in those cases when it takes too long to generate the
diff.  If you do that, then you will end up with a broken diff buffer,
but doing it this way has the advantage that you usually get to see the
diff, which is useful because it increases the odds that you spot
potential issues.


File: magit.ja.info,  Node: Microsoft Windows Performance,  Next: MacOS Performance,  Up: Performance

Microsoft Windows Performance
.............................

In order to update the status buffer, ‘git’ has to be run a few dozen
times.  That is problematic on Microsoft Windows, because that operating
system is exceptionally slow at starting processes.  Sadly this is an
issue that can only be fixed by Microsoft itself, and they don’t appear
to be particularly interested in doing so.

Beside the subprocess issue, there are also other Windows-specific
performance issues.  Some of these have workarounds.  The maintainers of
"Git for Windows" try to improve performance on Windows.  Always use the
latest release in order to benefit from the latest performance tweaks.
Magit too tries to work around some Windows-specific issues.

According to some sources, setting the following Git variables can also
help.

     git config --global core.preloadindex true   # default since v2.1
     git config --global core.fscache true        # default since v2.8
     git config --global gc.auto 256

You should also check whether an anti-virus program is affecting
performance.


File: magit.ja.info,  Node: MacOS Performance,  Prev: Microsoft Windows Performance,  Up: Performance

MacOS Performance
.................

Before Emacs 26.1 child processes were created using ‘fork’ on macOS.
That needlessly copied GUI resources, which is expensive.  The result
was that forking took about 30 times as long on Darwin than on Linux,
and because Magit starts many ‘git’ processes that made quite a
difference.

So make sure that you are using at least Emacs 26.1, in which case the
faster ‘vfork’ will be used.  (The creation of child processes still
takes about twice as long on Darwin compared to Linux.)  See (1) for
more information.

   ---------- Footnotes ----------

   (1) 
<https://lists.gnu.org/archive/html/bug-gnu-emacs/2017-04/msg00201.html>


File: magit.ja.info,  Node: Default Bindings,  Prev: Performance,  Up: 基本設定

9.2.3 Default Bindings
----------------------

 -- User Option: magit-define-global-key-bindings

     This option controls whether some Magit commands are automatically
     bound in the global keymap even before Magit is used for the first
     time in the current session.

     If this variable is non-nil, which it is by default, then the
     following bindings may be added to the global keymap.

     ‘C-x g’     ‘magit-status’
     ‘C-x M-g’   ‘magit-dispatch’
     ‘C-c M-g’   ‘magit-file-dispatch’

     These bindings may be added when ‘after-init-hook’ is run.  Each
     binding is added if and only if at that time no other key is bound
     to the same command and no other command is bound to the same key.
     In other words we try to avoid adding bindings that are
     unnecessary, as well as bindings that conflict with other bindings.

     Adding the above bindings is delayed until ‘after-init-hook’ is
     called to allow users to set the variable anywhere in their init
     file (without having to make sure to do so before ‘magit’ is loaded
     or autoloaded) and to increase the likelihood that all the
     potentially conflicting user bindings have already been added.

     To set this variable use either ‘setq’ or the Custom interface.  Do
     not use the function ‘customize-set-variable’ because doing that
     would cause Magit to be loaded immediately when that form is
     evaluated (this differs from ‘custom-set-variables’, which doesn’t
     load the libraries that define the customized variables).

     Setting this variable to nil has no effect if that is done after
     the key bindings have already been added.

     We recommend that you bind ‘C-c g’ instead of ‘C-c M-g’ to
     ‘magit-file-dispatch’.  The former is a much better binding but the
     ‘C-c <letter>’ namespace is strictly reserved for users; preventing
     Magit from using it by default.

          (global-set-key (kbd "C-c g") 'magit-file-dispatch)

     Also see *note Commands for Buffers Visiting Files:: and *note
     (elisp)Key Binding Conventions::.


File: magit.ja.info,  Node: 配管コマンド(Plumbing),  Next: FAQ,  Prev: Customizing,  Up: Top

10 配管コマンド(Plumbing)
*************************

以下の節では、Magitのコア抽象化のいくつかを使用して、Magit自体を拡張する
方法、または個別の拡張を実装する方法について説明します。

Magitで使用される低レベルの機能のいくつかは、個別の ライブラリ/パッケー
ジ に分解されているため、Magitに依存することなく他のパッケージで使用でき
ます。‘with-editor’については→*note (with-editor)Top:: ‘transient’にはま
だマニュアルがありません。

独自のMagit拡張機能によって提供されるコマンドにバインドできる未使用のキ
ーを見つけようとしている場合は、
<https://github.com/magit/magit/wiki/Plugin-Dispatch-Key-Registry>をチェ
ックアウトしてください。

* Menu:

* Calling Git::
* Section Plumbing::
* Refreshing Buffers::
* 慣習::


File: magit.ja.info,  Node: Calling Git,  Next: Section Plumbing,  Up: 配管コマンド(Plumbing)

10.1 Calling Git
================

Magit provides many specialized functions for calling Git.  All of these
functions are defined in either ‘magit-git.el’ or ‘magit-process.el’ and
have one of the prefixes ‘magit-run-’, ‘magit-call-’, ‘magit-start-’, or
‘magit-git-’ (which is also used for other things).

All of these functions accept an indefinite number of arguments, which
are strings that specify command line arguments for Git (or in some
cases an arbitrary executable).  These arguments are flattened before
being passed on to the executable; so instead of strings they can also
be lists of strings and arguments that are ‘nil’ are silently dropped.
Some of these functions also require a single mandatory argument before
these command line arguments.

Roughly speaking, these functions run Git either to get some value or
for side-effects.  The functions that return a value are useful to
collect the information necessary to populate a Magit buffer, while the
others are used to implement Magit commands.

The functions in the value-only group always run synchronously, and they
never trigger a refresh.  The function in the side-effect group can be
further divided into subgroups depending on whether they run Git
synchronously or asynchronously, and depending on whether they trigger a
refresh when the executable has finished.

* Menu:

* Getting a Value from Git::
* Calling Git for Effect::


File: magit.ja.info,  Node: Getting a Value from Git,  Next: Calling Git for Effect,  Up: Calling Git

10.1.1 Getting a Value from Git
-------------------------------

These functions run Git in order to get a value, an exit status, or
output.  Of course you could also use them to run Git commands that have
side-effects, but that should be avoided.

 -- Function: magit-git-exit-code &rest args

     Executes git with ARGS and returns its exit code.

 -- Function: magit-git-success &rest args

     Executes git with ARGS and returns ‘t’ if the exit code is ‘0’,
     ‘nil’ otherwise.

 -- Function: magit-git-failure &rest args

     Executes git with ARGS and returns ‘t’ if the exit code is ‘1’,
     ‘nil’ otherwise.

 -- Function: magit-git-true &rest args

     Executes git with ARGS and returns ‘t’ if the first line printed by
     git is the string "true", ‘nil’ otherwise.

 -- Function: magit-git-false &rest args

     Executes git with ARGS and returns ‘t’ if the first line printed by
     git is the string "false", ‘nil’ otherwise.

 -- Function: magit-git-insert &rest args

     Executes git with ARGS and inserts its output at point.

 -- Function: magit-git-string &rest args

     Executes git with ARGS and returns the first line of its output.
     If there is no output or if it begins with a newline character,
     then this returns ‘nil’.

 -- Function: magit-git-lines &rest args

     Executes git with ARGS and returns its output as a list of lines.
     Empty lines anywhere in the output are omitted.

 -- Function: magit-git-items &rest args

     Executes git with ARGS and returns its null-separated output as a
     list.  Empty items anywhere in the output are omitted.

     If the value of option ‘magit-git-debug’ is non-nil and git exits
     with a non-zero exit status, then warn about that in the echo area
     and add a section containing git’s standard error in the current
     repository’s process buffer.

 -- Function: magit-process-git destination &rest args

     Calls Git synchronously in a separate process, returning its exit
     code.  DESTINATION specifies how to handle the output, like for
     ‘call-process’, except that file handlers are supported.  Enables
     Cygwin’s "noglob" option during the call and ensures unix eol
     conversion.

 -- Function: magit-process-file process &optional infile buffer display
          &rest args

     Processes files synchronously in a separate process.  Identical to
     ‘process-file’ but temporarily enables Cygwin’s "noglob" option
     during the call and ensures unix eol conversion.

If an error occurs when using one of the above functions, then that is
usually due to a bug, i.e.  using an argument which is not actually
supported.  Such errors are usually not reported, but when they occur we
need to be able to debug them.

 -- User Option: magit-git-debug

     Whether to report errors that occur when using ‘magit-git-insert’,
     ‘magit-git-string’, ‘magit-git-lines’, or ‘magit-git-items’.  This
     does not actually raise an error.  Instead a message is shown in
     the echo area, and git’s standard error is insert into a new
     section in the current repository’s process buffer.

 -- Function: magit-git-str &rest args

     This is a variant of ‘magit-git-string’ that ignores the option
     ‘magit-git-debug’.  It is mainly intended to be used while handling
     errors in functions that do respect that option.  Using such a
     function while handing an error could cause yet another error and
     therefore lead to an infinite recursion.  You probably won’t ever
     need to use this function.


File: magit.ja.info,  Node: Calling Git for Effect,  Prev: Getting a Value from Git,  Up: Calling Git

10.1.2 Calling Git for Effect
-----------------------------

These functions are used to run git to produce some effect.  Most Magit
commands that actually run git do so by using such a function.

Because we do not need to consume git’s output when using these
functions, their output is instead logged into a per-repository buffer,
which can be shown using ‘$’ from a Magit buffer or ‘M-x magit-process’
elsewhere.

These functions can have an effect in two distinct ways.  Firstly,
running git may change something, i.e.  create or push a new commit.
Secondly, that change may require that Magit buffers are refreshed to
reflect the changed state of the repository.  But refreshing isn’t
always desirable, so only some of these functions do perform such a
refresh after git has returned.

Sometimes it is useful to run git asynchronously.  For example, when the
user has just initiated a push, then there is no reason to make her wait
until that has completed.  In other cases it makes sense to wait for git
to complete before letting the user do something else.  For example
after staging a change it is useful to wait until after the refresh
because that also automatically moves to the next change.

 -- Function: magit-call-git &rest args

     Calls git synchronously with ARGS.

 -- Function: magit-call-process program &rest args

     Calls PROGRAM synchronously with ARGS.

 -- Function: magit-run-git &rest args

     Calls git synchronously with ARGS and then refreshes.

 -- Function: magit-run-git-with-input &rest args

     Calls git synchronously with ARGS and sends it the content of the
     current buffer on standard input.

     If the current buffer’s ‘default-directory’ is on a remote
     filesystem, this function actually runs git asynchronously.  But
     then it waits for the process to return, so the function itself is
     synchronous.

 -- Function: magit-git &rest args

     Calls git synchronously with ARGS for side-effects only.  This
     function does not refresh the buffer.

 -- Function: magit-git-wash washer &rest args

     Execute Git with ARGS, inserting washed output at point.  Actually
     first insert the raw output at point.  If there is no output call
     ‘magit-cancel-section’.  Otherwise temporarily narrow the buffer to
     the inserted text, move to its beginning, and then call function
     WASHER with ARGS as its sole argument.

And now for the asynchronous variants.

 -- Function: magit-run-git-async &rest args

     Start Git, prepare for refresh, and return the process object.
     ARGS is flattened and then used as arguments to Git.

     Display the command line arguments in the echo area.

     After Git returns some buffers are refreshed: the buffer that was
     current when this function was called (if it is a Magit buffer and
     still alive), as well as the respective Magit status buffer.
     Unmodified buffers visiting files that are tracked in the current
     repository are reverted if ‘magit-revert-buffers’ is non-nil.

 -- Function: magit-run-git-with-editor &rest args

     Export GIT_EDITOR and start Git.  Also prepare for refresh and
     return the process object.  ARGS is flattened and then used as
     arguments to Git.

     Display the command line arguments in the echo area.

     After Git returns some buffers are refreshed: the buffer that was
     current when this function was called (if it is a Magit buffer and
     still alive), as well as the respective Magit status buffer.

 -- Function: magit-start-git input &rest args

     Start Git, prepare for refresh, and return the process object.

     If INPUT is non-nil, it has to be a buffer or the name of an
     existing buffer.  The buffer content becomes the processes standard
     input.

     Option ‘magit-git-executable’ specifies the Git executable and
     option ‘magit-git-global-arguments’ specifies constant arguments.
     The remaining arguments ARGS specify arguments to Git.  They are
     flattened before use.

     After Git returns, some buffers are refreshed: the buffer that was
     current when this function was called (if it is a Magit buffer and
     still alive), as well as the respective Magit status buffer.
     Unmodified buffers visiting files that are tracked in the current
     repository are reverted if ‘magit-revert-buffers’ is non-nil.

 -- Function: magit-start-process &rest args

     Start PROGRAM, prepare for refresh, and return the process object.

     If optional argument INPUT is non-nil, it has to be a buffer or the
     name of an existing buffer.  The buffer content becomes the
     processes standard input.

     The process is started using ‘start-file-process’ and then setup to
     use the sentinel ‘magit-process-sentinel’ and the filter
     ‘magit-process-filter’.  Information required by these functions is
     stored in the process object.  When this function returns the
     process has not started to run yet so it is possible to override
     the sentinel and filter.

     After the process returns, ‘magit-process-sentinel’ refreshes the
     buffer that was current when ‘magit-start-process’ was called (if
     it is a Magit buffer and still alive), as well as the respective
     Magit status buffer.  Unmodified buffers visiting files that are
     tracked in the current repository are reverted if
     ‘magit-revert-buffers’ is non-nil.

 -- Variable: magit-this-process

     The child process which is about to start.  This can be used to
     change the filter and sentinel.

 -- Variable: magit-process-raise-error

     When this is non-nil, then ‘magit-process-sentinel’ raises an error
     if git exits with a non-zero exit status.  For debugging purposes.


File: magit.ja.info,  Node: Section Plumbing,  Next: Refreshing Buffers,  Prev: Calling Git,  Up: 配管コマンド(Plumbing)

10.2 Section Plumbing
=====================

* Menu:

* Creating Sections::
* Section Selection::
* Matching Sections::


File: magit.ja.info,  Node: Creating Sections,  Next: Section Selection,  Up: Section Plumbing

10.2.1 Creating Sections
------------------------

 -- Macro: magit-insert-section &rest args

     Insert a section at point.

     TYPE is the section type, a symbol.  Many commands that act on the
     current section behave differently depending on that type.  Also if
     a variable ‘magit-TYPE-section-map’ exists, then use that as the
     text-property ‘keymap’ of all text belonging to the section (but
     this may be overwritten in subsections).  TYPE can also have the
     form ‘(eval FORM)’ in which case FORM is evaluated at runtime.

     Optional VALUE is the value of the section, usually a string that
     is required when acting on the section.

     When optional HIDE is non-nil collapse the section body by default,
     i.e.  when first creating the section, but not when refreshing the
     buffer.  Otherwise, expand it by default.  This can be overwritten
     using ‘magit-section-set-visibility-hook’.  When a section is
     recreated during a refresh, then the visibility of predecessor is
     inherited and HIDE is ignored (but the hook is still honored).

     BODY is any number of forms that actually insert the section’s
     heading and body.  Optional NAME, if specified, has to be a symbol,
     which is then bound to the struct of the section being inserted.

     Before BODY is evaluated the ‘start’ of the section object is set
     to the value of ‘point’ and after BODY was evaluated its ‘end’ is
     set to the new value of ‘point’; BODY is responsible for moving
     ‘point’ forward.

     If it turns out inside BODY that the section is empty, then
     ‘magit-cancel-section’ can be used to abort and remove all traces
     of the partially inserted section.  This can happen when creating a
     section by washing Git’s output and Git didn’t actually output
     anything this time around.

 -- Function: magit-insert-heading &rest args

     Insert the heading for the section currently being inserted.

     This function should only be used inside ‘magit-insert-section’.

     When called without any arguments, then just set the ‘content’ slot
     of the object representing the section being inserted to a marker
     at ‘point’.  The section should only contain a single line when
     this function is used like this.

     When called with arguments ARGS, which have to be strings, then
     insert those strings at point.  The section should not contain any
     text before this happens and afterwards it should again only
     contain a single line.  If the ‘face’ property is set anywhere
     inside any of these strings, then insert all of them unchanged.
     Otherwise use the ‘magit-section-heading’ face for all inserted
     text.

     The ‘content’ property of the section struct is the end of the
     heading (which lasts from ‘start’ to ‘content’) and the beginning
     of the body (which lasts from ‘content’ to ‘end’).  If the value of
     ‘content’ is nil, then the section has no heading and its body
     cannot be collapsed.  If a section does have a heading then its
     height must be exactly one line, including a trailing newline
     character.  This isn’t enforced; you are responsible for getting it
     right.  The only exception is that this function does insert a
     newline character if necessary.

 -- Function: magit-cancel-section

     Cancel the section currently being inserted.  This exits the
     innermost call to ‘magit-insert-section’ and removes all traces of
     what has already happened inside that call.

 -- Function: magit-define-section-jumper sym title &optional value

     Define an interactive function to go to section SYM.  TITLE is the
     displayed title of the section.


File: magit.ja.info,  Node: Section Selection,  Next: Matching Sections,  Prev: Creating Sections,  Up: Section Plumbing

10.2.2 Section Selection
------------------------

 -- Function: magit-current-section

     Return the section at point.

 -- Function: magit-region-sections &optional condition multiple

     Return a list of the selected sections.

     When the region is active and constitutes a valid section
     selection, then return a list of all selected sections.  This is
     the case when the region begins in the heading of a section and
     ends in the heading of the same section or in that of a sibling
     section.  If optional MULTIPLE is non-nil, then the region cannot
     begin and end in the same section.

     When the selection is not valid, then return nil.  In this case,
     most commands that can act on the selected sections will instead
     act on the section at point.

     When the region looks like it would in any other buffer then the
     selection is invalid.  When the selection is valid then the region
     uses the ‘magit-section-highlight’ face.  This does not apply to
     diffs where things get a bit more complicated, but even here if the
     region looks like it usually does, then that’s not a valid
     selection as far as this function is concerned.

     If optional CONDITION is non-nil, then the selection not only has
     to be valid; all selected sections additionally have to match
     CONDITION, or nil is returned.  See ‘magit-section-match’ for the
     forms CONDITION can take.

 -- Function: magit-region-values &optional condition multiple

     Return a list of the values of the selected sections.

     Return the values that themselves would be returned by
     ‘magit-region-sections’ (which see).


File: magit.ja.info,  Node: Matching Sections,  Prev: Section Selection,  Up: Section Plumbing

10.2.3 Matching Sections
------------------------

‘M-x magit-describe-section-briefly’     (‘magit-describe-section-briefly’)

     Show information about the section at point.  This command is
     intended for debugging purposes.

 -- Function: magit-section-ident section

     Return an unique identifier for SECTION.  The return value has the
     form ‘((TYPE . VALUE)...)’.

 -- Function: magit-get-section ident &optional root

     Return the section identified by IDENT.  IDENT has to be a list as
     returned by ‘magit-section-ident’.

 -- Function: magit-section-match condition &optional section

     Return ‘t’ if SECTION matches CONDITION.  SECTION defaults to the
     section at point.  If SECTION is not specified and there also is no
     section at point, then return ‘nil’.

     CONDITION can take the following forms:
        • ‘(CONDITION...)’

          matches if any of the CONDITIONs matches.

        • ‘[CLASS...]’

          matches if the section’s class is the same as the first CLASS
          or a subclass of that; the section’s parent class matches the
          second CLASS; and so on.

        • ‘[* CLASS...]’

          matches sections that match ‘[CLASS...]’ and also recursively
          all their child sections.

        • ‘CLASS’

          matches if the section’s class is the same as CLASS or a
          subclass of that; regardless of the classes of the parent
          sections.

     Each CLASS should be a class symbol, identifying a class that
     derives from ‘magit-section’.  For backward compatibility CLASS can
     also be a "type symbol".  A section matches such a symbol if the
     value of its ‘type’ slot is ‘eq’.  If a type symbol has an entry in
     ‘magit--section-type-alist’, then a section also matches that type
     if its class is a subclass of the class that corresponds to the
     type as per that alist.

     Note that it is not necessary to specify the complete section
     lineage as printed by ‘magit-describe-section-briefly’, unless of
     course you want to be that precise.

 -- Function: magit-section-value-if condition &optional section

     If the section at point matches CONDITION, then return its value.

     If optional SECTION is non-nil then test whether that matches
     instead.  If there is no section at point and SECTION is nil, then
     return nil.  If the section does not match, then return nil.

     See ‘magit-section-match’ for the forms CONDITION can take.

 -- Function: magit-section-case &rest clauses

     Choose among clauses on the type of the section at point.

     Each clause looks like (CONDITION BODY...).  The type of the
     section is compared against each CONDITION; the BODY forms of the
     first match are evaluated sequentially and the value of the last
     form is returned.  Inside BODY the symbol ‘it’ is bound to the
     section at point.  If no clause succeeds or if there is no section
     at point return nil.

     See ‘magit-section-match’ for the forms CONDITION can take.
     Additionally a CONDITION of t is allowed in the final clause and
     matches if no other CONDITION match, even if there is no section at
     point.

 -- Variable: magit-root-section

     The root section in the current buffer.  All other sections are
     descendants of this section.  The value of this variable is set by
     ‘magit-insert-section’ and you should never modify it.

For diff related sections a few additional tools exist.

 -- Function: magit-diff-type &optional section

     Return the diff type of SECTION.

     The returned type is one of the symbols ‘staged’, ‘unstaged’,
     ‘committed’, or ‘undefined’.  This type serves a similar purpose as
     the general type common to all sections (which is stored in the
     ‘type’ slot of the corresponding ‘magit-section’ struct) but takes
     additional information into account.  When the SECTION isn’t
     related to diffs and the buffer containing it also isn’t a
     diff-only buffer, then return nil.

     Currently the type can also be one of ‘tracked’ and ‘untracked’,
     but these values are not handled explicitly in every place they
     should be.  A possible fix could be to just return nil here.

     The section has to be a ‘diff’ or ‘hunk’ section, or a section
     whose children are of type ‘diff’.  If optional SECTION is nil,
     return the diff type for the current section.  In buffers whose
     major mode is ‘magit-diff-mode’ SECTION is ignored and the type is
     determined using other means.  In ‘magit-revision-mode’ buffers the
     type is always ‘committed’.

 -- Function: magit-diff-scope &optional section strict

     Return the diff scope of SECTION or the selected section(s).

     A diff’s "scope" describes what part of a diff is selected, it is a
     symbol, one of ‘region’, ‘hunk’, ‘hunks’, ‘file’, ‘files’, or
     ‘list’.  Do not confuse this with the diff "type", as returned by
     ‘magit-diff-type’.

     If optional SECTION is non-nil, then return the scope of that,
     ignoring the sections selected by the region.  Otherwise return the
     scope of the current section, or if the region is active and
     selects a valid group of diff related sections, the type of these
     sections, i.e.  ‘hunks’ or ‘files’.  If SECTION (or if the current
     section that is nil) is a ‘hunk’ section and the region starts and
     ends inside the body of a that section, then the type is ‘region’.

     If optional STRICT is non-nil then return nil if the diff type of
     the section at point is ‘untracked’ or the section at point is not
     actually a ‘diff’ but a ‘diffstat’ section.


File: magit.ja.info,  Node: Refreshing Buffers,  Next: 慣習,  Prev: Section Plumbing,  Up: 配管コマンド(Plumbing)

10.3 Refreshing Buffers
=======================

All commands that create a new Magit buffer or change what is being
displayed in an existing buffer do so by calling ‘magit-mode-setup’.
Among other things, that function sets the buffer local values of
‘default-directory’ (to the top-level of the repository),
‘magit-refresh-function’, and ‘magit-refresh-args’.

Buffers are refreshed by calling the function that is the local value of
‘magit-refresh-function’ (a function named ‘magit-*-refresh-buffer’,
where ‘*’ may be something like ‘diff’) with the value of
‘magit-refresh-args’ as arguments.

 -- Macro: magit-mode-setup buffer switch-func mode refresh-func
          &optional refresh-args

     This function displays and selects BUFFER, turns on MODE, and
     refreshes a first time.

     This function displays and optionally selects BUFFER by calling
     ‘magit-mode-display-buffer’ with BUFFER, MODE and SWITCH-FUNC as
     arguments.  Then it sets the local value of
     ‘magit-refresh-function’ to REFRESH-FUNC and that of
     ‘magit-refresh-args’ to REFRESH-ARGS.  Finally it creates the
     buffer content by calling REFRESH-FUNC with REFRESH-ARGS as
     arguments.

     All arguments are evaluated before switching to BUFFER.

 -- Function: magit-mode-display-buffer buffer mode &optional
          switch-function

     This function display BUFFER in some window and select it.  BUFFER
     may be a buffer or a string, the name of a buffer.  The buffer is
     returned.

     Unless BUFFER is already displayed in the selected frame, store the
     previous window configuration as a buffer local value, so that it
     can later be restored by ‘magit-mode-bury-buffer’.

     The buffer is displayed and selected using SWITCH-FUNCTION.  If
     that is ‘nil’ then ‘pop-to-buffer’ is used if the current buffer’s
     major mode derives from ‘magit-mode’.  Otherwise ‘switch-to-buffer’
     is used.

 -- Variable: magit-refresh-function

     The value of this buffer-local variable is the function used to
     refresh the current buffer.  It is called with ‘magit-refresh-args’
     as arguments.

 -- Variable: magit-refresh-args

     The list of arguments used by ‘magit-refresh-function’ to refresh
     the current buffer.  ‘magit-refresh-function’ is called with these
     arguments.

     The value is usually set using ‘magit-mode-setup’, but in some
     cases it’s also useful to provide commands that can change the
     value.  For example, the ‘magit-diff-refresh’ transient can be used
     to change any of the arguments used to display the diff, without
     having to specify again which differences should be shown, but
     ‘magit-diff-more-context’, ‘magit-diff-less-context’ and
     ‘magit-diff-default-context’ change just the ‘-U<N>’ argument.  In
     both case this is done by changing the value of this variable and
     then calling this ‘magit-refresh-function’.


File: magit.ja.info,  Node: 慣習,  Prev: Refreshing Buffers,  Up: 配管コマンド(Plumbing)

10.4 慣習
=========

こちらもご覧ください→*note 補完と確認::

* Menu:

* Theming Faces::


File: magit.ja.info,  Node: Theming Faces,  Up: 慣習

10.4.1 Theming Faces
--------------------

The default theme uses blue for local branches, green for remote
branches, and goldenrod (brownish yellow) for tags.  When creating a new
theme, you should probably follow that example.  If your theme already
uses other colors, then stick to that.

In older releases these reference faces used to have a background color
and a box around them.  The basic default faces no longer do so, to make
Magit buffers much less noisy, and you should follow that example at
least with regards to boxes.  (Boxes were used in the past to work
around a conflict between the highlighting overlay and text property
backgrounds.  That’s no longer necessary because highlighting no longer
causes other background colors to disappear.)  Alternatively you can
keep the background color and/or box, but then have to take special care
to adjust ‘magit-branch-current’ accordingly.  By default it looks
mostly like ‘magit-branch-local’, but with a box (by default the former
is the only face that uses a box, exactly so that it sticks out).  If
the former also uses a box, then you have to make sure that it differs
in some other way from the latter.

The most difficult faces to theme are those related to diffs, headings,
highlighting, and the region.  There are faces that fall into all four
groups - expect to spend some time getting this right.

The ‘region’ face in the default theme, in both the light and dark
variants, as well as in many other themes, distributed with Emacs or by
third-parties, is very ugly.  It is common to use a background color
that really sticks out, which is ugly but if that were the only problem
then it would be acceptable.  Unfortunately many themes also set the
foreground color, which ensures that all text within the region is
readable.  Without doing that there might be cases where some foreground
color is too close to the region background color to still be readable.
But it also means that text within the region loses all syntax
highlighting.

I consider the work that went into getting the ‘region’ face right to be
a good indicator for the general quality of a theme.  My recommendation
for the ‘region’ face is this: use a background color slightly different
from the background color of the ‘default’ face, and do not set the
foreground color at all.  So for a light theme you might use a light
(possibly tinted) gray as the background color of ‘default’ and a
somewhat darker gray for the background of ‘region’.  That should
usually be enough to not collide with the foreground color of any other
face.  But if some other faces also set a light gray as background
color, then you should also make sure it doesn’t collide with those (in
some cases it might be acceptable though).

Magit only uses the ‘region’ face when the region is "invalid" by its
own definition.  In a Magit buffer the region is used to either select
multiple sibling sections, so that commands which support it act on all
of these sections instead of just the current section, or to select
lines within a single hunk section.  In all other cases, the section is
considered invalid and Magit won’t act on it.  But such invalid sections
happen, either because the user has not moved point enough yet to make
it valid or because she wants to use a non-magit command to act on the
region, e.g.  ‘kill-region’.

So using the regular ‘region’ face for invalid sections is a feature.
It tells the user that Magit won’t be able to act on it.  It’s
acceptable if that face looks a bit odd and even (but less so) if it
collides with the background colors of section headings and other things
that have a background color.

Magit highlights the current section.  If a section has subsections,
then all of them are highlighted.  This is done using faces that have
"highlight" in their names.  For most sections,
‘magit-section-highlight’ is used for both the body and the heading.
Like the ‘region’ face, it should only set the background color to
something similar to that of ‘default’.  The highlight background color
must be different from both the ‘region’ background color and the
‘default’ background color.

For diff related sections Magit uses various faces to highlight
different parts of the selected section(s).  Note that hunk headings,
unlike all other section headings, by default have a background color,
because it is useful to have very visible separators between hunks.
That face ‘magit-diff-hunk-heading’, should be different from both
‘magit-diff-hunk-heading-highlight’ and ‘magit-section-highlight’, as
well as from ‘magit-diff-context’ and ‘magit-diff-context-highlight’.
By default we do that by changing the foreground color.  Changing the
background color would lead to complications, and there are already
enough we cannot get around.  (Also note that it is generally a good
idea for section headings to always be bold, but only for sections that
have subsections).

When there is a valid region selecting diff-related sibling sections,
i.e.  multiple files or hunks, then the bodies of all these sections use
the respective highlight faces, but additionally the headings instead
use one of the faces ‘magit-diff-file-heading-selection’ or
‘magit-diff-hunk-heading-selection’.  These faces have to be different
from the regular highlight variants to provide explicit visual
indication that the region is active.

When theming diff related faces, start by setting the option
‘magit-diff-refine-hunk’ to ‘all’.  You might personally prefer to only
refine the current hunk or not use hunk refinement at all, but some of
the users of your theme want all hunks to be refined, so you have to
cater to that.

(Also turn on ‘magit-diff-highlight-indentation’,
‘magit-diff-highlight-trailing’, and ‘magit-diff-paint-whitespace’; and
insert some whitespace errors into the code you use for testing.)

For e.g.  "added lines" you have to adjust three faces:
‘magit-diff-added’, ‘magit-diff-added-highlight’, and
‘smerge-refined-added’.  Make sure that the latter works well with both
of the former, as well as ‘smerge-other’ and ‘diff-added’.  Then do the
same for the removed lines, context lines, lines added by us, and lines
added by them.  Also make sure the respective added, removed, and
context faces use approximately the same saturation for both the
highlighted and unhighlighted variants.  Also make sure the file and
diff headings work nicely with context lines (e.g.  make them look
different).  Line faces should set both the foreground and the
background color.  For example, for added lines use two different
greens.

It’s best if the foreground color of both the highlighted and the
unhighlighted variants are the same, so you will need to have to find a
color that works well on the highlight and unhighlighted background, the
refine background, and the highlight context background.  When there is
an hunk internal region, then the added- and removed-lines background
color is used only within that region.  Outside the region the
highlighted context background color is used.  This makes it easier to
see what is being staged.  With an hunk internal region the hunk heading
is shown using ‘magit-diff-hunk-heading-selection’, and so are the thin
lines that are added around the lines that fall within the region.  The
background color of that has to be distinct enough from the various
other involved background colors.

Nobody said this would be easy.  If your theme restricts itself to a
certain set of colors, then you should make an exception here.
Otherwise it would be impossible to make the diffs look good in each and
every variation.  Actually you might want to just stick to the default
definitions for these faces.  You have been warned.  Also please note
that if you do not get this right, this will in some cases look to users
like bugs in Magit - so please do it right or not at all.


File: magit.ja.info,  Node: FAQ,  Next: Debugging Tools,  Prev: 配管コマンド(Plumbing),  Up: Top

Appendix A FAQ
**************

次の2つのノードには、よくある質問が一覧表示されます。よくある*および最近
*の質問、つまりまだマニュアルに記載されていない質問のリストについては
→<https://github.com/magit/magit/wiki/FAQ>

デバッグツールも使用できます→*note Debugging Tools::

* Menu:

* FAQ - How to ...?::
* FAQ - Issues and Errors::


File: magit.ja.info,  Node: FAQ - How to ...?,  Next: FAQ - Issues and Errors,  Up: FAQ

A.1 FAQ - How to ...?
=====================

* Menu:

* Magitの発音は？::
* How to show git's output?::
* How to install the gitman info manual?::
* How to show diffs for gpg-encrypted files?::
* How does branching and pushing work?::
* Magitをediff-version-control-packageとして使用できますか？::
* VC@を無効にする必要がありますか？::


File: magit.ja.info,  Node: Magitの発音は？,  Next: How to show git's output?,  Up: FAQ - How to ...?

A.1.1 Magitの発音は？
---------------------

‘mu[m's] git’または‘magi{c => t}’のいずれかで問題ありません。

スローガンは "It’s Magit!  The magical Git client" なので、magiCと
magiTが同じように聞こえないことを考慮しながら、Magitをmagic(魔法)のよう
に発音するのは理にかなっています。(訳注「マジット」)

ドイツ語の「Magie」は英語の「magic」と同じ発音ではないため、ドイツ語を話
す場合は、上記の合理性を使用して前者の発音を使用することを正当化できます
。‘Mag{ie => it}’

以前の発音が好きだからといって、前者の発音を使用することもできます。

<https://magit.vc/assets/videos/magic.mp4>(訳注:2021年現在ファイルが存在
しない模様)。


File: magit.ja.info,  Node: How to show git's output?,  Next: How to install the gitman info manual?,  Prev: Magitの発音は？,  Up: FAQ - How to ...?

A.1.2 How to show git’s output?
-------------------------------

最近実行されたgitコマンドの出力を表示するには、‘$’(または、それが利用で
きない場合は‘M-x magit-process-buffer’)を押します。これにより、git呼び出
しごとのセクションを含むバッファが表示されます。いつものように‘TAB’を押
して展開または折りたたみできます。

デフォルトでは、gitの出力は、副作用の目的のために実行された場合にのみプ
ロセスバッファに挿入されます。出力が何らかの方法で消費される場合、それを
プロセスバッファに挿入することもコストがかかりすぎます。デバッグの目的で
、‘magit-git-debug’を‘t’に設定することで、とにかくそうすることができます
。


File: magit.ja.info,  Node: How to install the gitman info manual?,  Next: How to show diffs for gpg-encrypted files?,  Prev: How to show git's output?,  Up: FAQ - How to ...?

A.1.3 How to install the gitman info manual?
--------------------------------------------

Gitのmanpage達は、‘gitman’というinfoマニュアルとしてエクスポートできます
。Infoはmampageへのリンクをサポートしていないため、Magit独自のinfoマニュ
アルは実際のmanpageではなくそのマニュアルのノードにリンクしています。

残念ながら、一部のディストリビューションではデフォルトで‘gitman’マニュア
ルがインストールされていないため、入手するには別のドキュメントパッケージ
をインストールする必要があります。

Magitは、それぞれのmanpageを表示する代わりに、‘gitman’ infoマニュアルへ
のリンクにアクセスする機能を追加するInfoにパッチを適用します。そのアプロ
ーチを好む場合は、‘magit-view-git-manual-method’の値をサポートされている
パッケージ‘man’または‘woman’のいずれかに設定します。例:

     (setq magit-view-git-manual-method 'man)


File: magit.ja.info,  Node: How to show diffs for gpg-encrypted files?,  Next: How does branching and pushing work?,  Prev: How to install the gitman info manual?,  Up: FAQ - How to ...?

A.1.4 How to show diffs for gpg-encrypted files?
------------------------------------------------

Git supports showing diffs for encrypted files, but has to be told to do
so.  Since Magit just uses Git to get the diffs, configuring Git also
affects the diffs displayed inside Magit.

     git config --global diff.gpg.textconv "gpg --no-tty --decrypt"
     echo "*.gpg filter=gpg diff=gpg" > .gitattributes


File: magit.ja.info,  Node: How does branching and pushing work?,  Next: Magitをediff-version-control-packageとして使用できますか？,  Prev: How to show diffs for gpg-encrypted files?,  Up: FAQ - How to ...?

A.1.5 How does branching and pushing work?
------------------------------------------

Please see *note Branching:: and
<http://emacsair.me/2016/01/18/magit-2.4>


File: magit.ja.info,  Node: Magitをediff-version-control-packageとして使用できますか？,  Next: VC@を無効にする必要がありますか？,  Prev: How does branching and pushing work?,  Up: FAQ - How to ...?

A.1.6 Magitを‘ediff-version-control-package’として使用できますか？
------------------------------------------------------------------

No, it cannot.  For that to work the functions ‘ediff-magit-internal’
and ‘ediff-magit-merge-internal’ would have to be implemented, and they
are not.  These two functions are only used by the three commands
‘ediff-revision’, ‘ediff-merge-revisions-with-ancestor’, and
‘ediff-merge-revisions’.

These commands only delegate the task of populating buffers with certain
revisions to the "internal" functions.  The equally important task of
determining which revisions are to be compared/merged is not delegated.
Instead this is done without any support whatsoever from the version
control package/system - meaning that the user has to enter the
revisions explicitly.  Instead of implementing ‘ediff-magit-internal’ we
provide ‘magit-ediff-compare’, which handles both tasks like it is 2005.

The other commands ‘ediff-merge-revisions’ and
‘ediff-merge-revisions-with-ancestor’ are normally not what you want
when using a modern version control system like Git.  Instead of letting
the user resolve only those conflicts which Git could not resolve on its
own, they throw away all work done by Git and then expect the user to
manually merge all conflicts, including those that had already been
resolved.  That made sense back in the days when version control systems
couldn’t merge (or so I have been told), but not anymore.  Once in a
blue moon you might actually want to see all conflicts, in which case
you *can* use these commands, which then use ‘ediff-vc-merge-internal’.
So we don’t actually have to implement ‘ediff-magit-merge-internal’.
Instead we provide the more useful command ‘magit-ediff-resolve’ which
only shows yet-to-be resolved conflicts.


File: magit.ja.info,  Node: VC@を無効にする必要がありますか？,  Prev: Magitをediff-version-control-packageとして使用できますか？,  Up: FAQ - How to ...?

A.1.7 VC@を無効にする必要がありますか？
---------------------------------------

If you don’t use VC (the built-in version control interface) then you
might be tempted to disable it, not least because we used to recommend
that you do that.

We no longer recommend that you disable VC.  Doing so would break useful
third-party packages (such as ‘diff-hl’), which depend on VC being
enabled.

If you choose to disable VC anyway, then you can do so by changing the
value of ‘vc-handled-backends’.


File: magit.ja.info,  Node: FAQ - Issues and Errors,  Prev: FAQ - How to ...?,  Up: FAQ

A.2 FAQ - Issues and Errors
===========================

* Menu:

* Magit is slow::
* 一度に数千のファイルを変更したらMagitが使用できなくなりました::
* コミットに問題があります::
* MS WindowsではMagitでpushできません::
* I am using OS X and SOMETHING works in shell, but not in Magit: I am using OS X and SOMETHING works in shell but not in Magit.
* ファイルを展開して差分を表示するとファイルが消えます::
* COMMIT_EDITMSGバッファのpointが間違っています::
* モード行の情報が常に最新ではない::
* 同じ名前を共有するブランチとタグは何かを壊します::
* 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません::
* コマンドラインからコミットする場合、git-commit-modeは使用されません::
* file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内に表示されています::
* MS-WindowsからEmacsのTrampモードを使用するとステージできません::
* 私はポップアップのデフォルトを保存できなくなりました::


File: magit.ja.info,  Node: Magit is slow,  Next: 一度に数千のファイルを変更したらMagitが使用できなくなりました,  Up: FAQ - Issues and Errors

A.2.1 Magit is slow
-------------------

See *note Performance::.


File: magit.ja.info,  Node: 一度に数千のファイルを変更したらMagitが使用できなくなりました,  Next: コミットに問題があります,  Prev: Magit is slow,  Up: FAQ - Issues and Errors

A.2.2 一度に数千のファイルを変更したらMagitが使用できなくなりました
-------------------------------------------------------------------

Magit is *currently* not expected to work under such conditions.  It
sure would be nice if it did, and v2.5 will hopefully be a big step into
that direction.  But it might take until v3.1 to accomplish fully
satisfactory performance, because that requires some heavy refactoring.

But for now we recommend you use the command line to complete this one
commit.  Also see *note Performance::.


File: magit.ja.info,  Node: コミットに問題があります,  Next: MS WindowsではMagitでpushできません,  Prev: 一度に数千のファイルを変更したらMagitが使用できなくなりました,  Up: FAQ - Issues and Errors

A.2.3 コミットに問題があります
------------------------------

これは、Magitが適切なemacsclient実行可能ファイルを見つけるのに問題がある
ことを意味している可能性があります(*note (with-editor)Configuring
With-Editor:: and *note (with-editor)Debugging::)。


File: magit.ja.info,  Node: MS WindowsではMagitでpushできません,  Next: I am using OS X and SOMETHING works in shell but not in Magit,  Prev: コミットに問題があります,  Up: FAQ - Issues and Errors

A.2.4 MS WindowsではMagitでpushできません
-----------------------------------------

Magitにありがちな問題であることはほぼ確実です。あなたがコマンドラインで
pushできる場合、構成(configuration)の問題である可能性が限りなく高いです
。

詳細なセットアップ手順は、
<https://github.com/magit/magit/wiki/Pushing-with-Magit-from-Windows>に
あります。


File: magit.ja.info,  Node: I am using OS X and SOMETHING works in shell but not in Magit,  Next: ファイルを展開して差分を表示するとファイルが消えます,  Prev: MS WindowsではMagitでpushできません,  Up: FAQ - Issues and Errors

A.2.5 I am using OS X and SOMETHING works in shell, but not in Magit
--------------------------------------------------------------------

This usually occurs because Emacs doesn’t have the same environment
variables as your shell.  Try installing and configuring
<https://github.com/purcell/exec-path-from-shell>.  By default it
synchronizes ‘$PATH’, which helps Magit find the same ‘git’ as the one
you are using on the shell.

If SOMETHING is "passphrase caching with gpg-agent for commit and/or tag
signing", then you’ll also need to synchronize ‘$GPG_AGENT_INFO’.


File: magit.ja.info,  Node: ファイルを展開して差分を表示するとファイルが消えます,  Next: COMMIT_EDITMSGバッファのpointが間違っています,  Prev: I am using OS X and SOMETHING works in shell but not in Magit,  Up: FAQ - Issues and Errors

A.2.6 ファイルを展開して差分を表示するとファイルが消えます
----------------------------------------------------------

This is probably caused by a change of a ‘diff.*’ Git variable.  You
probably set that variable for a reason, and should therefore only undo
that setting in Magit by customizing ‘magit-git-global-arguments’.


File: magit.ja.info,  Node: COMMIT_EDITMSGバッファのpointが間違っています,  Next: モード行の情報が常に最新ではない,  Prev: ファイルを展開して差分を表示するとファイルが消えます,  Up: FAQ - Issues and Errors

A.2.7 ‘COMMIT_EDITMSG’バッファのpointが間違っています
-----------------------------------------------------

Neither Magit nor ‘git-commit‘ fiddle with point in the buffer used to
write commit messages, so something else must be doing it.

You have probably globally enabled a mode which does restore point in
file-visiting buffers.  It might be a bit surprising, but when you write
a commit message, then you are actually editing a file.

So you have to figure out which package is doing.  ‘saveplace’,
‘pointback’, and ‘session’ are likely candidates.  These snippets might
help:

     (setq session-name-disable-regexp "\\(?:\\`'\\.git/[A-Z_]+\\'\\)")

     (with-eval-after-load 'pointback
       (lambda ()
         (when (or git-commit-mode git-rebase-mode)
           (pointback-mode -1))))


File: magit.ja.info,  Node: モード行の情報が常に最新ではない,  Next: 同じ名前を共有するブランチとタグは何かを壊します,  Prev: COMMIT_EDITMSGバッファのpointが間違っています,  Up: FAQ - Issues and Errors

A.2.8 モード行の情報が常に最新ではない
--------------------------------------

Magitは、モードラインに表示されている‘Git-master’のようなバージョン管理
情報については責任を負いません。「VC」とも呼ばれる組み込みの「バージョン
管理」パッケージは、その情報を更新し、より頻繁に更新するように指示できま
す:

     (setq auto-revert-check-vc-info t)

しかし、そうするとフォーマンスが悪化します。 より多くの(過度に楽観的な
)情報については→*note (emacs)VC Mode Line::

あなたがこの情報をモード行に表示するこをあまり気にしないなら、_不正確な
_情報を単にモード行に表示しないことを検討してください。

     (setq-default mode-line-format
                   (delete '(vc-mode vc-mode) mode-line-format))


File: magit.ja.info,  Node: 同じ名前を共有するブランチとタグは何かを壊します,  Next: 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません,  Prev: モード行の情報が常に最新ではない,  Up: FAQ - Issues and Errors

A.2.9 同じ名前を共有するブランチとタグは何かを壊します
------------------------------------------------------

Or more generally, ambiguous refnames break SOMETHING.

Magit assumes that refs are named non-ambiguously across the
"refs/heads/", "refs/tags/", and "refs/remotes/" namespaces (i.e., all
the names remain unique when those prefixes are stripped).  We consider
ambiguous refnames unsupported and recommend that you use a
non-ambiguous naming scheme.  However, if you do work with a repository
that has ambiguous refnames, please report any issues you encounter so
that we can investigate whether there is a simple fix.


File: magit.ja.info,  Node: 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません,  Next: コマンドラインからコミットする場合、git-commit-modeは使用されません,  Prev: 同じ名前を共有するブランチとタグは何かを壊します,  Up: FAQ - Issues and Errors

A.2.10 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません
-----------------------------------------------------------------------------

When Magit calls ‘git’ it adds a few global arguments including
‘--literal-pathspecs’ and the ‘git’ process started by Magit then passes
that setting on to other ‘git’ process it starts itself.  It does so by
setting the environment variable ‘GIT_LITERAL_PATHSPECS’, not by calling
subprocesses with the ‘--literal-pathspecs’ argument.  You can therefore
override this setting in hook scripts using ‘unset
GIT_LITERAL_PATHSPECS’.


File: magit.ja.info,  Node: コマンドラインからコミットする場合、git-commit-modeは使用されません,  Next: file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内に表示されています,  Prev: 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません,  Up: FAQ - Issues and Errors

A.2.11 コマンドラインからコミットする場合、‘git-commit-mode’は使用されません
----------------------------------------------------------------------------

The reason for this is that ‘git-commit.el’ has not been loaded yet
and/or that the server has not been started yet.  These things have
always already been taken care of when you commit from Magit because in
order to do so, Magit has to be loaded and doing that involves loading
‘git-commit’ and starting the server.

If you want to commit from the command-line, then you have to take care
of these things yourself.  Your ‘init.el’ file should contain:

     (require 'git-commit)
     (server-mode)

Instead of ‘(require ’git-commit)‘ you may also use:

     (load "/path/to/magit-autoloads.el")

You might want to do that because loading ‘git-commit’ causes large
parts of Magit to be loaded.

There are also some variations of ‘(server-mode)’ that you might want to
try.  Personally I use:

     (use-package server
       :config (or (server-running-p) (server-mode)))

Now you can use:

     $ emacs&
     $ EDITOR=emacsclient git commit

However you cannot use:

     $ killall emacs
     $ EDITOR="emacsclient --alternate-editor emacs" git commit

This will actually end up using ‘emacs’, not ‘emacsclient’.  If you do
this, then you can still edit the commit message but ‘git-commit-mode’
won’t be used and you have to exit ‘emacs’ to finish the process.

Tautology ahead.  If you want to be able to use ‘emacsclient’ to connect
to a running ‘emacs’ instance, even though no ‘emacs’ instance is
running, then you cannot use ‘emacsclient’ directly.

Instead you have to create a script that does something like this:

Try to use ‘emacsclient’ (without using ‘--alternate-editor’).  If that
succeeds, do nothing else.  Otherwise start ‘emacs &’ (and ‘init.el’
must call ‘server-start’) and try to use ‘emacsclient’ again.


File: magit.ja.info,  Node: file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内に表示されています,  Next: MS-WindowsからEmacsのTrampモードを使用するとステージできません,  Prev: コマンドラインからコミットする場合、git-commit-modeは使用されません,  Up: FAQ - Issues and Errors

A.2.12 file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内に表示されています
--------------------------------------------------------------------------------------------

This can happen when you type ‘RET’ on a hunk to visit the respective
file at the respective position.  One solution to this problem is to use
‘global-reveal-mode’.  It makes sure that text around point is always
visible.  If that is too drastic for your taste, then you may instead
use ‘magit-diff-visit-file-hook’ to reveal the text, possibly using
‘reveal-post-command’ or for Org buffers ‘org-reveal’.


File: magit.ja.info,  Node: MS-WindowsからEmacsのTrampモードを使用するとステージできません,  Next: 私はポップアップのデフォルトを保存できなくなりました,  Prev: file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内に表示されています,  Up: FAQ - Issues and Errors

A.2.13 MS-WindowsからEmacsのTrampモードを使用するとステージできません
---------------------------------------------------------------------

Magit may be unable to stage (or otherwise apply) individual hunks when
you are connected to remote machine using Tramp and the local machine
uses MS Windows.

There appears to be a problem with ‘process-send-eof’ in this scenario,
as mentioned at the end of ‘tramp-tests.el’.  I have contacted the Tramp
maintainer about this.  For now this unfortunately means that it just
doesn’t work and we cannot do anything about it.  If you have more
information, then please comment on
<https://github.com/magit/magit/issues/3624>.


File: magit.ja.info,  Node: 私はポップアップのデフォルトを保存できなくなりました,  Prev: MS-WindowsからEmacsのTrampモードを使用するとステージできません,  Up: FAQ - Issues and Errors

A.2.14 私はポップアップのデフォルトを保存できなくなりました
-----------------------------------------------------------

Magit used to use Magit-Popup to implement the transient popup menus.
Now it used Transient instead, which is Magit-Popup’s successor.

In the older Magit-Popup menus, it was possible to save user settings
(e.g.  setting the gpg signing key for commits) by using ‘C-c C-c’ in
the popup buffer.  This would dismiss the popup, but save the settings
as the defaults for future popups.

When switching to Transient menus, this functionality is now available
via ‘C-x C-s’ instead; the ‘C-x’ prefix has other options as well when
using Transient, which will be displayed when it is typed.  See
<https://magit.vc/manual/transient/Saving-Values.html#Saving-Values> for
more details.


File: magit.ja.info,  Node: Debugging Tools,  Next: Keystroke Index,  Prev: FAQ,  Up: Top

B Debugging Tools
*****************

Magitとその依存関係には、いくつかのデバッグツールが用意されています。問
題を報告する前にこれらのツールを使用していただければ幸いです。問題を報告
するときは、関連するすべての出力を含めてください。

‘M-x magit-version’     (‘magit-version’)

     このコマンドは、現在使用されているMagit、Git、およびEmacsのバージョ
     ンをエコー領域に表示します。非インタラクティブでは、これは単に
     Magitバージョンを返すだけです。

‘M-x magit-emacs-Q-command’     (‘magit-emacs-Q-command’)

     このコマンドは、エコー領域にデバッグシェルコマンドを表示し、それを
     キルリングに追加します。そのコマンドをシェルに貼り付けして実行しま
     す。

     このシェルコマンドは、‘magit’とその依存関係のみがロードされた状態で
     ‘emacs’を開始します。構成も他のインストール済みパッケージもロードさ
     れません。これにより、Magitに問題があるのか他の問題にあるのかを簡単
     に判断できます。

     あなたがMagitをそのGitリポジトリから実行する場合は、このコマンドの
     出力の代わりに‘make emacs-Q’を使用できるはずです。

‘M-x magit-toggle-verbose-refresh’     (‘magit-toggle-verbose-refresh’)

     このコマンドは、Magitがバッファを詳細に更新するかどうかを切り替えま
     す。これを有効にすると、どのセクションがボトルネックであるかを把握
     するのに役立ちます。追加の出力は、‘*Messages*’バッファにあります。

‘M-x magit-debug-git-executable’     (‘magit-debug-git-executable’)

     このコマンドは、使用可能で使用されている‘git’実行可能ファイルに関す
     る情報を含むバッファを表示し、‘exec-path’の問題を調査するときに役立
     ちます。

     こちらもご覧ください→*note Git実行ファイル::

‘M-x with-editor-debug’     (‘with-editor-debug’)

     このコマンドは、使用可能で使用されている‘emacsclient’実行可能ファイ
     ルに関する情報を含むバッファを表示し、Magit(または‘with-editor’)が
     適切な‘emacsclient’実行可能ファイルを見つけられない理由を調査すると
     きに役立ちます。

     こちらもご覧ください→*note (with-editor)Debugging::

FAQもご覧ください→*note FAQ::


File: magit.ja.info,  Node: Keystroke Index,  Next: Command Index,  Prev: Debugging Tools,  Up: Top

Appendix C Keystroke Index
**************************

 [index ]
* Menu:

* !:                                     Gitを手動で実行.     (line  11)
* ! !:                                   Gitを手動で実行.     (line  17)
* ! a:                                   Gitを手動で実行.     (line  58)
* ! b:                                   Gitを手動で実行.     (line  62)
* ! g:                                   Gitを手動で実行.     (line  66)
* ! k:                                   Gitを手動で実行.     (line  54)
* ! p:                                   Gitを手動で実行.     (line  25)
* ! s:                                   Gitを手動で実行.     (line  35)
* ! S:                                   Gitを手動で実行.     (line  40)
* $:                                     Viewing Git Output.  (line  16)
* %:                                     Worktree.            (line   8)
* % b:                                   Worktree.            (line  14)
* % c:                                   Worktree.            (line  18)
* % g:                                   Worktree.            (line  31)
* % k:                                   Worktree.            (line  26)
* % m:                                   Worktree.            (line  22)
* +:                                     Log Buffer.          (line  72)
* + <1>:                                 Refreshing Diffs.    (line  66)
* -:                                     Log Buffer.          (line  76)
* - <1>:                                 Refreshing Diffs.    (line  61)
* 0:                                     Refreshing Diffs.    (line  71)
* 1:                                     Section Visibility.  (line  25)
* 2:                                     Section Visibility.  (line  26)
* 3:                                     Section Visibility.  (line  27)
* 4:                                     Section Visibility.  (line  28)
* =:                                     Log Buffer.          (line  66)
* ^:                                     Section Movement.    (line  29)
* a:                                     Applying.            (line  35)
* A:                                     Cherry Picking.      (line   8)
* A A:                                   Cherry Picking.      (line  18)
* A a:                                   Cherry Picking.      (line  25)
* A A <1>:                               Cherry Picking.      (line  91)
* A a <1>:                               Cherry Picking.      (line  99)
* A d:                                   Cherry Picking.      (line  55)
* A h:                                   Cherry Picking.      (line  43)
* A n:                                   Cherry Picking.      (line  66)
* A s:                                   Cherry Picking.      (line  77)
* A s <1>:                               Cherry Picking.      (line  95)
* B:                                     Bisecting.           (line   8)
* b:                                     Blaming.             (line 103)
* b <1>:                                 Branch Commands.     (line  12)
* b <2>:                                 Editing Rebase Sequences.
                                                              (line  85)
* B B:                                   Bisecting.           (line  17)
* B b:                                   Bisecting.           (line  35)
* b b:                                   Branch Commands.     (line  50)
* b C:                                   Branch Commands.     (line  30)
* b c:                                   Branch Commands.     (line  68)
* B g:                                   Bisecting.           (line  40)
* B k:                                   Bisecting.           (line  52)
* b k:                                   Branch Commands.     (line 148)
* b l:                                   Branch Commands.     (line  75)
* B m:                                   Bisecting.           (line  45)
* b n:                                   Branch Commands.     (line  58)
* B r:                                   Bisecting.           (line  58)
* b r:                                   Branch Commands.     (line 154)
* B s:                                   Bisecting.           (line  28)
* b s:                                   Branch Commands.     (line  98)
* b S:                                   Branch Commands.     (line 126)
* b x:                                   Branch Commands.     (line 132)
* c:                                     Blaming.             (line 136)
* C:                                     Cloning Repository.  (line  20)
* c <1>:                                 コミット開始.        (line   8)
* c <2>:                                 Editing Rebase Sequences.
                                                              (line  72)
* c a:                                   コミット開始.        (line  20)
* c A:                                   コミット開始.        (line  72)
* C b:                                   Cloning Repository.  (line  41)
* C C:                                   Cloning Repository.  (line  29)
* c c:                                   コミット開始.        (line  15)
* C d:                                   Cloning Repository.  (line  54)
* C e:                                   Cloning Repository.  (line  61)
* c e:                                   コミット開始.        (line  24)
* c f:                                   コミット開始.        (line  46)
* c F:                                   コミット開始.        (line  55)
* C m:                                   Cloning Repository.  (line  46)
* C s:                                   Cloning Repository.  (line  34)
* c s:                                   コミット開始.        (line  59)
* c S:                                   コミット開始.        (line  68)
* c w:                                   コミット開始.        (line  35)
* C-<return>:                            Visiting Files and Blobs from a Diff.
                                                              (line  51)
* C-<tab>:                               Section Visibility.  (line  13)
* C-c C-a:                               Commit Pseudo Headers.
                                                              (line  17)
* C-c C-b:                               Log Buffer.          (line  22)
* C-c C-b <1>:                           Refreshing Diffs.    (line  88)
* C-c C-c:                               一時的(transient)コマンド.
                                                              (line  18)
* C-c C-c <1>:                           Select from Log.     (line  18)
* C-c C-c <2>:                           コミットメッセージ編集.
                                                              (line  17)
* C-c C-c <3>:                           Editing Rebase Sequences.
                                                              (line   6)
* C-c C-d:                               Refreshing Diffs.    (line  79)
* C-c C-d <1>:                           コミットメッセージ編集.
                                                              (line  58)
* C-c C-e:                               Commands Available in Diffs.
                                                              (line  27)
* C-c C-f:                               Log Buffer.          (line  26)
* C-c C-f <1>:                           Refreshing Diffs.    (line  92)
* C-c C-i:                               Commit Pseudo Headers.
                                                              (line  13)
* C-c C-k:                               Select from Log.     (line  23)
* C-c C-k <1>:                           コミットメッセージ編集.
                                                              (line  23)
* C-c C-k <2>:                           Editing Rebase Sequences.
                                                              (line  11)
* C-c C-n:                               Log Buffer.          (line  30)
* C-c C-o:                               Commit Pseudo Headers.
                                                              (line  33)
* C-c C-p:                               Commit Pseudo Headers.
                                                              (line  37)
* C-c C-r:                               Commit Pseudo Headers.
                                                              (line  21)
* C-c C-s:                               Commit Pseudo Headers.
                                                              (line  25)
* C-c C-t:                               Commands Available in Diffs.
                                                              (line  15)
* C-c C-t <1>:                           Commit Pseudo Headers.
                                                              (line  29)
* C-c C-w:                               Using the Revision Stack.
                                                              (line   6)
* C-c M-g:                               Commands for Buffers Visiting Files.
                                                              (line  21)
* C-c M-g B:                             Blaming.             (line  18)
* C-c M-g b:                             Blaming.             (line  30)
* C-c M-g B <1>:                         Commands for Buffers Visiting Files.
                                                              (line  93)
* C-c M-g B b:                           Blaming.             (line  31)
* C-c M-g B e:                           Blaming.             (line  65)
* C-c M-g B f:                           Blaming.             (line  56)
* C-c M-g B r:                           Blaming.             (line  47)
* C-c M-g c:                             Commands for Buffers Visiting Files.
                                                              (line  39)
* C-c M-g D:                             Commands for Buffers Visiting Files.
                                                              (line  45)
* C-c M-g d:                             Commands for Buffers Visiting Files.
                                                              (line  56)
* C-c M-g e:                             Blaming.             (line  64)
* C-c M-g e <1>:                         Commands for Buffers Visiting Files.
                                                              (line 106)
* C-c M-g f:                             Blaming.             (line  55)
* C-c M-g L:                             Commands for Buffers Visiting Files.
                                                              (line  66)
* C-c M-g l:                             Commands for Buffers Visiting Files.
                                                              (line  77)
* C-c M-g p:                             Commands for Buffers Visiting Files.
                                                              (line 116)
* C-c M-g r:                             Blaming.             (line  46)
* C-c M-g s:                             Commands for Buffers Visiting Files.
                                                              (line  30)
* C-c M-g t:                             Commands for Buffers Visiting Files.
                                                              (line  84)
* C-c M-g u:                             Commands for Buffers Visiting Files.
                                                              (line  34)
* C-c M-i:                               Commit Pseudo Headers.
                                                              (line  42)
* C-c M-s:                               コミットメッセージ編集.
                                                              (line  34)
* C-w:                                   Common Commands.     (line  22)
* C-x g:                                 Status Buffer.       (line  21)
* C-x u:                                 Editing Rebase Sequences.
                                                              (line  94)
* d:                                     Diffing.             (line  20)
* D:                                     Refreshing Diffs.    (line  10)
* d c:                                   Diffing.             (line  69)
* d d:                                   Diffing.             (line  27)
* D f:                                   Refreshing Diffs.    (line  43)
* D F:                                   Refreshing Diffs.    (line  48)
* D g:                                   Refreshing Diffs.    (line  17)
* d p:                                   Diffing.             (line  61)
* d r:                                   Diffing.             (line  31)
* D r:                                   Refreshing Diffs.    (line  38)
* d s:                                   Diffing.             (line  51)
* D s:                                   Refreshing Diffs.    (line  21)
* d t:                                   Diffing.             (line  74)
* D t:                                   Refreshing Diffs.    (line  34)
* d u:                                   Diffing.             (line  57)
* d w:                                   Diffing.             (line  45)
* D w:                                   Refreshing Diffs.    (line  27)
* DEL:                                   Log Buffer.          (line  56)
* DEL <1>:                               Commands Available in Diffs.
                                                              (line  61)
* DEL <2>:                               Blaming.             (line  90)
* DEL <3>:                               Editing Rebase Sequences.
                                                              (line  28)
* e:                                     Ediffing.            (line   9)
* E:                                     Ediffing.            (line  23)
* e <1>:                                 Editing Rebase Sequences.
                                                              (line  55)
* E c:                                   Ediffing.            (line  72)
* E i:                                   Ediffing.            (line  62)
* E m:                                   Ediffing.            (line  38)
* E r:                                   Ediffing.            (line  29)
* E s:                                   Ediffing.            (line  51)
* E u:                                   Ediffing.            (line  57)
* E w:                                   Ediffing.            (line  67)
* E z:                                   Ediffing.            (line  77)
* f:                                     Editing Rebase Sequences.
                                                              (line  63)
* f <1>:                                 Fetching.            (line   9)
* F:                                     Pulling.             (line   9)
* f a:                                   Fetching.            (line  51)
* f C:                                   Branch Commands.     (line  31)
* F C:                                   Branch Commands.     (line  32)
* f e:                                   Fetching.            (line  37)
* F e:                                   Pulling.             (line  31)
* f m:                                   Fetching.            (line  55)
* f o:                                   Fetching.            (line  41)
* f p:                                   Fetching.            (line  16)
* F p:                                   Pulling.             (line  15)
* f r:                                   Fetching.            (line  46)
* f u:                                   Fetching.            (line  24)
* F u:                                   Pulling.             (line  23)
* g:                                     Automatic Refreshing of Magit Buffers.
                                                              (line  23)
* G:                                     Automatic Refreshing of Magit Buffers.
                                                              (line  32)
* j:                                     Log Buffer.          (line  35)
* j <1>:                                 Commands Available in Diffs.
                                                              (line  46)
* k:                                     Viewing Git Output.  (line  23)
* k <1>:                                 Applying.            (line  42)
* k <2>:                                 Editing Rebase Sequences.
                                                              (line  68)
* k <3>:                                 Stashing.            (line  97)
* l:                                     Logging.             (line  27)
* L:                                     Refreshing Logs.     (line  10)
* L <1>:                                 Log Buffer.          (line   6)
* L <2>:                                 Log Margin.          (line  54)
* l <1>:                                 Editing Rebase Sequences.
                                                              (line 115)
* l a:                                   Logging.             (line  60)
* l b:                                   Logging.             (line  55)
* L d:                                   Log Margin.          (line  71)
* L g:                                   Refreshing Logs.     (line  17)
* l h:                                   Logging.             (line  47)
* l H:                                   Reflog.              (line  19)
* l l:                                   Logging.             (line  34)
* l L:                                   Logging.             (line  51)
* L L:                                   Log Margin.          (line  63)
* L l:                                   Log Margin.          (line  67)
* l o:                                   Logging.             (line  40)
* l O:                                   Reflog.              (line  15)
* l r:                                   Reflog.              (line  11)
* L s:                                   Refreshing Logs.     (line  21)
* L t:                                   Refreshing Logs.     (line  34)
* L w:                                   Refreshing Logs.     (line  27)
* m:                                     Merging.             (line   9)
* M:                                     Remote Commands.     (line  13)
* m a:                                   Merging.             (line  45)
* m a <1>:                               Merging.             (line  90)
* M a:                                   Remote Commands.     (line  51)
* M C:                                   Remote Commands.     (line  34)
* m e:                                   Merging.             (line  31)
* m i:                                   Merging.             (line  57)
* M k:                                   Remote Commands.     (line  66)
* m m:                                   Merging.             (line  19)
* m m <1>:                               Merging.             (line  85)
* m n:                                   Merging.             (line  38)
* m p:                                   Merging.             (line  77)
* M p:                                   Remote Commands.     (line  70)
* M P:                                   Remote Commands.     (line  75)
* M r:                                   Remote Commands.     (line  56)
* m s:                                   Merging.             (line  69)
* M u:                                   Remote Commands.     (line  61)
* M-1:                                   Section Visibility.  (line  32)
* M-2:                                   Section Visibility.  (line  33)
* M-3:                                   Section Visibility.  (line  34)
* M-4:                                   Section Visibility.  (line  35)
* M-<tab>:                               Section Visibility.  (line  17)
* M-n:                                   Section Movement.    (line  24)
* M-n <1>:                               コミットメッセージ編集.
                                                              (line  44)
* M-n <2>:                               Editing Rebase Sequences.
                                                              (line  47)
* M-p:                                   Section Movement.    (line  19)
* M-p <1>:                               コミットメッセージ編集.
                                                              (line  38)
* M-p <2>:                               Editing Rebase Sequences.
                                                              (line  43)
* M-w:                                   Blaming.             (line 128)
* M-w <1>:                               Common Commands.     (line  40)
* M-x magit-debug-git-executable:        Git実行ファイル.     (line  55)
* M-x magit-debug-git-executable <1>:    Debugging Tools.     (line  36)
* M-x magit-describe-section-briefly:    Section Types and Values.
                                                              (line  13)
* M-x magit-describe-section-briefly <1>: Matching Sections.  (line   6)
* M-x magit-emacs-Q-command:             Debugging Tools.     (line  16)
* M-x magit-init:                        Creating Repository. (line   6)
* M-x magit-reset-index:                 Staging and Unstaging.
                                                              (line  92)
* M-x magit-reverse-in-index:            Staging and Unstaging.
                                                              (line  66)
* M-x magit-stage-file:                  Staging from File-Visiting Buffers.
                                                              (line  11)
* M-x magit-toggle-buffer-lock:          Modes and Buffers.   (line  18)
* M-x magit-toggle-verbose-refresh:      Debugging Tools.     (line  30)
* M-x magit-unstage-file:                Staging from File-Visiting Buffers.
                                                              (line  20)
* M-x magit-version:                     Git実行ファイル.     (line  61)
* M-x magit-version <1>:                 Debugging Tools.     (line  10)
* M-x magit-wip-commit:                  Wip Modes.           (line  88)
* M-x with-editor-debug:                 Debugging Tools.     (line  44)
* MM:                                    Editing Rebase Sequences.
                                                              (line 125)
* Mt:                                    Editing Rebase Sequences.
                                                              (line 132)
* n:                                     Section Movement.    (line  15)
* n <1>:                                 Blaming.             (line 107)
* N:                                     Blaming.             (line 111)
* n <2>:                                 Editing Rebase Sequences.
                                                              (line  39)
* n <3>:                                 Minor Mode for Buffers Visiting Blobs.
                                                              (line  16)
* o:                                     一時的サブモジュール.
                                                              (line   6)
* O:                                     Subtree.             (line   8)
* o a:                                   一時的サブモジュール.
                                                              (line  21)
* o d:                                   一時的サブモジュール.
                                                              (line  51)
* O e:                                   Subtree.             (line  43)
* O e p:                                 Subtree.             (line  56)
* O e s:                                 Subtree.             (line  61)
* o f:                                   一時的サブモジュール.
                                                              (line  59)
* O i:                                   Subtree.             (line  13)
* O i a:                                 Subtree.             (line  26)
* O i c:                                 Subtree.             (line  31)
* O i f:                                 Subtree.             (line  39)
* O i m:                                 Subtree.             (line  35)
* o l:                                   一時的サブモジュール.
                                                              (line  55)
* o p:                                   一時的サブモジュール.
                                                              (line  35)
* o r:                                   一時的サブモジュール.
                                                              (line  28)
* o s:                                   一時的サブモジュール.
                                                              (line  45)
* o u:                                   一時的サブモジュール.
                                                              (line  40)
* p:                                     Section Movement.    (line  10)
* p <1>:                                 Blaming.             (line 115)
* P:                                     Blaming.             (line 119)
* p <2>:                                 Editing Rebase Sequences.
                                                              (line  35)
* P <1>:                                 Pushing.             (line   9)
* p <3>:                                 Minor Mode for Buffers Visiting Blobs.
                                                              (line  12)
* P C:                                   Branch Commands.     (line  33)
* P e:                                   Pushing.             (line  32)
* P m:                                   Pushing.             (line  51)
* P o:                                   Pushing.             (line  37)
* P p:                                   Pushing.             (line  16)
* P r:                                   Pushing.             (line  42)
* P t:                                   Pushing.             (line  59)
* P T:                                   Pushing.             (line  67)
* P u:                                   Pushing.             (line  24)
* q:                                     Quitting Windows.    (line   6)
* q <1>:                                 Log Buffer.          (line  15)
* q <2>:                                 Blaming.             (line 123)
* q <3>:                                 Minor Mode for Buffers Visiting Blobs.
                                                              (line  20)
* r:                                     Rebasing.            (line   9)
* r <1>:                                 Editing Rebase Sequences.
                                                              (line  51)
* r a:                                   Rebasing.            (line 124)
* r e:                                   Rebasing.            (line  45)
* r e <1>:                               Rebasing.            (line 119)
* r f:                                   Rebasing.            (line  85)
* r i:                                   Rebasing.            (line  81)
* r k:                                   Rebasing.            (line 100)
* r m:                                   Rebasing.            (line  90)
* r p:                                   Rebasing.            (line  29)
* r r:                                   Rebasing.            (line 107)
* r s:                                   Rebasing.            (line  51)
* r s <1>:                               Rebasing.            (line 114)
* r u:                                   Rebasing.            (line  37)
* r w:                                   Rebasing.            (line  95)
* RET:                                   References Buffer.   (line 171)
* RET <1>:                               Visiting Files and Blobs from a Diff.
                                                              (line   8)
* RET <2>:                               Blaming.             (line  76)
* RET <3>:                               Editing Rebase Sequences.
                                                              (line  16)
* s:                                     Staging and Unstaging.
                                                              (line  30)
* S:                                     Staging and Unstaging.
                                                              (line  39)
* s <1>:                                 Editing Rebase Sequences.
                                                              (line  59)
* S-<tab>:                               Section Visibility.  (line  21)
* SPC:                                   Log Buffer.          (line  46)
* SPC <1>:                               Commands Available in Diffs.
                                                              (line  57)
* SPC <2>:                               Blaming.             (line  80)
* SPC <3>:                               Editing Rebase Sequences.
                                                              (line  21)
* t:                                     Editing Rebase Sequences.
                                                              (line 119)
* t <1>:                                 Tagging.             (line   8)
* T:                                     Notes.               (line   8)
* T a:                                   Notes.               (line  53)
* T c:                                   Notes.               (line  48)
* t k:                                   Tagging.             (line  40)
* T m:                                   Notes.               (line  39)
* t p:                                   Tagging.             (line  47)
* T p:                                   Notes.               (line  31)
* t r:                                   Tagging.             (line  21)
* T r:                                   Notes.               (line  23)
* t t:                                   Tagging.             (line  15)
* T T:                                   Notes.               (line  15)
* TAB:                                   Section Visibility.  (line   9)
* u:                                     Staging and Unstaging.
                                                              (line  47)
* U:                                     Staging and Unstaging.
                                                              (line  56)
* v:                                     Applying.            (line  46)
* V:                                     Reverting.           (line   6)
* V A:                                   Reverting.           (line  32)
* V a:                                   Reverting.           (line  40)
* V s:                                   Reverting.           (line  36)
* V V:                                   Reverting.           (line  16)
* V v:                                   Reverting.           (line  22)
* W:                                     Plain Patches.       (line   6)
* w:                                     Maildir Patches.     (line   8)
* w a:                                   Plain Patches.       (line  22)
* w a <1>:                               Maildir Patches.     (line  26)
* w a <2>:                               Maildir Patches.     (line  44)
* W c:                                   Plain Patches.       (line  13)
* w m:                                   Maildir Patches.     (line  22)
* W s:                                   Plain Patches.       (line  29)
* w s:                                   Maildir Patches.     (line  39)
* w w:                                   Maildir Patches.     (line  15)
* w w <1>:                               Maildir Patches.     (line  35)
* x:                                     Editing Rebase Sequences.
                                                              (line  76)
* x <1>:                                 Resetting.           (line   8)
* X f:                                   Resetting.           (line  50)
* X h:                                   Resetting.           (line  26)
* X i:                                   Resetting.           (line  37)
* X k:                                   Resetting.           (line  31)
* X m:                                   Resetting.           (line  15)
* X s:                                   Resetting.           (line  20)
* X w:                                   Resetting.           (line  44)
* X w <1>:                               Wip Modes.           (line  66)
* Y:                                     Cherries.            (line  17)
* y:                                     References Buffer.   (line   6)
* y <1>:                                 Editing Rebase Sequences.
                                                              (line  90)
* y c:                                   References Buffer.   (line  24)
* y o:                                   References Buffer.   (line  30)
* y y:                                   References Buffer.   (line  19)
* z:                                     Stashing.            (line   8)
* z a:                                   Stashing.            (line  60)
* z b:                                   Stashing.            (line  82)
* z B:                                   Stashing.            (line  87)
* z f:                                   Stashing.            (line  93)
* z i:                                   Stashing.            (line  22)
* z I:                                   Stashing.            (line  48)
* z k:                                   Stashing.            (line  73)
* z l:                                   Stashing.            (line 101)
* z p:                                   Stashing.            (line  66)
* z v:                                   Stashing.            (line  78)
* z w:                                   Stashing.            (line  27)
* z W:                                   Stashing.            (line  53)
* z x:                                   Stashing.            (line  34)
* z z:                                   Stashing.            (line  15)
* z Z:                                   Stashing.            (line  41)


File: magit.ja.info,  Node: Command Index,  Next: Function Index,  Prev: Keystroke Index,  Up: Top

Appendix D Command Index
************************

 [index ]
* Menu:

* forward-line:                          Editing Rebase Sequences.
                                                              (line  39)
* git-commit-ack:                        Commit Pseudo Headers.
                                                              (line  17)
* git-commit-cc:                         Commit Pseudo Headers.
                                                              (line  33)
* git-commit-insert-pseudo-header:       Commit Pseudo Headers.
                                                              (line  13)
* git-commit-next-message:               コミットメッセージ編集.
                                                              (line  44)
* git-commit-prev-message:               コミットメッセージ編集.
                                                              (line  38)
* git-commit-reported:                   Commit Pseudo Headers.
                                                              (line  37)
* git-commit-review:                     Commit Pseudo Headers.
                                                              (line  21)
* git-commit-save-message:               コミットメッセージ編集.
                                                              (line  34)
* git-commit-signoff:                    Commit Pseudo Headers.
                                                              (line  25)
* git-commit-suggested:                  Commit Pseudo Headers.
                                                              (line  42)
* git-commit-test:                       Commit Pseudo Headers.
                                                              (line  29)
* git-rebase-backward-line:              Editing Rebase Sequences.
                                                              (line  35)
* git-rebase-break:                      Editing Rebase Sequences.
                                                              (line  85)
* git-rebase-edit:                       Editing Rebase Sequences.
                                                              (line  55)
* git-rebase-exec:                       Editing Rebase Sequences.
                                                              (line  76)
* git-rebase-fixup:                      Editing Rebase Sequences.
                                                              (line  63)
* git-rebase-insert:                     Editing Rebase Sequences.
                                                              (line  90)
* git-rebase-kill-line:                  Editing Rebase Sequences.
                                                              (line  68)
* git-rebase-label:                      Editing Rebase Sequences.
                                                              (line 115)
* git-rebase-merge:                      Editing Rebase Sequences.
                                                              (line 125)
* git-rebase-merge-toggle-editmsg:       Editing Rebase Sequences.
                                                              (line 132)
* git-rebase-move-line-down:             Editing Rebase Sequences.
                                                              (line  47)
* git-rebase-move-line-up:               Editing Rebase Sequences.
                                                              (line  43)
* git-rebase-pick:                       Editing Rebase Sequences.
                                                              (line  72)
* git-rebase-reset:                      Editing Rebase Sequences.
                                                              (line 119)
* git-rebase-reword:                     Editing Rebase Sequences.
                                                              (line  51)
* git-rebase-show-commit:                Editing Rebase Sequences.
                                                              (line  16)
* git-rebase-show-or-scroll-down:        Editing Rebase Sequences.
                                                              (line  28)
* git-rebase-show-or-scroll-up:          Editing Rebase Sequences.
                                                              (line  21)
* git-rebase-squash:                     Editing Rebase Sequences.
                                                              (line  59)
* git-rebase-undo:                       Editing Rebase Sequences.
                                                              (line  94)
* ido-enter-magit-status:                Status Buffer.       (line  93)
* magit-am:                              Maildir Patches.     (line   8)
* magit-am-abort:                        Maildir Patches.     (line  44)
* magit-am-apply-maildir:                Maildir Patches.     (line  22)
* magit-am-apply-patches:                Maildir Patches.     (line  15)
* magit-am-continue:                     Maildir Patches.     (line  35)
* magit-am-skip:                         Maildir Patches.     (line  39)
* magit-apply:                           Applying.            (line  35)
* magit-bisect:                          Bisecting.           (line   8)
* magit-bisect-bad:                      Bisecting.           (line  35)
* magit-bisect-good:                     Bisecting.           (line  40)
* magit-bisect-mark:                     Bisecting.           (line  45)
* magit-bisect-reset:                    Bisecting.           (line  58)
* magit-bisect-run:                      Bisecting.           (line  28)
* magit-bisect-skip:                     Bisecting.           (line  52)
* magit-bisect-start:                    Bisecting.           (line  17)
* magit-blame:                           Blaming.             (line  18)
* magit-blame <1>:                       Blaming.             (line 103)
* magit-blame <2>:                       Commands for Buffers Visiting Files.
                                                              (line  93)
* magit-blame-addition:                  Blaming.             (line  30)
* magit-blame-addition <1>:              Blaming.             (line  31)
* magit-blame-copy-hash:                 Blaming.             (line 128)
* magit-blame-cycle-style:               Blaming.             (line 136)
* magit-blame-echo:                      Blaming.             (line  64)
* magit-blame-echo <1>:                  Blaming.             (line  65)
* magit-blame-next-chunk:                Blaming.             (line 107)
* magit-blame-next-chunk-same-commit:    Blaming.             (line 111)
* magit-blame-previous-chunk:            Blaming.             (line 115)
* magit-blame-previous-chunk-same-commit: Blaming.            (line 119)
* magit-blame-quit:                      Blaming.             (line 123)
* magit-blame-removal:                   Blaming.             (line  46)
* magit-blame-removal <1>:               Blaming.             (line  47)
* magit-blame-reverse:                   Blaming.             (line  55)
* magit-blame-reverse <1>:               Blaming.             (line  56)
* magit-blob-next:                       Minor Mode for Buffers Visiting Blobs.
                                                              (line  16)
* magit-blob-previous:                   Commands for Buffers Visiting Files.
                                                              (line 116)
* magit-blob-previous <1>:               Minor Mode for Buffers Visiting Blobs.
                                                              (line  12)
* magit-branch:                          Branch Commands.     (line  12)
* magit-branch-and-checkout:             Branch Commands.     (line  68)
* magit-branch-checkout:                 Branch Commands.     (line  75)
* magit-branch-configure:                Branch Commands.     (line  30)
* magit-branch-configure <1>:            Branch Commands.     (line  31)
* magit-branch-configure <2>:            Branch Commands.     (line  32)
* magit-branch-configure <3>:            Branch Commands.     (line  33)
* magit-branch-create:                   Branch Commands.     (line  58)
* magit-branch-delete:                   Branch Commands.     (line 148)
* magit-branch-or-checkout:              Branch Commands.     (line 268)
* magit-branch-orphan:                   Branch Commands.     (line 263)
* magit-branch-rename:                   Branch Commands.     (line 154)
* magit-branch-reset:                    Branch Commands.     (line 132)
* magit-branch-shelve:                   Auxiliary Branch Commands.
                                                              (line   9)
* magit-branch-spinoff:                  Branch Commands.     (line  98)
* magit-branch-spinout:                  Branch Commands.     (line 126)
* magit-branch-unshelve:                 Auxiliary Branch Commands.
                                                              (line  20)
* magit-checkout:                        Branch Commands.     (line  50)
* magit-cherry:                          Cherries.            (line  17)
* magit-cherry-apply:                    Cherry Picking.      (line  25)
* magit-cherry-copy:                     Cherry Picking.      (line  18)
* magit-cherry-donate:                   Cherry Picking.      (line  55)
* magit-cherry-harvest:                  Cherry Picking.      (line  43)
* magit-cherry-pick:                     Cherry Picking.      (line   8)
* magit-cherry-spinoff:                  Cherry Picking.      (line  77)
* magit-cherry-spinout:                  Cherry Picking.      (line  66)
* magit-clone:                           Cloning Repository.  (line  20)
* magit-clone-bare:                      Cloning Repository.  (line  41)
* magit-clone-mirror:                    Cloning Repository.  (line  46)
* magit-clone-regular:                   Cloning Repository.  (line  29)
* magit-clone-shallow:                   Cloning Repository.  (line  34)
* magit-clone-shallow-exclude:           Cloning Repository.  (line  61)
* magit-clone-shallow-since:             Cloning Repository.  (line  54)
* magit-commit:                          コミット開始.        (line   8)
* magit-commit <1>:                      Commands for Buffers Visiting Files.
                                                              (line  39)
* magit-commit-amend:                    コミット開始.        (line  20)
* magit-commit-augment:                  コミット開始.        (line  72)
* magit-commit-create:                   コミット開始.        (line  15)
* magit-commit-extend:                   コミット開始.        (line  24)
* magit-commit-fixup:                    コミット開始.        (line  46)
* magit-commit-instant-fixup:            コミット開始.        (line  55)
* magit-commit-instant-squash:           コミット開始.        (line  68)
* magit-commit-reword:                   コミット開始.        (line  35)
* magit-commit-squash:                   コミット開始.        (line  59)
* magit-copy-buffer-revision:            Common Commands.     (line  40)
* magit-copy-section-value:              Common Commands.     (line  22)
* magit-cycle-margin-style:              Log Margin.          (line  67)
* magit-debug-git-executable:            Git実行ファイル.     (line  55)
* magit-debug-git-executable <1>:        Debugging Tools.     (line  36)
* magit-describe-section-briefly:        Section Types and Values.
                                                              (line  13)
* magit-describe-section-briefly <1>:    Matching Sections.   (line   6)
* magit-diff:                            Diffing.             (line  20)
* magit-diff <1>:                        Commands for Buffers Visiting Files.
                                                              (line  45)
* magit-diff-buffer-file:                Commands for Buffers Visiting Files.
                                                              (line  56)
* magit-diff-default-context:            Refreshing Diffs.    (line  71)
* magit-diff-dwim:                       Diffing.             (line  27)
* magit-diff-edit-hunk-commit:           Commands Available in Diffs.
                                                              (line  27)
* magit-diff-flip-revs:                  Refreshing Diffs.    (line  43)
* magit-diff-less-context:               Refreshing Diffs.    (line  61)
* magit-diff-more-context:               Refreshing Diffs.    (line  66)
* magit-diff-paths:                      Diffing.             (line  61)
* magit-diff-range:                      Diffing.             (line  31)
* magit-diff-refresh:                    Refreshing Diffs.    (line  10)
* magit-diff-refresh <1>:                Refreshing Diffs.    (line  17)
* magit-diff-save-default-arguments:     Refreshing Diffs.    (line  27)
* magit-diff-set-default-arguments:      Refreshing Diffs.    (line  21)
* magit-diff-show-or-scroll-down:        Log Buffer.          (line  56)
* magit-diff-show-or-scroll-down <1>:    Blaming.             (line  90)
* magit-diff-show-or-scroll-up:          Log Buffer.          (line  46)
* magit-diff-show-or-scroll-up <1>:      Blaming.             (line  80)
* magit-diff-staged:                     Diffing.             (line  51)
* magit-diff-switch-range-type:          Refreshing Diffs.    (line  38)
* magit-diff-toggle-file-filter:         Refreshing Diffs.    (line  48)
* magit-diff-toggle-refine-hunk:         Refreshing Diffs.    (line  34)
* magit-diff-trace-definition:           Commands Available in Diffs.
                                                              (line  15)
* magit-diff-unstaged:                   Diffing.             (line  57)
* magit-diff-visit-file:                 Visiting Files and Blobs from a Diff.
                                                              (line   8)
* magit-diff-visit-file-other-frame:     Visiting Files and Blobs from a Diff.
                                                              (line  73)
* magit-diff-visit-file-other-window:    Visiting Files and Blobs from a Diff.
                                                              (line  72)
* magit-diff-visit-file-worktree:        Visiting Files and Blobs from a Diff.
                                                              (line  51)
* magit-diff-visit-worktree-file-other-frame: Visiting Files and Blobs from a Diff.
                                                              (line  75)
* magit-diff-visit-worktree-file-other-window: Visiting Files and Blobs from a Diff.
                                                              (line  74)
* magit-diff-while-committing:           Refreshing Diffs.    (line  79)
* magit-diff-while-committing <1>:       コミットメッセージ編集.
                                                              (line  58)
* magit-diff-working-tree:               Diffing.             (line  45)
* magit-discard:                         Applying.            (line  42)
* magit-dispatch:                        一時的(transient)コマンド.
                                                              (line  18)
* magit-display-repository-buffer:       Common Commands.     (line   9)
* magit-ediff:                           Ediffing.            (line  23)
* magit-ediff-compare:                   Ediffing.            (line  29)
* magit-ediff-dwim:                      Ediffing.            (line   9)
* magit-ediff-resolve:                   Ediffing.            (line  38)
* magit-ediff-show-commit:               Ediffing.            (line  72)
* magit-ediff-show-staged:               Ediffing.            (line  62)
* magit-ediff-show-stash:                Ediffing.            (line  77)
* magit-ediff-show-unstaged:             Ediffing.            (line  57)
* magit-ediff-show-working-tree:         Ediffing.            (line  67)
* magit-ediff-stage:                     Ediffing.            (line  51)
* magit-edit-line-commit:                Commands for Buffers Visiting Files.
                                                              (line 106)
* magit-emacs-Q-command:                 Debugging Tools.     (line  16)
* magit-fetch:                           Fetching.            (line   9)
* magit-fetch-all:                       Fetching.            (line  51)
* magit-fetch-branch:                    Fetching.            (line  41)
* magit-fetch-from-pushremote:           Fetching.            (line  16)
* magit-fetch-from-upstream:             Fetching.            (line  24)
* magit-fetch-modules:                   一時的サブモジュール.
                                                              (line  59)
* magit-fetch-other:                     Fetching.            (line  37)
* magit-fetch-refspec:                   Fetching.            (line  46)
* magit-file-checkout:                   Resetting.           (line  50)
* magit-file-checkout <1>:               Commands for Buffers Visiting Files.
                                                              (line 135)
* magit-file-delete:                     Commands for Buffers Visiting Files.
                                                              (line 127)
* magit-file-dispatch:                   Commands for Buffers Visiting Files.
                                                              (line  21)
* magit-file-rename:                     Commands for Buffers Visiting Files.
                                                              (line 123)
* magit-file-untrack:                    Commands for Buffers Visiting Files.
                                                              (line 131)
* magit-find-file:                       General-Purpose Visit Commands.
                                                              (line   9)
* magit-find-file-other-frame:           General-Purpose Visit Commands.
                                                              (line  21)
* magit-find-file-other-window:          General-Purpose Visit Commands.
                                                              (line  15)
* magit-git-command:                     Gitを手動で実行.     (line  25)
* magit-git-command-topdir:              Gitを手動で実行.     (line  17)
* magit-go-backward:                     Log Buffer.          (line  22)
* magit-go-backward <1>:                 Refreshing Diffs.    (line  88)
* magit-go-forward:                      Log Buffer.          (line  26)
* magit-go-forward <1>:                  Refreshing Diffs.    (line  92)
* magit-init:                            Creating Repository. (line   6)
* magit-jump-to-diffstat-or-diff:        Commands Available in Diffs.
                                                              (line  46)
* magit-kill-this-buffer:                Minor Mode for Buffers Visiting Blobs.
                                                              (line  20)
* magit-list-repositories:               Repository List.     (line   6)
* magit-list-submodules:                 Listing Submodules.  (line  13)
* magit-list-submodules <1>:             一時的サブモジュール.
                                                              (line  55)
* magit-log:                             Logging.             (line  27)
* magit-log <1>:                         Commands for Buffers Visiting Files.
                                                              (line  66)
* magit-log-all:                         Logging.             (line  60)
* magit-log-all-branches:                Logging.             (line  55)
* magit-log-branches:                    Logging.             (line  51)
* magit-log-buffer-file:                 Commands for Buffers Visiting Files.
                                                              (line  77)
* magit-log-bury-buffer:                 Log Buffer.          (line  15)
* magit-log-current:                     Logging.             (line  34)
* magit-log-double-commit-limit:         Log Buffer.          (line  72)
* magit-log-half-commit-limit:           Log Buffer.          (line  76)
* magit-log-head:                        Logging.             (line  47)
* magit-log-move-to-parent:              Log Buffer.          (line  30)
* magit-log-move-to-revision:            Log Buffer.          (line  35)
* magit-log-other:                       Logging.             (line  40)
* magit-log-refresh:                     Refreshing Logs.     (line  10)
* magit-log-refresh <1>:                 Refreshing Logs.     (line  17)
* magit-log-refresh <2>:                 Log Buffer.          (line   6)
* magit-log-save-default-arguments:      Refreshing Logs.     (line  27)
* magit-log-select-pick:                 Select from Log.     (line  18)
* magit-log-select-quit:                 Select from Log.     (line  23)
* magit-log-set-default-arguments:       Refreshing Logs.     (line  21)
* magit-log-toggle-commit-limit:         Log Buffer.          (line  66)
* magit-log-trace-definition:            Commands for Buffers Visiting Files.
                                                              (line  84)
* magit-margin-settings:                 Log Margin.          (line  54)
* magit-merge:                           Merging.             (line   9)
* magit-merge <1>:                       Merging.             (line  85)
* magit-merge-abort:                     Merging.             (line  90)
* magit-merge-absorb:                    Merging.             (line  45)
* magit-merge-editmsg:                   Merging.             (line  31)
* magit-merge-into:                      Merging.             (line  57)
* magit-merge-nocommit:                  Merging.             (line  38)
* magit-merge-plain:                     Merging.             (line  19)
* magit-merge-preview:                   Merging.             (line  77)
* magit-merge-squash:                    Merging.             (line  69)
* magit-mode-bury-buffer:                Quitting Windows.    (line   6)
* magit-notes:                           Notes.               (line   8)
* magit-notes-edit:                      Notes.               (line  15)
* magit-notes-merge:                     Notes.               (line  39)
* magit-notes-merge-abort:               Notes.               (line  53)
* magit-notes-merge-commit:              Notes.               (line  48)
* magit-notes-prune:                     Notes.               (line  31)
* magit-notes-remove:                    Notes.               (line  23)
* magit-patch:                           Plain Patches.       (line   6)
* magit-patch-apply:                     Plain Patches.       (line  22)
* magit-patch-apply <1>:                 Maildir Patches.     (line  26)
* magit-patch-create:                    Plain Patches.       (line  13)
* magit-patch-save:                      Plain Patches.       (line  29)
* magit-pop-revision-stack:              Using the Revision Stack.
                                                              (line   6)
* magit-process:                         Viewing Git Output.  (line  16)
* magit-process-kill:                    Viewing Git Output.  (line  23)
* magit-pull:                            Pulling.             (line   9)
* magit-pull-branch:                     Pulling.             (line  31)
* magit-pull-from-pushremote:            Pulling.             (line  15)
* magit-pull-from-upstream:              Pulling.             (line  23)
* magit-push:                            Pushing.             (line   9)
* magit-push-current:                    Pushing.             (line  32)
* magit-push-current-to-pushremote:      Pushing.             (line  16)
* magit-push-current-to-upstream:        Pushing.             (line  24)
* magit-push-implicitly args:            Pushing.             (line  84)
* magit-push-matching:                   Pushing.             (line  51)
* magit-push-other:                      Pushing.             (line  37)
* magit-push-refspecs:                   Pushing.             (line  42)
* magit-push-tag:                        Pushing.             (line  67)
* magit-push-tags:                       Pushing.             (line  59)
* magit-push-to-remote remote args:      Pushing.             (line 102)
* magit-rebase:                          Rebasing.            (line   9)
* magit-rebase-abort:                    Rebasing.            (line 124)
* magit-rebase-autosquash:               Rebasing.            (line  85)
* magit-rebase-branch:                   Rebasing.            (line  45)
* magit-rebase-continue:                 Rebasing.            (line 107)
* magit-rebase-edit:                     Rebasing.            (line 119)
* magit-rebase-edit-commit:              Rebasing.            (line  90)
* magit-rebase-interactive:              Rebasing.            (line  81)
* magit-rebase-onto-pushremote:          Rebasing.            (line  29)
* magit-rebase-onto-upstream:            Rebasing.            (line  37)
* magit-rebase-remove-commit:            Rebasing.            (line 100)
* magit-rebase-reword-commit:            Rebasing.            (line  95)
* magit-rebase-skip:                     Rebasing.            (line 114)
* magit-rebase-subset:                   Rebasing.            (line  51)
* magit-reflog-current:                  Reflog.              (line  11)
* magit-reflog-head:                     Reflog.              (line  19)
* magit-reflog-other:                    Reflog.              (line  15)
* magit-refresh:                         Automatic Refreshing of Magit Buffers.
                                                              (line  23)
* magit-refresh-all:                     Automatic Refreshing of Magit Buffers.
                                                              (line  32)
* magit-remote:                          Remote Commands.     (line  13)
* magit-remote-add:                      Remote Commands.     (line  51)
* magit-remote-configure:                Remote Commands.     (line  34)
* magit-remote-prune:                    Remote Commands.     (line  70)
* magit-remote-prune-refspecs:           Remote Commands.     (line  75)
* magit-remote-remove:                   Remote Commands.     (line  66)
* magit-remote-rename:                   Remote Commands.     (line  56)
* magit-remote-set-url:                  Remote Commands.     (line  61)
* magit-reset-hard:                      Resetting.           (line  26)
* magit-reset-index:                     Staging and Unstaging.
                                                              (line  92)
* magit-reset-index <1>:                 Resetting.           (line  37)
* magit-reset-keep:                      Resetting.           (line  31)
* magit-reset-mixed:                     Resetting.           (line  15)
* magit-reset-quickly:                   Resetting.           (line   8)
* magit-reset-soft:                      Resetting.           (line  20)
* magit-reset-worktree:                  Resetting.           (line  44)
* magit-reset-worktree <1>:              Wip Modes.           (line  66)
* magit-reverse:                         Applying.            (line  46)
* magit-reverse-in-index:                Staging and Unstaging.
                                                              (line  66)
* magit-revert:                          Reverting.           (line   6)
* magit-revert-and-commit:               Reverting.           (line  16)
* magit-revert-no-commit:                Reverting.           (line  22)
* magit-run:                             Gitを手動で実行.     (line  11)
* magit-run-git-gui:                     Gitを手動で実行.     (line  66)
* magit-run-gitk:                        Gitを手動で実行.     (line  54)
* magit-run-gitk-all:                    Gitを手動で実行.     (line  58)
* magit-run-gitk-branches:               Gitを手動で実行.     (line  62)
* magit-section-backward:                Section Movement.    (line  10)
* magit-section-backward-siblings:       Section Movement.    (line  19)
* magit-section-cycle:                   Section Visibility.  (line  13)
* magit-section-cycle-diffs:             Section Visibility.  (line  17)
* magit-section-cycle-global:            Section Visibility.  (line  21)
* magit-section-forward:                 Section Movement.    (line  15)
* magit-section-forward-siblings:        Section Movement.    (line  24)
* magit-section-hide:                    Section Visibility.  (line  48)
* magit-section-hide-children:           Section Visibility.  (line  63)
* magit-section-show:                    Section Visibility.  (line  44)
* magit-section-show-children:           Section Visibility.  (line  57)
* magit-section-show-headings:           Section Visibility.  (line  52)
* magit-section-show-level-1:            Section Visibility.  (line  25)
* magit-section-show-level-1-all:        Section Visibility.  (line  32)
* magit-section-show-level-2:            Section Visibility.  (line  26)
* magit-section-show-level-2-all:        Section Visibility.  (line  33)
* magit-section-show-level-3:            Section Visibility.  (line  27)
* magit-section-show-level-3-all:        Section Visibility.  (line  34)
* magit-section-show-level-4:            Section Visibility.  (line  28)
* magit-section-show-level-4-all:        Section Visibility.  (line  35)
* magit-section-toggle:                  Section Visibility.  (line   9)
* magit-section-toggle-children:         Section Visibility.  (line  67)
* magit-section-up:                      Section Movement.    (line  29)
* magit-sequence-abort:                  Cherry Picking.      (line  99)
* magit-sequence-abort <1>:              Reverting.           (line  40)
* magit-sequence-continue:               Cherry Picking.      (line  91)
* magit-sequence-continue <1>:           Reverting.           (line  32)
* magit-sequence-skip:                   Cherry Picking.      (line  95)
* magit-sequence-skip <1>:               Reverting.           (line  36)
* magit-shell-command:                   Gitを手動で実行.     (line  40)
* magit-shell-command-topdir:            Gitを手動で実行.     (line  35)
* magit-show-commit:                     Diffing.             (line  69)
* magit-show-commit <1>:                 Blaming.             (line  76)
* magit-show-refs:                       References Buffer.   (line   6)
* magit-show-refs-current:               References Buffer.   (line  24)
* magit-show-refs-head:                  References Buffer.   (line  19)
* magit-show-refs-other:                 References Buffer.   (line  30)
* magit-snapshot-both:                   Stashing.            (line  41)
* magit-snapshot-index:                  Stashing.            (line  48)
* magit-snapshot-worktree:               Stashing.            (line  53)
* magit-stage:                           Staging and Unstaging.
                                                              (line  30)
* magit-stage-file:                      Staging from File-Visiting Buffers.
                                                              (line  11)
* magit-stage-file <1>:                  Commands for Buffers Visiting Files.
                                                              (line  30)
* magit-stage-modified:                  Staging and Unstaging.
                                                              (line  39)
* magit-stash:                           Stashing.            (line   8)
* magit-stash-apply:                     Stashing.            (line  60)
* magit-stash-both:                      Stashing.            (line  15)
* magit-stash-branch:                    Stashing.            (line  82)
* magit-stash-branch-here:               Stashing.            (line  87)
* magit-stash-clear:                     Stashing.            (line  97)
* magit-stash-drop:                      Stashing.            (line  73)
* magit-stash-format-patch:              Stashing.            (line  93)
* magit-stash-index:                     Stashing.            (line  22)
* magit-stash-keep-index:                Stashing.            (line  34)
* magit-stash-list:                      Stashing.            (line 101)
* magit-stash-pop:                       Stashing.            (line  66)
* magit-stash-show:                      Diffing.             (line  74)
* magit-stash-show <1>:                  Stashing.            (line  78)
* magit-stash-worktree:                  Stashing.            (line  27)
* magit-status:                          Status Buffer.       (line  21)
* magit-status-quick:                    Status Buffer.       (line  68)
* magit-submodule:                       一時的サブモジュール.
                                                              (line   6)
* magit-submodule-add:                   一時的サブモジュール.
                                                              (line  21)
* magit-submodule-fetch:                 Fetching.            (line  55)
* magit-submodule-populate:              一時的サブモジュール.
                                                              (line  35)
* magit-submodule-register:              一時的サブモジュール.
                                                              (line  28)
* magit-submodule-synchronize:           一時的サブモジュール.
                                                              (line  45)
* magit-submodule-unpopulate:            一時的サブモジュール.
                                                              (line  51)
* magit-submodule-update:                一時的サブモジュール.
                                                              (line  40)
* magit-subtree:                         Subtree.             (line   8)
* magit-subtree-add:                     Subtree.             (line  26)
* magit-subtree-add-commit:              Subtree.             (line  31)
* magit-subtree-export:                  Subtree.             (line  43)
* magit-subtree-import:                  Subtree.             (line  13)
* magit-subtree-merge:                   Subtree.             (line  35)
* magit-subtree-pull:                    Subtree.             (line  39)
* magit-subtree-push:                    Subtree.             (line  56)
* magit-subtree-split:                   Subtree.             (line  61)
* magit-switch-to-repository-buffer:     Common Commands.     (line   6)
* magit-switch-to-repository-buffer-other-frame: Common Commands.
                                                              (line   8)
* magit-switch-to-repository-buffer-other-window: Common Commands.
                                                              (line   7)
* magit-tag:                             Tagging.             (line   8)
* magit-tag-create:                      Tagging.             (line  15)
* magit-tag-delete:                      Tagging.             (line  40)
* magit-tag-prune:                       Tagging.             (line  47)
* magit-tag-release:                     Tagging.             (line  21)
* magit-toggle-buffer-lock:              Modes and Buffers.   (line  18)
* magit-toggle-margin:                   Refreshing Logs.     (line  34)
* magit-toggle-margin <1>:               Log Margin.          (line  63)
* magit-toggle-margin-details:           Log Margin.          (line  71)
* magit-toggle-verbose-refresh:          Debugging Tools.     (line  30)
* magit-unstage:                         Staging and Unstaging.
                                                              (line  47)
* magit-unstage-all:                     Staging and Unstaging.
                                                              (line  56)
* magit-unstage-file:                    Staging from File-Visiting Buffers.
                                                              (line  20)
* magit-unstage-file <1>:                Commands for Buffers Visiting Files.
                                                              (line  34)
* magit-version:                         Git実行ファイル.     (line  61)
* magit-version <1>:                     Debugging Tools.     (line  10)
* magit-visit-ref:                       References Buffer.   (line 171)
* magit-wip-commit:                      Wip Modes.           (line  88)
* magit-wip-log:                         Wip Modes.           (line  48)
* magit-wip-log-current:                 Wip Modes.           (line  57)
* magit-worktree:                        Worktree.            (line   8)
* magit-worktree-branch:                 Worktree.            (line  18)
* magit-worktree-checkout:               Worktree.            (line  14)
* magit-worktree-delete:                 Worktree.            (line  26)
* magit-worktree-move:                   Worktree.            (line  22)
* magit-worktree-status:                 Worktree.            (line  31)
* scroll-down:                           Commands Available in Diffs.
                                                              (line  61)
* scroll-up:                             Commands Available in Diffs.
                                                              (line  57)
* with-editor-cancel:                    コミットメッセージ編集.
                                                              (line  23)
* with-editor-cancel <1>:                Editing Rebase Sequences.
                                                              (line  11)
* with-editor-debug:                     Debugging Tools.     (line  44)
* with-editor-finish:                    コミットメッセージ編集.
                                                              (line  17)
* with-editor-finish <1>:                Editing Rebase Sequences.
                                                              (line   6)


File: magit.ja.info,  Node: Function Index,  Next: Variable Index,  Prev: Command Index,  Up: Top

Appendix E Function Index
*************************

 [index ]
* Menu:

* bug-reference-mode:                    Commit Mode and Hooks.
                                                              (line  56)
* git-commit-check-style-conventions:    Commit Message Conventions.
                                                              (line  40)
* git-commit-propertize-diff:            Commit Mode and Hooks.
                                                              (line  47)
* git-commit-save-message:               Commit Mode and Hooks.
                                                              (line  28)
* git-commit-setup-changelog-support:    Commit Mode and Hooks.
                                                              (line  32)
* git-commit-turn-on-auto-fill:          Commit Mode and Hooks.
                                                              (line  37)
* git-commit-turn-on-flyspell:           Commit Mode and Hooks.
                                                              (line  42)
* magit-add-section-hook:                Section Hooks.       (line  21)
* magit-after-save-refresh-status:       Automatic Refreshing of Magit Buffers.
                                                              (line  55)
* magit-branch-or-checkout:              Branch Commands.     (line 268)
* magit-branch-orphan:                   Branch Commands.     (line 263)
* magit-builtin-completing-read:         補完フレームワークのサポート.
                                                              (line  42)
* magit-call-git:                        Calling Git for Effect.
                                                              (line  28)
* magit-call-process:                    Calling Git for Effect.
                                                              (line  32)
* magit-cancel-section:                  Creating Sections.   (line  71)
* magit-completing-read:                 補完フレームワークのサポート.
                                                              (line  60)
* magit-current-section:                 Section Selection.   (line   6)
* magit-define-section-jumper:           Creating Sections.   (line  77)
* magit-diff-scope:                      Matching Sections.   (line 118)
* magit-diff-type:                       Matching Sections.   (line  95)
* magit-diff-visit-file-other-frame:     Visiting Files and Blobs from a Diff.
                                                              (line  73)
* magit-diff-visit-file-other-window:    Visiting Files and Blobs from a Diff.
                                                              (line  72)
* magit-diff-visit-worktree-file-other-frame: Visiting Files and Blobs from a Diff.
                                                              (line  75)
* magit-diff-visit-worktree-file-other-window: Visiting Files and Blobs from a Diff.
                                                              (line  74)
* magit-disable-section-inserter:        Per-Repository Configuration.
                                                              (line  31)
* magit-display-buffer:                  バッファの切り替え.  (line   6)
* magit-display-buffer-fullcolumn-most-v1: バッファの切り替え.
                                                              (line  76)
* magit-display-buffer-fullframe-status-topleft-v1: バッファの切り替え.
                                                              (line  66)
* magit-display-buffer-fullframe-status-v1: バッファの切り替え.
                                                              (line  60)
* magit-display-buffer-same-window-except-diff-v1: バッファの切り替え.
                                                              (line  53)
* magit-display-buffer-traditional:      バッファの切り替え.  (line  45)
* magit-find-file:                       General-Purpose Visit Commands.
                                                              (line   9)
* magit-find-file-other-frame:           General-Purpose Visit Commands.
                                                              (line  21)
* magit-find-file-other-window:          General-Purpose Visit Commands.
                                                              (line  15)
* magit-generate-buffer-name-default-function: バッファの名付け.
                                                              (line  17)
* magit-get-section:                     Matching Sections.   (line  16)
* magit-git:                             Calling Git for Effect.
                                                              (line  50)
* magit-git-exit-code:                   Getting a Value from Git.
                                                              (line  10)
* magit-git-failure:                     Getting a Value from Git.
                                                              (line  19)
* magit-git-false:                       Getting a Value from Git.
                                                              (line  29)
* magit-git-insert:                      Getting a Value from Git.
                                                              (line  34)
* magit-git-items:                       Getting a Value from Git.
                                                              (line  49)
* magit-git-lines:                       Getting a Value from Git.
                                                              (line  44)
* magit-git-str:                         Getting a Value from Git.
                                                              (line  87)
* magit-git-string:                      Getting a Value from Git.
                                                              (line  38)
* magit-git-success:                     Getting a Value from Git.
                                                              (line  14)
* magit-git-true:                        Getting a Value from Git.
                                                              (line  24)
* magit-git-wash:                        Calling Git for Effect.
                                                              (line  55)
* magit-hunk-set-window-start:           Section Movement.    (line  50)
* magit-ido-completing-read:             補完フレームワークのサポート.
                                                              (line  48)
* magit-insert-am-sequence:              Status Sections.     (line  28)
* magit-insert-assumed-unchanged-files:  Status Sections.     (line 120)
* magit-insert-bisect-log:               Status Sections.     (line  47)
* magit-insert-bisect-output:            Status Sections.     (line  38)
* magit-insert-bisect-rest:              Status Sections.     (line  43)
* magit-insert-diff-filter-header:       Status Header Sections.
                                                              (line  38)
* magit-insert-error-header:             Status Header Sections.
                                                              (line  28)
* magit-insert-head-branch-header:       Status Header Sections.
                                                              (line  42)
* magit-insert-heading:                  Creating Sections.   (line  42)
* magit-insert-ignored-files:            Status Sections.     (line 102)
* magit-insert-local-branches:           References Sections. (line  17)
* magit-insert-merge-log:                Status Sections.     (line  18)
* magit-insert-modules:                  Status Module Sections.
                                                              (line  12)
* magit-insert-modules-overview:         Status Module Sections.
                                                              (line  33)
* magit-insert-modules-unpulled-from-pushremote: Status Module Sections.
                                                              (line  51)
* magit-insert-modules-unpulled-from-upstream: Status Module Sections.
                                                              (line  45)
* magit-insert-modules-unpushed-to-pushremote: Status Module Sections.
                                                              (line  63)
* magit-insert-modules-unpushed-to-upstream: Status Module Sections.
                                                              (line  57)
* magit-insert-push-branch-header:       Status Header Sections.
                                                              (line  52)
* magit-insert-rebase-sequence:          Status Sections.     (line  23)
* magit-insert-recent-commits:           Status Sections.     (line 135)
* magit-insert-remote-branches:          References Sections. (line  21)
* magit-insert-remote-header:            Status Header Sections.
                                                              (line  68)
* magit-insert-repo-header:              Status Header Sections.
                                                              (line  64)
* magit-insert-section:                  Creating Sections.   (line   6)
* magit-insert-sequencer-sequence:       Status Sections.     (line  33)
* magit-insert-skip-worktree-files:      Status Sections.     (line 113)
* magit-insert-staged-changes:           Status Sections.     (line  65)
* magit-insert-stashes:                  Status Sections.     (line  69)
* magit-insert-status-headers:           Status Header Sections.
                                                              (line  12)
* magit-insert-tags:                     References Sections. (line  25)
* magit-insert-tags-header:              Status Header Sections.
                                                              (line  57)
* magit-insert-tracked-files:            Status Sections.     (line  98)
* magit-insert-unpulled-cherries:        Status Sections.     (line 147)
* magit-insert-unpulled-from-pushremote: Status Sections.     (line  81)
* magit-insert-unpulled-from-upstream:   Status Sections.     (line  76)
* magit-insert-unpulled-or-recent-commits: Status Sections.   (line 127)
* magit-insert-unpushed-cherries:        Status Sections.     (line 155)
* magit-insert-unpushed-to-pushremote:   Status Sections.     (line  91)
* magit-insert-unpushed-to-upstream:     Status Sections.     (line  86)
* magit-insert-unstaged-changes:         Status Sections.     (line  60)
* magit-insert-untracked-files:          Status Sections.     (line  51)
* magit-insert-upstream-branch-header:   Status Header Sections.
                                                              (line  47)
* magit-insert-user-header:              Status Header Sections.
                                                              (line  76)
* magit-list-submodules:                 Listing Submodules.  (line  13)
* magit-log-maybe-show-more-commits:     Section Movement.    (line  64)
* magit-log-maybe-update-blob-buffer:    Section Movement.    (line  79)
* magit-log-maybe-update-revision-buffer: Section Movement.   (line  72)
* magit-maybe-set-dedicated:             バッファの切り替え.  (line 101)
* magit-mode-display-buffer:             Refreshing Buffers.  (line  33)
* magit-mode-quit-window:                Quitting Windows.    (line  35)
* magit-mode-setup:                      Refreshing Buffers.  (line  17)
* magit-process-file:                    Getting a Value from Git.
                                                              (line  67)
* magit-process-git:                     Getting a Value from Git.
                                                              (line  59)
* magit-push-implicitly:                 Pushing.             (line  84)
* magit-push-to-remote:                  Pushing.             (line 102)
* magit-region-sections:                 Section Selection.   (line  10)
* magit-region-values:                   Section Selection.   (line  37)
* magit-repolist-column-branch:          Repository List.     (line  48)
* magit-repolist-column-branches:        Repository List.     (line  57)
* magit-repolist-column-flag:            Repository List.     (line  65)
* magit-repolist-column-ident:           Repository List.     (line  35)
* magit-repolist-column-path:            Repository List.     (line  40)
* magit-repolist-column-stashes:         Repository List.     (line  61)
* magit-repolist-column-unpulled-from-pushremote: Repository List.
                                                              (line  89)
* magit-repolist-column-unpulled-from-upstream: Repository List.
                                                              (line  84)
* magit-repolist-column-unpushed-to-pushremote: Repository List.
                                                              (line  99)
* magit-repolist-column-unpushed-to-upstream: Repository List.
                                                              (line  94)
* magit-repolist-column-upstream:        Repository List.     (line  52)
* magit-repolist-column-version:         Repository List.     (line  44)
* magit-restore-window-configuration:    Quitting Windows.    (line  24)
* magit-run-git:                         Calling Git for Effect.
                                                              (line  36)
* magit-run-git-async:                   Calling Git for Effect.
                                                              (line  65)
* magit-run-git-with-editor:             Calling Git for Effect.
                                                              (line  78)
* magit-run-git-with-input:              Calling Git for Effect.
                                                              (line  40)
* magit-save-window-configuration:       バッファの切り替え.  (line  90)
* magit-section-case:                    Matching Sections.   (line  71)
* magit-section-ident:                   Matching Sections.   (line  11)
* magit-section-match:                   Matching Sections.   (line  21)
* magit-section-set-window-start:        Section Movement.    (line  57)
* magit-section-value-if:                Matching Sections.   (line  61)
* magit-start-git:                       Calling Git for Effect.
                                                              (line  90)
* magit-start-process:                   Calling Git for Effect.
                                                              (line 109)
* magit-stashes-maybe-update-stash-buffer: Section Movement.  (line 103)
* magit-status-maybe-update-blob-buffer: Section Movement.    (line  97)
* magit-status-maybe-update-revision-buffer: Section Movement.
                                                              (line  85)
* magit-status-maybe-update-stash-buffer: Section Movement.   (line  91)
* with-editor-usage-message:             Commit Mode and Hooks.
                                                              (line  60)
* コマンド:                              Section Visibility.  (line  44)
* コマンド <1>:                          Section Visibility.  (line  48)
* コマンド <2>:                          Section Visibility.  (line  52)
* コマンド <3>:                          Section Visibility.  (line  57)
* コマンド <4>:                          Section Visibility.  (line  63)
* コマンド <5>:                          Section Visibility.  (line  67)
* コマンド <6>:                          Status Buffer.       (line  68)
* コマンド <7>:                          Status Buffer.       (line  93)
* コマンド <8>:                          Repository List.     (line   6)
* コマンド <9>:                          Auxiliary Branch Commands.
                                                              (line   9)
* コマンド <10>:                         Auxiliary Branch Commands.
                                                              (line  20)
* コマンド <11>:                         Common Commands.     (line   6)
* コマンド <12>:                         Common Commands.     (line   7)
* コマンド <13>:                         Common Commands.     (line   8)
* コマンド <14>:                         Common Commands.     (line   9)
* コマンド <15>:                         Wip Modes.           (line  48)
* コマンド <16>:                         Wip Modes.           (line  57)
* コマンド <17>:                         Commands for Buffers Visiting Files.
                                                              (line 123)
* コマンド <18>:                         Commands for Buffers Visiting Files.
                                                              (line 127)
* コマンド <19>:                         Commands for Buffers Visiting Files.
                                                              (line 131)
* コマンド <20>:                         Commands for Buffers Visiting Files.
                                                              (line 135)


File: magit.ja.info,  Node: Variable Index,  Prev: Function Index,  Up: Top

Appendix F Variable Index
*************************

 [index ]
* Menu:

* auto-revert-buffer-list-filter:        Automatic Reverting of File-Visiting Buffers.
                                                              (line  86)
* auto-revert-interval:                  Automatic Reverting of File-Visiting Buffers.
                                                              (line  81)
* auto-revert-mode:                      Automatic Reverting of File-Visiting Buffers.
                                                              (line  67)
* auto-revert-stop-on-user-input:        Automatic Reverting of File-Visiting Buffers.
                                                              (line  76)
* auto-revert-use-notify:                Automatic Reverting of File-Visiting Buffers.
                                                              (line  54)
* auto-revert-verbose:                   Automatic Reverting of File-Visiting Buffers.
                                                              (line 106)
* branch.autoSetupMerge:                 Branch Git Variables.
                                                              (line  81)
* branch.autoSetupRebase:                Branch Git Variables.
                                                              (line  98)
* branch.NAME.description:               Branch Git Variables.
                                                              (line  48)
* branch.NAME.merge:                     Branch Git Variables.
                                                              (line  10)
* branch.NAME.pushRemote:                Branch Git Variables.
                                                              (line  34)
* branch.NAME.rebase:                    Branch Git Variables.
                                                              (line  22)
* branch.NAME.remote:                    Branch Git Variables.
                                                              (line  16)
* core.notesRef:                         Notes.               (line  61)
* git-commit-fill-column:                Commit Message Conventions.
                                                              (line  19)
* git-commit-finish-query-functions:     Commit Message Conventions.
                                                              (line  24)
* git-commit-known-pseudo-headers:       Commit Pseudo Headers.
                                                              (line   9)
* git-commit-major-mode:                 Commit Mode and Hooks.
                                                              (line  12)
* git-commit-setup-hook:                 Commit Mode and Hooks.
                                                              (line  22)
* git-commit-setup-hook <1>:             Commit Mode and Hooks.
                                                              (line  64)
* git-commit-style-convention-checks:    Commit Message Conventions.
                                                              (line  46)
* git-commit-summary-max-length:         Commit Message Conventions.
                                                              (line  13)
* git-rebase-auto-advance:               Editing Rebase Sequences.
                                                              (line  99)
* git-rebase-confirm-cancel:             Editing Rebase Sequences.
                                                              (line 107)
* git-rebase-show-instructions:          Editing Rebase Sequences.
                                                              (line 103)
* global-auto-revert-mode:               Automatic Reverting of File-Visiting Buffers.
                                                              (line  24)
* magit-auto-revert-immediately:         Automatic Reverting of File-Visiting Buffers.
                                                              (line  35)
* magit-auto-revert-mode:                Automatic Reverting of File-Visiting Buffers.
                                                              (line  18)
* magit-auto-revert-tracked-only:        Automatic Reverting of File-Visiting Buffers.
                                                              (line  60)
* magit-bisect-show-graph:               Bisecting.           (line  66)
* magit-blame-disable-modes:             Blaming.             (line 166)
* magit-blame-echo-style:                Blaming.             (line 149)
* magit-blame-goto-chunk-hook:           Blaming.             (line 172)
* magit-blame-read-only:                 Blaming.             (line 161)
* magit-blame-styles:                    Blaming.             (line 144)
* magit-blame-time-format:               Blaming.             (line 156)
* magit-branch-adjust-remote-upstream-alist: Branch Commands. (line 211)
* magit-branch-direct-configure:         Branch Commands.     (line  21)
* magit-branch-prefer-remote-upstream:   Branch Commands.     (line 166)
* magit-branch-read-upstream-first:      Branch Commands.     (line 160)
* magit-buffer-name-format:              バッファの名付け.    (line  27)
* magit-bury-buffer-function:            Quitting Windows.    (line  14)
* magit-cherry-margin:                   Cherries.            (line  22)
* magit-clone-always-transient:          Cloning Repository.  (line  12)
* magit-clone-default-directory:         Cloning Repository.  (line  90)
* magit-clone-name-alist:                Cloning Repository.  (line 103)
* magit-clone-set-remote-head:           Cloning Repository.  (line  68)
* magit-clone-set-remote.pushDefault:    Cloning Repository.  (line  78)
* magit-clone-url-format:                Cloning Repository.  (line 124)
* magit-commit-ask-to-stage:             コミット開始.        (line  81)
* magit-commit-extend-override-date:     コミット開始.        (line  90)
* magit-commit-reword-override-date:     コミット開始.        (line  94)
* magit-commit-show-diff:                コミット開始.        (line  86)
* magit-commit-squash-confirm:           コミット開始.        (line  98)
* magit-completing-read-function:        補完フレームワークのサポート.
                                                              (line  28)
* magit-define-global-key-bindings:      Default Bindings.    (line   6)
* magit-diff-adjust-tab-width:           Diff Options.        (line  23)
* magit-diff-buffer-file-locked:         Commands for Buffers Visiting Files.
                                                              (line  61)
* magit-diff-extra-stat-arguments:       Diff Options.        (line 132)
* magit-diff-hide-trailing-cr-characters: Diff Options.       (line  96)
* magit-diff-highlight-hunk-region-functions: Diff Options.   (line 100)
* magit-diff-highlight-indentation:      Diff Options.        (line  80)
* magit-diff-highlight-trailing:         Diff Options.        (line  75)
* magit-diff-paint-whitespace:           Diff Options.        (line  46)
* magit-diff-paint-whitespace-lines:     Diff Options.        (line  63)
* magit-diff-refine-hunk:                Diff Options.        (line   6)
* magit-diff-refine-ignore-whitespace:   Diff Options.        (line  18)
* magit-diff-unmarked-lines-keep-foreground: Diff Options.    (line 125)
* magit-diff-visit-previous-blob:        Visiting Files and Blobs from a Diff.
                                                              (line  39)
* magit-direct-use-buffer-arguments:     一時的引数とバッファ変数.
                                                              (line  65)
* magit-display-buffer-function:         バッファの切り替え.  (line  27)
* magit-display-buffer-noselect:         バッファの切り替え.  (line  18)
* magit-dwim-selection:                  補完と確認.          (line  38)
* magit-ediff-dwim-show-on-hunks:        Ediffing.            (line  82)
* magit-ediff-quit-hook:                 Ediffing.            (line  98)
* magit-ediff-show-stash-with-index:     Ediffing.            (line  91)
* magit-generate-buffer-name-function:   バッファの名付け.    (line   6)
* magit-git-debug:                       Viewing Git Output.  (line  28)
* magit-git-debug <1>:                   Getting a Value from Git.
                                                              (line  79)
* magit-git-executable:                  Git実行ファイル.     (line  26)
* magit-git-global-arguments:            Global Git Arguments.
                                                              (line   6)
* magit-keep-region-overlay:             選択範囲.            (line  48)
* magit-list-refs-sortby:                追加の補完オプション.
                                                              (line   6)
* magit-log-auto-more:                   Log Buffer.          (line  80)
* magit-log-buffer-file-locked:          Commands for Buffers Visiting Files.
                                                              (line  88)
* magit-log-margin:                      Log Margin.          (line  12)
* magit-log-margin-show-committer-date:  Log Margin.          (line  46)
* magit-log-section-commit-count:        Status Sections.     (line 140)
* magit-log-select-margin:               Select from Log.     (line  28)
* magit-log-show-refname-after-summary:  Log Buffer.          (line  86)
* magit-log-trace-definition-function:   Commands Available in Diffs.
                                                              (line  20)
* magit-module-sections-hook:            Status Module Sections.
                                                              (line  20)
* magit-module-sections-nested:          Status Module Sections.
                                                              (line  24)
* magit-no-confirm:                      アクションの確認.    (line  17)
* magit-pop-revision-stack-format:       Using the Revision Stack.
                                                              (line  35)
* magit-post-commit-hook:                コミット開始.        (line 107)
* magit-post-display-buffer-hook:        バッファの切り替え.  (line  96)
* magit-pre-display-buffer-hook:         バッファの切り替え.  (line  85)
* magit-prefer-remote-upstream:          Branch Git Variables.
                                                              (line 127)
* magit-prefix-use-buffer-arguments:     一時的引数とバッファ変数.
                                                              (line  56)
* magit-process-raise-error:             Calling Git for Effect.
                                                              (line 136)
* magit-pull-or-fetch:                   Fetching.            (line  60)
* magit-reflog-margin:                   Reflog.              (line  23)
* magit-refresh-args:                    Refreshing Buffers.  (line  55)
* magit-refresh-buffer-hook:             Automatic Refreshing of Magit Buffers.
                                                              (line  41)
* magit-refresh-function:                Refreshing Buffers.  (line  49)
* magit-refresh-status-buffer:           Automatic Refreshing of Magit Buffers.
                                                              (line  46)
* magit-refs-filter-alist:               References Buffer.   (line 151)
* magit-refs-focus-column-width:         References Buffer.   (line  79)
* magit-refs-margin:                     References Buffer.   (line  93)
* magit-refs-margin-for-tags:            References Buffer.   (line 119)
* magit-refs-pad-commit-counts:          References Buffer.   (line  48)
* magit-refs-primary-column-width:       References Buffer.   (line  68)
* magit-refs-sections-hook:              References Sections. (line  13)
* magit-refs-show-commit-count:          References Buffer.   (line  35)
* magit-refs-show-remote-prefix:         References Buffer.   (line  61)
* magit-remote-add-set-remote.pushDefault: Remote Commands.   (line  93)
* magit-remote-direct-configure:         Remote Commands.     (line  22)
* magit-remote-git-executable:           Git実行ファイル.     (line  33)
* magit-repolist-columns:                Repository List.     (line  14)
* magit-repository-directories:          Status Buffer.       (line  55)
* magit-revision-filter-files-on-follow: Revision Buffer.     (line  60)
* magit-revision-insert-related-refs:    Revision Buffer.     (line   6)
* magit-revision-show-gravatars:         Revision Buffer.     (line  19)
* magit-revision-use-hash-sections:      Revision Buffer.     (line  35)
* magit-root-section:                    Matching Sections.   (line  87)
* magit-save-repository-buffers:         Automatic Saving of File-Visiting Buffers.
                                                              (line  12)
* magit-section-cache-visibility:        Section Visibility.  (line  95)
* magit-section-initial-visibility-alist: Section Visibility. (line  77)
* magit-section-movement-hook:           Section Movement.    (line  45)
* magit-section-set-visibility-hook:     Section Visibility.  (line 106)
* magit-section-show-child-count:        Section Options.     (line   9)
* magit-section-visibility-indicator:    Section Visibility.  (line 123)
* magit-shell-command-verbose-prompt:    Gitを手動で実行.     (line  47)
* magit-stashes-margin:                  Stashing.            (line 105)
* magit-status-headers-hook:             Status Header Sections.
                                                              (line  18)
* magit-status-margin:                   Status Options.      (line  10)
* magit-status-refresh-hook:             Status Options.      (line   6)
* magit-status-sections-hook:            Status Sections.     (line  10)
* magit-submodule-list-columns:          Listing Submodules.  (line  21)
* magit-this-process:                    Calling Git for Effect.
                                                              (line 131)
* magit-uniquify-buffer-names:           バッファの名付け.    (line  74)
* magit-unstage-committed:               Staging and Unstaging.
                                                              (line  60)
* magit-update-other-window-delay:       Section Movement.    (line 109)
* magit-visit-ref-behavior:              References Buffer.   (line 182)
* magit-wip-after-apply-mode:            Legacy Wip Modes.    (line  19)
* magit-wip-after-apply-mode-lighter:    Legacy Wip Modes.    (line  59)
* magit-wip-after-save-local-mode-lighter: Legacy Wip Modes.  (line  55)
* magit-wip-after-save-mode:             Legacy Wip Modes.    (line  13)
* magit-wip-before-change-mode:          Legacy Wip Modes.    (line  33)
* magit-wip-before-change-mode-lighter:  Legacy Wip Modes.    (line  63)
* magit-wip-initial-backup-mode:         Legacy Wip Modes.    (line  38)
* magit-wip-initial-backup-mode-lighter: Legacy Wip Modes.    (line  67)
* magit-wip-merge-branch:                Wip Graph.           (line   6)
* magit-wip-mode:                        Wip Modes.           (line  30)
* magit-wip-mode-lighter:                Wip Modes.           (line 104)
* magit-wip-namespace:                   Wip Modes.           (line  96)
* notes.displayRef:                      Notes.               (line  66)
* pull.rebase:                           Branch Git Variables.
                                                              (line  57)
* remote.NAME.fetch:                     Remote Git Variables.
                                                              (line  15)
* remote.NAME.push:                      Remote Git Variables.
                                                              (line  26)
* remote.NAME.pushurl:                   Remote Git Variables.
                                                              (line  20)
* remote.NAME.tagOpts:                   Remote Git Variables.
                                                              (line  31)
* remote.NAME.url:                       Remote Git Variables.
                                                              (line  10)
* remote.pushDefault:                    Branch Git Variables.
                                                              (line  71)



Tag Table:
Node: Top782
Node: Introduction7473
Node: Installation14076
Node: Installing from Melpa14499
Node: Installing from the Git Repository15815
Node: Post-Installation Tasks19235
Node: Getting Started20852
Node: Interface Concepts28469
Node: Modes and Buffers28890
Node: バッファの切り替え31378
Node: バッファの名付け37541
Node: Quitting Windows41666
Node: Automatic Refreshing of Magit Buffers44071
Node: Automatic Saving of File-Visiting Buffers47793
Node: Automatic Reverting of File-Visiting Buffers49288
Node: 自動的に元に戻るリスク55895
Node: Sections59004
Node: Section Movement60262
Node: Section Visibility66378
Node: Section Hooks74426
Node: Section Types and Values77817
Node: Section Options79569
Node: 一時的(transient)コマンド80155
Node: 一時的引数とバッファ変数81869
Node: Completion Confirmation(確認補完)とSelection(選択範囲)90588
Node: アクションの確認91101
Node: 補完と確認101576
Node: 選択範囲105810
Node: ハンク内部リージョン109699
Node: 補完フレームワークのサポート111162
Node: 追加の補完オプション117191
Node: Running Git117957
Node: Viewing Git Output118263
Node: Git Process Status119742
Node: Gitを手動で実行120935
Node: Git実行ファイル124181
Node: Global Git Arguments128287
Node: Inspecting129371
Node: Status Buffer130622
Node: Status Sections136945
Node: Status Header Sections144525
Node: Status Module Sections147832
Node: Status Options151240
Node: Repository List153118
Node: Logging157295
Node: Refreshing Logs160572
Node: Log Buffer162361
Node: Log Margin168050
Node: Select from Log172235
Node: Reflog175111
Node: Cherries177164
Node: Diffing179622
Node: Refreshing Diffs183598
Node: Commands Available in Diffs188110
Node: Diff Options191469
Node: Revision Buffer198510
Node: Ediffing202796
Node: References Buffer208099
Node: References Sections220547
Node: Bisecting221411
Node: Visiting Files and Blobs223878
Node: General-Purpose Visit Commands224351
Node: Visiting Files and Blobs from a Diff225310
Node: Blaming228769
Node: Manipulating235204
Node: Creating Repository235549
Node: Cloning Repository236107
Node: Staging and Unstaging241512
Node: Staging from File-Visiting Buffers247433
Node: Applying249220
Node: Committing252000
Node: コミット開始252595
Node: コミットメッセージ編集257435
Node: Using the Revision Stack261070
Node: Commit Pseudo Headers264134
Node: Commit Mode and Hooks265483
Node: Commit Message Conventions268462
Node: Branching270603
Node: The Two Remotes270832
Node: Branch Commands273473
Node: Branch Git Variables286372
Node: Auxiliary Branch Commands291770
Node: Merging292901
Node: Resolving Conflicts298151
Node: Rebasing304468
Node: Editing Rebase Sequences309435
Node: Information About In-Progress Rebase313763
Ref: Information About In-Progress Rebase-Footnote-1322628
Node: Cherry Picking323224
Node: Reverting327662
Node: Resetting329203
Node: Stashing331090
Node: Transferring336178
Node: Remotes336403
Node: Remote Commands336558
Node: Remote Git Variables340756
Node: Fetching342038
Node: Pulling344640
Node: Pushing345808
Node: Plain Patches350255
Node: Maildir Patches351841
Node: Miscellaneous353466
Node: Tagging353783
Node: Notes356245
Node: Submodules358934
Node: Listing Submodules359184
Node: 一時的サブモジュール360690
Node: Subtree363330
Node: Worktree365517
Node: Common Commands366745
Node: Wip Modes369403
Node: Wip Graph374327
Node: Legacy Wip Modes376629
Node: Commands for Buffers Visiting Files379520
Node: Minor Mode for Buffers Visiting Blobs385259
Node: Customizing386073
Node: Per-Repository Configuration388011
Node: 基本設定390250
Node: Safety390576
Node: Performance392554
Ref: Log Performance395556
Ref: Diff Performance396853
Ref: Refs Buffer Performance398188
Ref: Committing Performance398757
Node: Microsoft Windows Performance399667
Node: MacOS Performance400852
Ref: MacOS Performance-Footnote-1401557
Node: Default Bindings401639
Node: 配管コマンド(Plumbing)403878
Node: Calling Git404923
Node: Getting a Value from Git406461
Node: Calling Git for Effect410202
Node: Section Plumbing416099
Node: Creating Sections416350
Node: Section Selection420253
Node: Matching Sections422055
Node: Refreshing Buffers428028
Node: 慣習431191
Node: Theming Faces431400
Node: FAQ439471
Node: FAQ - How to ...?439996
Node: Magitの発音は？440456
Node: How to show git's output?441409
Node: How to install the gitman info manual?442437
Node: How to show diffs for gpg-encrypted files?443718
Node: How does branching and pushing work?444317
Node: Magitをediff-version-control-packageとして使用できますか？444702
Node: VC@を無効にする必要がありますか？446789
Node: FAQ - Issues and Errors447492
Node: Magit is slow448757
Node: 一度に数千のファイルを変更したらMagitが使用できなくなりました448997
Node: コミットに問題があります449772
Node: MS WindowsではMagitでpushできません450333
Node: I am using OS X and SOMETHING works in shell but not in Magit450984
Node: ファイルを展開して差分を表示するとファイルが消えます451832
Node: COMMIT_EDITMSGバッファのpointが間違っています452471
Node: モード行の情報が常に最新ではない453567
Node: 同じ名前を共有するブランチとタグは何かを壊します454739
Node: 私のGitフックはコマンドラインでは機能しますが、Magit内では機能しません455694
Node: コマンドラインからコミットする場合、git-commit-modeは使用されません456687
Node: file-visitingバッファにジャンプすると、ポイントは非表示のテキスト内に表示されています459080
Node: MS-WindowsからEmacsのTrampモードを使用するとステージできません460107
Node: 私はポップアップのデフォルトを保存できなくなりました461166
Node: Debugging Tools462236
Node: Keystroke Index465056
Node: Command Index499589
Node: Function Index537653
Node: Variable Index554693

End Tag Table


Local Variables:
coding: utf-8
End:
